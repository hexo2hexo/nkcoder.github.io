<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Daniel&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/dbe2d186662d66cacfa4d77a8b3b00e1</icon>
  <subtitle>Salvation lies within！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nkcoder.github.io/"/>
  <updated>2017-10-14T14:28:47.000Z</updated>
  <id>http://nkcoder.github.io/</id>
  
  <author>
    <name>Daniel</name>
    <email>nkcoder@icloud.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【问答系列】Sudo时让环境变量继续有效</title>
    <link href="http://nkcoder.github.io/2017/10/14/how-to-preserve-env-in-sudo/"/>
    <id>http://nkcoder.github.io/2017/10/14/how-to-preserve-env-in-sudo/</id>
    <published>2017-10-14T13:31:12.000Z</published>
    <updated>2017-10-14T14:28:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在执行一个python脚本时，需要使用到一个环境变量，并且需要sudo权限才能执行。设置了环境变量后，在sudo执行脚本时还是找不到该环境变量。</p><p>因为sudo是一个新的环境，默认不会使用已有的环境变量。如果要sudo使用环境变量，有以下几种方式可以实现。</p><h2 id="1-sudo时指定环境变量"><a href="#1-sudo时指定环境变量" class="headerlink" title="1. sudo时指定环境变量"></a>1. <code>sudo</code>时指定环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~ sudo JUST_TEST=<span class="string">'hello, test'</span> bash -c <span class="string">'echo $JUST_TEST'</span></div><div class="line">hello, <span class="built_in">test</span></div></pre></td></tr></table></figure><a id="more"></a><h2 id="2-使用sudo的-E选项"><a href="#2-使用sudo的-E选项" class="headerlink" title="2. 使用sudo的-E选项"></a>2. 使用<code>sudo</code>的<code>-E</code>选项</h2><p>通过<code>man sudo</code>查看sudo的用法，有一个<code>-E</code>选项，说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-E, --preserve-env</div><div class="line">            Indicates to the security policy that the user wishes to preserve</div><div class="line">            their existing environment variables.  The security policy may return</div><div class="line">            an error if the user does not have permission to preserve the</div><div class="line">            environment.</div></pre></td></tr></table></figure><p><code>-E</code>选项表示用户希望使用已有的环境变量，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  ~ <span class="built_in">export</span> JUST_TEST2=<span class="string">'hello, test2'</span></div><div class="line">➜  ~ sudo -E bash -c <span class="string">'echo $JUST_TEST2'</span></div><div class="line">hello, test2</div></pre></td></tr></table></figure><h2 id="3-通过visudo在sudoers中设置环境变量"><a href="#3-通过visudo在sudoers中设置环境变量" class="headerlink" title="3. 通过visudo在sudoers中设置环境变量"></a>3. 通过<code>visudo</code>在sudoers中设置环境变量</h2><p>在<code>/etc/sudoers</code>中设置的环境变量，<code>sudo</code>是可以使用的。但为了安全，最好不要直接编辑<code>/etc/sudoers</code>文件，而应该使用<code>visudo</code>命令修改，该命令在修改<code>/etc/sudoers</code>文件之前会进行语法检查。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  ~ <span class="built_in">export</span> JUST_TEST3=<span class="string">'hello, test3'</span></div><div class="line">➜  ~ sudo visudo</div><div class="line">  Defaults        env_keep= <span class="string">"JUST_TEST3"</span></div><div class="line">➜  ~ sudo bash -c <span class="string">'echo $JUST_TEST3'</span></div><div class="line">hello, test3</div></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://stackoverflow.com/questions/8633461/how-to-keep-environment-variables-when-using-sudo" target="_blank" rel="external">How to keep Environment Variables when Using SUDO</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在执行一个python脚本时，需要使用到一个环境变量，并且需要sudo权限才能执行。设置了环境变量后，在sudo执行脚本时还是找不到该环境变量。&lt;/p&gt;
&lt;p&gt;因为sudo是一个新的环境，默认不会使用已有的环境变量。如果要sudo使用环境变量，有以下几种方式可以实现。&lt;/p&gt;
&lt;h2 id=&quot;1-sudo时指定环境变量&quot;&gt;&lt;a href=&quot;#1-sudo时指定环境变量&quot; class=&quot;headerlink&quot; title=&quot;1. sudo时指定环境变量&quot;&gt;&lt;/a&gt;1. &lt;code&gt;sudo&lt;/code&gt;时指定环境变量&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;➜  ~ sudo JUST_TEST=&lt;span class=&quot;string&quot;&gt;&#39;hello, test&#39;&lt;/span&gt; bash -c &lt;span class=&quot;string&quot;&gt;&#39;echo $JUST_TEST&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;hello, &lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="问答系列" scheme="http://nkcoder.github.io/tags/%E9%97%AE%E7%AD%94%E7%B3%BB%E5%88%97/"/>
    
      <category term="Linux" scheme="http://nkcoder.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【问答系列】Redis中如何清空所有数据？</title>
    <link href="http://nkcoder.github.io/2017/10/08/redis-swipe-all-data/"/>
    <id>http://nkcoder.github.io/2017/10/08/redis-swipe-all-data/</id>
    <published>2017-10-08T09:37:38.000Z</published>
    <updated>2017-10-08T10:06:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>redis中与清空数据有关的命令有3个，分别是：<a href="https://redis.io/commands/flushall" target="_blank" rel="external">FLUSHALL</a>, <a href="https://redis.io/commands/flushdb" target="_blank" rel="external">FLUSHDB</a>, <a href="https://redis.io/commands/script-flush" target="_blank" rel="external">SCRIPT FLUSH</a>。</p><h2 id="FLUSHALL-ASYNC"><a href="#FLUSHALL-ASYNC" class="headerlink" title="FLUSHALL [ASYNC]"></a>FLUSHALL [ASYNC]</h2><p>表示删除<strong>所有DB</strong>中的<strong>所有数据</strong>。默认是同步操作，选项<code>ASYNC</code>表示异步，即清空操作在一个新的线程中进行，不会阻塞主线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -h 127.0.0.1 -p 6379 FLUSHALL ASYNC</div></pre></td></tr></table></figure><a id="more"></a><h2 id="FLUSHDB-ASYNC"><a href="#FLUSHDB-ASYNC" class="headerlink" title="FLUSHDB [ASYNC]"></a>FLUSHDB [ASYNC]</h2><p>表示删除<strong>当前DB</strong>中的<strong>所有数据</strong>。默认是同步操作，和<code>FLUSHall</code>一样，支持选项<code>ASYNC</code>，表示异步。要删除指定DB中的所有数据，可以使用<code>SELECT</code>命令先选中DB，然后使用<code>FLUSHDB</code>命令清空数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -h 127.0.0.1 -p 6379 SELECT 0</div><div class="line">$ redis-cli -h 127.0.0.1 -p 6379 FLUSHDB</div></pre></td></tr></table></figure><h2 id="SCRIPT-FLUSH"><a href="#SCRIPT-FLUSH" class="headerlink" title="SCRIPT FLUSH"></a>SCRIPT FLUSH</h2><p>表示删除<strong>所有</strong>的LUA脚本缓存。所有执行过的LUA脚本都会放在脚本缓存中，该命令可以强制清空所有的LUA脚本缓存。关于LUA脚本的更多内容，请参考<a href="https://redis.io/commands/eval" target="_blank" rel="external">EVAL</a>命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -h 127.0.0.1 -p 6379 SCRIPT FLUSH</div></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://redis.io/commands/flushall" target="_blank" rel="external">FLUSHALL</a></li><li><a href="https://redis.io/commands/flushdb" target="_blank" rel="external">FLUSHDB</a></li><li><a href="https://redis.io/commands/script-flush" target="_blank" rel="external">SCRIPT FLUSH</a></li><li><a href="https://redis.io/commands/eval" target="_blank" rel="external">EVAL</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis中与清空数据有关的命令有3个，分别是：&lt;a href=&quot;https://redis.io/commands/flushall&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FLUSHALL&lt;/a&gt;, &lt;a href=&quot;https://redis.io/commands/flushdb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;https://redis.io/commands/script-flush&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SCRIPT FLUSH&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;FLUSHALL-ASYNC&quot;&gt;&lt;a href=&quot;#FLUSHALL-ASYNC&quot; class=&quot;headerlink&quot; title=&quot;FLUSHALL [ASYNC]&quot;&gt;&lt;/a&gt;FLUSHALL [ASYNC]&lt;/h2&gt;&lt;p&gt;表示删除&lt;strong&gt;所有DB&lt;/strong&gt;中的&lt;strong&gt;所有数据&lt;/strong&gt;。默认是同步操作，选项&lt;code&gt;ASYNC&lt;/code&gt;表示异步，即清空操作在一个新的线程中进行，不会阻塞主线程。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ redis-cli -h 127.0.0.1 -p 6379 FLUSHALL ASYNC&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="redis" scheme="http://nkcoder.github.io/tags/redis/"/>
    
      <category term="问答系列" scheme="http://nkcoder.github.io/tags/%E9%97%AE%E7%AD%94%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【问答系列】什么是空指针异常，如何避免？</title>
    <link href="http://nkcoder.github.io/2017/10/08/what-is-null-pointer-exception/"/>
    <id>http://nkcoder.github.io/2017/10/08/what-is-null-pointer-exception/</id>
    <published>2017-10-08T06:41:04.000Z</published>
    <updated>2017-10-08T15:07:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是空指针异常？"><a href="#什么是空指针异常？" class="headerlink" title="什么是空指针异常？"></a>什么是空指针异常？</h2><p>对于引用类型的变量，如果在使用的时候，它的值是空的(null)，就会报空指针异常。当变量的值为null的时候，表示这个引用不指向内存中的任何区域，所以使用（解引用）时就会触发空指针异常。</p><h2 id="常见发生场景"><a href="#常见发生场景" class="headerlink" title="常见发生场景"></a>常见发生场景</h2><ul><li>直接使用值为null的变量，如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer num = <span class="keyword">null</span>;</div><div class="line">System.out.println(<span class="string">"result: "</span> + (num + <span class="number">10</span>));</div></pre></td></tr></table></figure><a id="more"></a><ul><li>调用值为null的对象的方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SomeClass someObject = <span class="keyword">null</span>;</div><div class="line">someObject.someMethod();</div></pre></td></tr></table></figure><ul><li>值为null的集合类型变量，遍历集合元素或者调用方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = <span class="keyword">null</span>;</div><div class="line">names.forEach(System.out::println);</div><div class="line">names.add(<span class="string">"daniel"</span>);</div></pre></td></tr></table></figure><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><p>最简单直接的办法就是，如果对象可能为null，使用之前先判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">String value = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (Objects.isNull(value)) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (StringUtils.isEmpty(value)) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">checkArgument(value != <span class="keyword">null</span>, <span class="string">"invalid value"</span>);</div></pre></td></tr></table></figure><p>另外，可以参考以下建议：</p><ul><li>如果返回的引用类型的变量可能为null，则返回Optional&lt;&gt;，如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">getResult</span><span class="params">(<span class="keyword">boolean</span> valid)</span> </span>&#123;</div><div class="line">  String result = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">if</span> (valid) &#123;</div><div class="line">    result = getResultFromRemote();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> Optional.ofNullable(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>如果返回值是集合类型(List或Map)，如果可以，尽量返回空集合，而不是null，如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getResults</span><span class="params">(<span class="keyword">boolean</span> valid)</span> </span>&#123;</div><div class="line">  List&lt;String&gt; results = getResultsFromRemote();</div><div class="line">  <span class="keyword">if</span> (results != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>使用注解<code>@Nullable</code>或<code>@NonNull</code></p></li><li><p>使用<code>final</code>修饰变量，提醒自己做合理的初始化</p></li><li><p>对象比较时，将有值的变量放在前面，如：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="string">"name"</span>.equals(someName)) &#123;</div><div class="line">  <span class="comment">// ... </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="如何修复"><a href="#如何修复" class="headerlink" title="如何修复"></a>如何修复</h2><p>空指针异常的修复比较简单，根据异常堆栈定位发生异常的代码行，然后进一步确定可能为null的变量即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_npe</span><span class="params">()</span> </span>&#123;</div><div class="line">  List&lt;String&gt; names = <span class="keyword">null</span>;</div><div class="line">  names.forEach(System.out::println);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">java.lang.NullPointerException</div><div class="line">at NullPointerExceptionTest.test_primitive_type(NullPointerExceptionTest.java:12)</div><div class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</div><div class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">at java.lang.reflect.Method.invoke(Method.java:498)</div><div class="line">at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</div><div class="line">at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</div><div class="line">at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</div><div class="line">at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</div><div class="line">at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)</div><div class="line">at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)</div><div class="line">at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)</div><div class="line">at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)</div><div class="line">at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)</div><div class="line">at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)</div><div class="line">at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)</div><div class="line">at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)</div><div class="line">at org.junit.runners.ParentRunner.run(ParentRunner.java:363)</div><div class="line">at org.junit.runner.JUnitCore.run(JUnitCore.java:137)</div><div class="line">at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)</div><div class="line">at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)</div><div class="line">at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)</div><div class="line">at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)</div></pre></td></tr></table></figure><p>异常堆栈的重要信息为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java.lang.NullPointerException</div><div class="line">at NullPointerExceptionTest.test_primitive_type(NullPointerExceptionTest.java:12)</div></pre></td></tr></table></figure><p>表示异常发生在方法<code>NullPointerExceptionTest</code>的12行，则可以进一步定位是变量names为null。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html" target="_blank" rel="external">NullPointerException</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是空指针异常？&quot;&gt;&lt;a href=&quot;#什么是空指针异常？&quot; class=&quot;headerlink&quot; title=&quot;什么是空指针异常？&quot;&gt;&lt;/a&gt;什么是空指针异常？&lt;/h2&gt;&lt;p&gt;对于引用类型的变量，如果在使用的时候，它的值是空的(null)，就会报空指针异常。当变量的值为null的时候，表示这个引用不指向内存中的任何区域，所以使用（解引用）时就会触发空指针异常。&lt;/p&gt;
&lt;h2 id=&quot;常见发生场景&quot;&gt;&lt;a href=&quot;#常见发生场景&quot; class=&quot;headerlink&quot; title=&quot;常见发生场景&quot;&gt;&lt;/a&gt;常见发生场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;直接使用值为null的变量，如：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Integer num = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;result: &quot;&lt;/span&gt; + (num + &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="java" scheme="http://nkcoder.github.io/tags/java/"/>
    
      <category term="问答系列" scheme="http://nkcoder.github.io/tags/%E9%97%AE%E7%AD%94%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>单元测试系列：使用Junit</title>
    <link href="http://nkcoder.github.io/2017/09/17/junit-tutorial-1/"/>
    <id>http://nkcoder.github.io/2017/09/17/junit-tutorial-1/</id>
    <published>2017-09-17T02:43:09.000Z</published>
    <updated>2017-10-01T01:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Junit版本：4.12</code></pre><p>本文简单介绍<code>Junit</code>在实际工作中的常见的一些用法和API。</p><p>添加gradle依赖：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">testCompile(<span class="string">"junit:junit:4.12"</span>) &#123;</div><div class="line">    exclude group: <span class="string">'org.hamcrest'</span></div><div class="line">&#125;</div><div class="line">testCompile <span class="string">"org.hamcrest:hamcrest-library:1.3"</span></div></pre></td></tr></table></figure></code></pre><h2 id="1-基本注解"><a href="#1-基本注解" class="headerlink" title="1. 基本注解"></a>1. 基本注解</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@BeforeClass</span>: 在<span class="class"><span class="keyword">class</span>中的所有测试方法执行之前运行一次</span></div><div class="line"><span class="class">@<span class="title">AfterClass</span>：在<span class="title">class</span>中的所有测试方法执行之后运行一次</span></div><div class="line"><span class="class">@<span class="title">Before</span>：在每一个测试方法执行之前运行一次</span></div><div class="line"><span class="class">@<span class="title">After</span>：在每一个测试方法执行之后运行一次</span></div><div class="line"><span class="class">@<span class="title">Test</span>：表示一个测试方法</span></div></pre></td></tr></table></figure></code></pre><a id="more"></a><p>其中<code>@BeforeClass</code>和<code>@AfterClass</code>修饰的方法签名为<code>public static void</code>，<code>@Before</code>、<code>@After</code>和<code>@Test</code>修饰的方法的签名为<code>public void</code>。</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@BeforeClass</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run_before_class</span><span class="params">()</span> </span>&#123;</div><div class="line">    log.info(<span class="string">"run once before class."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@AfterClass</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run_after_class</span><span class="params">()</span> </span>&#123;</div><div class="line">    log.info(<span class="string">"run once after class."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Before</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run_before_test_method</span><span class="params">()</span> </span>&#123;</div><div class="line">    log.info(<span class="string">"run before every test method."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@After</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run_after_test_method</span><span class="params">()</span> </span>&#123;</div><div class="line">    log.info(<span class="string">"run before every test method."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_method1</span><span class="params">()</span> </span>&#123;</div><div class="line">    log.info(<span class="string">"test method 1"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_method2</span><span class="params">()</span> </span>&#123;</div><div class="line">    log.info(<span class="string">"test method 2"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="2-测试异常"><a href="#2-测试异常" class="headerlink" title="2. 测试异常"></a>2. 测试异常</h2><p>测试异常主要有三种方式：</p><ul><li>通过<code>@Test</code>的<code>expect</code>属性</li><li>通过<code>try...catch...</code>搭配<code>fail()</code>方法使用，使用<code>fail()</code>的原因是，如果测试的方法没有抛出指定的异常，则该单元测试就会通过</li><li><p>通过<code>@Rule</code>注解</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>(expected = IndexOutOfBoundsException.class)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_exception_with_expect_attribute</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> ArrayList&lt;&gt;().get(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_exception_with_try_catch_fail</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">new</span> ArrayList&lt;&gt;().get(<span class="number">0</span>);</div><div class="line">        fail();</div><div class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</div><div class="line">        assertThat(e.getMessage(), is(<span class="string">"Index: 0, Size: 0"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Rule</span></div><div class="line"><span class="keyword">public</span> ExpectedException expectedException = ExpectedException.none();</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_exception_with_rule</span><span class="params">()</span> </span>&#123;</div><div class="line">    expectedException.expect(IndexOutOfBoundsException.class);</div><div class="line">    expectedException.expectMessage(is(<span class="string">"Index: 0, Size: 0"</span>));</div><div class="line">    expectedException.expectMessage(containsString(<span class="string">"Index: 0, Size: 0"</span>));</div><div class="line">    <span class="keyword">new</span> ArrayList&lt;&gt;().get(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="3-忽略测试"><a href="#3-忽略测试" class="headerlink" title="3. 忽略测试"></a>3. 忽略测试</h2><p>通过<code>@Ignore</code>可以忽略单元测试，如果用在方法上，表示该方法不作为单元测试被执行，如果用在类上，表示该类中的所有单元测试方法都不被执行。</p><p>为什么要用<code>@Ignore</code>忽略单元测试，而不是直接注释掉单元测试或者注释掉<code>@Test</code>注解呢？因为被<code>@Ignore</code>的单元测试会显示在最后的测试结果中，另外，在<br>多人协作的多模块项目中，ignore掉别的模块中执行不通过的单元测试，可以避免整个项目都无法运行。</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Ignore</span>(<span class="string">"will be add later!"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitException</span> </span>&#123;</div><div class="line">    <span class="meta">@Test</span>(expected = IndexOutOfBoundsException.class)</div><div class="line">    <span class="meta">@Ignore</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_exception_with_expect_attribute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> ArrayList&lt;&gt;().get(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="4-设置超时"><a href="#4-设置超时" class="headerlink" title="4. 设置超时"></a>4. 设置超时</h2><p><code>@Test</code>的<code>tiimeout</code>属性可以设置超时，单位是毫秒。</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>(timeout = <span class="number">1000</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_timeout</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        TimeUnit.SECONDS.sleep(<span class="number">2000</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        log.error(e.getMessage(), e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="5-测试list的常用方法"><a href="#5-测试list的常用方法" class="headerlink" title="5. 测试list的常用方法"></a>5. 测试list的常用方法</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; actual = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</div><div class="line">List&lt;String&gt; expected = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</div><div class="line">List&lt;Integer&gt; numList = Arrays.asList®(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">assertThat(actual, is(expected));</div><div class="line">assertThat(actual, hasItem(<span class="string">"a"</span>));</div><div class="line">assertThat(actual, hasItems(<span class="string">"c"</span>, <span class="string">"b"</span>));</div><div class="line">assertThat(actual, containsInAnyOrder(<span class="string">"c"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>));</div><div class="line"></div><div class="line">assertThat(actual.size(), is(<span class="number">3</span>));</div><div class="line">assertThat(actual, hasSize(<span class="number">3</span>));</div><div class="line"></div><div class="line">assertThat(numList, everyItem(greaterThanOrEqualTo(<span class="number">1</span>)));</div></pre></td></tr></table></figure></code></pre><h2 id="6-测试map的常用方法"><a href="#6-测试map的常用方法" class="headerlink" title="6. 测试map的常用方法"></a>6. 测试map的常用方法</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Integer&gt; actual = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">actual.put(<span class="string">"00001"</span>, <span class="number">1</span>);</div><div class="line">actual.put(<span class="string">"00002"</span>, <span class="number">2</span>);</div><div class="line">actual.put(<span class="string">"00003"</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">Map&lt;String, Integer&gt; expected = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">expected.put(<span class="string">"00001"</span>, <span class="number">1</span>);</div><div class="line">expected.put(<span class="string">"00002"</span>, <span class="number">2</span>);</div><div class="line">expected.put(<span class="string">"00003"</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">assertThat(actual, is(expected));</div><div class="line">assertThat(actual, hasEntry(<span class="string">"00001"</span>, <span class="number">1</span>));</div><div class="line">assertThat(actual, not(hasEntry(<span class="string">"00004"</span>, <span class="number">4</span>)));</div><div class="line">assertThat(actual, hasKey(<span class="string">"00002"</span>));</div><div class="line">assertThat(actual, hasValue(<span class="string">"00003"</span>));</div></pre></td></tr></table></figure></code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://junit.org/junit4/" target="_blank" rel="external">junit4</a></li><li><a href="http://www.mkyong.com/tutorials/junit-tutorials/" target="_blank" rel="external">JUnit Tutorial</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Junit版本：4.12
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本文简单介绍&lt;code&gt;Junit&lt;/code&gt;在实际工作中的常见的一些用法和API。&lt;/p&gt;
&lt;p&gt;添加gradle依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;testCompile(&lt;span class=&quot;string&quot;&gt;&quot;junit:junit:4.12&quot;&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    exclude group: &lt;span class=&quot;string&quot;&gt;&#39;org.hamcrest&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;testCompile &lt;span class=&quot;string&quot;&gt;&quot;org.hamcrest:hamcrest-library:1.3&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-基本注解&quot;&gt;&lt;a href=&quot;#1-基本注解&quot; class=&quot;headerlink&quot; title=&quot;1. 基本注解&quot;&gt;&lt;/a&gt;1. 基本注解&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@BeforeClass&lt;/span&gt;: 在&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;中的所有测试方法执行之前运行一次&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;@&lt;span class=&quot;title&quot;&gt;AfterClass&lt;/span&gt;：在&lt;span class=&quot;title&quot;&gt;class&lt;/span&gt;中的所有测试方法执行之后运行一次&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;@&lt;span class=&quot;title&quot;&gt;Before&lt;/span&gt;：在每一个测试方法执行之前运行一次&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;@&lt;span class=&quot;title&quot;&gt;After&lt;/span&gt;：在每一个测试方法执行之后运行一次&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;@&lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt;：表示一个测试方法&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="单元测试" scheme="http://nkcoder.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Junit" scheme="http://nkcoder.github.io/tags/Junit/"/>
    
  </entry>
  
  <entry>
    <title>学习Express框架一：概述</title>
    <link href="http://nkcoder.github.io/2016/08/20/express-tutorial-basic/"/>
    <id>http://nkcoder.github.io/2016/08/20/express-tutorial-basic/</id>
    <published>2016-08-19T22:59:43.000Z</published>
    <updated>2017-09-27T14:44:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://expressjs.com/" target="_blank" rel="external">express</a>是nodejs的一个流行的web框架。本文主要介绍将express作为服务端对外提供API接口时，需要了解的入门知识。Express版本：<code>4.x</code>。</p><h1 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1. Hello World"></a>1. Hello World</h1><p>首先安装node（如果已安装，则略过）：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install node</div></pre></td></tr></table></figure></code></pre><p>创建一个项目，然后安装express：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mkdir express-hello-world &amp;&amp; cd express-hello-world</div><div class="line">$ npm init</div><div class="line">$ npm install express --save</div></pre></td></tr></table></figure></code></pre><p><code>npm init</code>会提示输入一些配置信息，回车使用默认值即可，执行完后，当前目录下会自动创建<code>package.json</code>文件。</p><p><code>npm install express --save</code>表示为当前项目安装express依赖，该依赖信息会保存在<code>package.json</code>文件中。</p><a id="more"></a><p>新建文件<code>index.js</code>文件， 输入以下内容：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express =  <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">var</span> app = express();</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.send(<span class="string">'hello, world!'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure></code></pre><p>运行：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node index.js</div></pre></td></tr></table></figure></code></pre><p>浏览器访问：<code>http://localhost:3000/</code>，会输出”hello, world!”。</p><h1 id="2-中间件middleware"><a href="#2-中间件middleware" class="headerlink" title="2. 中间件middleware"></a>2. 中间件middleware</h1><p>在express中，中间件（middleware）函数是一种特殊的函数，它可以访问一个http请求周期中的request对象、response对象，以及表示调用栈中的下一个中间件函数的引用，如：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    next();</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p>其中，<code>req</code>, <code>res</code>和<code>next</code>三个参数名是约定的，不要使用其它的变量名。中间件函数可以修改request和response，或者提前结束response，也可以调用<code>next()</code>表示将执行传递给调用栈中的下一个中间件函数。</p><p>如果当前中间件函数没有结束HTTP请求，则必须调用<code>next()</code>将执行传递给下一个中间件函数，否则请求会挂起。</p><p>使用<code>app.use()</code>加载中间件函数，中间件函数加载的顺序决定了它的执行顺序，即先加载，先执行。</p><p>在上面hello-world的例子中，我们增加两个简单的中间件函数，分别打印两条日志信息。在<code>var app = express();</code>的后面增加以下代码：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'in middleware one...'</span>);</div><div class="line">  next();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'in middleware two...'</span>);</div><div class="line">  next();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><p>执行后，终端会依次输出两个中间件函数中的日志信息。</p><p>express中的中间件可以分为以下几类：</p><ul><li>app级中间件</li><li>router级中间件</li><li>错误处理中间件</li><li>内置中间件</li><li>第三方中间件</li></ul><p>这里仅简要介绍一下主要的app级中间件和router级中间件。</p><p>app级中间件，即将中间件函数绑定到<code>app</code>对象（即使用<code>express()</code>得到的对象），通过<code>app.use()</code>或者<code>app.METHOD()</code>方法来加载中间件函数，其中<code>METHOD()</code>表示HTTP请求中的<code>GET/POST/PUT</code>等方法。上面的hello-world示例中就是app级中间件：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.send(<span class="string">'hello, world!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><p>router级中间件与app级中间件的用法基本一致，不同的是，它将中间件函数绑定到<code>express.Router()</code>对象，通过<code>router.use()</code>或者<code>router.METHOD()</code>方法来加载。比如上面的app级中间件，用router级中间件的方法改写如下：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> router = express.Router();</div><div class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.send(<span class="string">'hello, world!'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.use(<span class="string">'/'</span>, router);</div></pre></td></tr></table></figure></code></pre><p>引入router级中间件的好处之一是解耦，通过router去分层，然后app加载router。</p><h1 id="3-HTTP的req对象"><a href="#3-HTTP的req对象" class="headerlink" title="3. HTTP的req对象"></a>3. HTTP的req对象</h1><h2 id="3-1-req-params取路径参数"><a href="#3-1-req-params取路径参数" class="headerlink" title="3.1 req.params取路径参数"></a>3.1 req.params取路径参数</h2><p>express中，路径参数使用命名参数的方式，比如路径是<code>/user/:id</code>，则使用<code>req.params.id</code>取参数<code>:id</code>的值，如：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/user/:id</div><div class="line">GET /user/15</div><div class="line">req.params.id  =&gt; 15</div></pre></td></tr></table></figure></code></pre><h2 id="3-2-req-query取查询参数"><a href="#3-2-req-query取查询参数" class="headerlink" title="3.2 req.query取查询参数"></a>3.2 req.query取查询参数</h2><p>取查询参数，只需要通过<code>req.query</code>根据key取值即可，如：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /search?name=Ketty&amp;gender=male</div><div class="line">req.query.name =&gt; Ketty</div><div class="line">req.query.gender =&gt; male</div><div class="line"></div><div class="line">GET /search?user[name]=Ketty&amp;user[age]=30</div><div class="line">req.query.user.name =&gt; Ketty</div><div class="line">req.query.user.age  =&gt; 30</div></pre></td></tr></table></figure></code></pre><h2 id="3-3-req-body"><a href="#3-3-req-body" class="headerlink" title="3.3 req.body"></a>3.3 req.body</h2><p>要取HTTP请求中的body内容，使用<code>req.body</code>，但是需要借助第三方module，如<code>body-parser</code>和<code>multer</code>，以下示例来自<a href="http://expressjs.com/en/4x/api.html#req.body" target="_blank" rel="external">express文档</a>：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</div><div class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</div><div class="line"><span class="keyword">var</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>); <span class="comment">// v1.0.5</span></div><div class="line"><span class="keyword">var</span> upload = multer(); <span class="comment">// for parsing multipart/form-data</span></div><div class="line"></div><div class="line">app.use(bodyParser.json()); <span class="comment">// for parsing application/json</span></div><div class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">true</span> &#125;)); <span class="comment">// for parsing application/x-www-form-urlencoded</span></div><div class="line"></div><div class="line">app.post(<span class="string">'/profile'</span>, upload.array(), <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(req.body);</div><div class="line">  res.json(req.body);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></code></pre><h2 id="3-4-req-get"><a href="#3-4-req-get" class="headerlink" title="3.4 req.get()"></a>3.4 req.get()</h2><p>提取HTTP header中的信息，其中，key是不区分大小写的，如：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">req.get(<span class="string">'Content-Type'</span>);    <span class="comment">// text/html</span></div><div class="line">req.get(<span class="string">'content-type'</span>);    <span class="comment">// text/html</span></div></pre></td></tr></table></figure></code></pre><h1 id="4-HTTP的res对象"><a href="#4-HTTP的res对象" class="headerlink" title="4. HTTP的res对象"></a>4. HTTP的res对象</h1><h2 id="4-1-res-status"><a href="#4-1-res-status" class="headerlink" title="4.1 res.status()"></a>4.1 res.status()</h2><p>该方法仅仅是设置状态码，返回response还需调用<code>send()/end()</code>等方法，如：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">res.status(<span class="number">200</span>).end();</div><div class="line">res.status(<span class="number">401</span>).send(<span class="string">"error: unauthorized!"</span>);</div></pre></td></tr></table></figure></code></pre><h2 id="4-2-res-json"><a href="#4-2-res-json" class="headerlink" title="4.2 res.json()"></a>4.2 res.json()</h2><p>返回json格式的信息，res会自动设置response的<code>Content-Type</code>为<code>application/json</code>，如：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">res.status(<span class="number">401</span>).json(&#123;<span class="string">"error"</span>: <span class="string">"unauthorized"</span>&#125;);</div></pre></td></tr></table></figure></code></pre><h2 id="4-3-res-send"><a href="#4-3-res-send" class="headerlink" title="4.3 res.send()"></a>4.3 res.send()</h2><p>发送HTTP响应信息，参数可以是字符串、数组、Buffer对象等，会根据参数的类型自动设置header的<code>Content-Type</code>，如：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">res.send(<span class="keyword">new</span> Buffer(<span class="string">"buffer info"</span>));        <span class="comment">// Content-Type: application/octet-stream</span></div><div class="line">res.send(<span class="string">"&lt;small&gt;small text&lt;/small&gt;"</span>);      <span class="comment">// Content-Type: text/html</span></div><div class="line">res.send(&#123;<span class="attr">message</span>: <span class="string">"Welcome"</span>&#125;);             <span class="comment">// Content-Type: application/json</span></div></pre></td></tr></table></figure></code></pre><h2 id="4-4-res-set"><a href="#4-4-res-set" class="headerlink" title="4.4. res.set()"></a>4.4. res.set()</h2><p>设置HTTP的header信息，如：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">res.set(<span class="string">'Content-Type'</span>, <span class="string">'application/pdf'</span>);</div><div class="line">res.setHeader(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment; filename=cnb.pdf'</span>);</div></pre></td></tr></table></figure></code></pre><h2 id="4-5-res-render"><a href="#4-5-res-render" class="headerlink" title="4.5 res.render()"></a>4.5 res.render()</h2><p>使用模板引擎渲染页面，然后作为response返回。如果参数表示的文件名不带后缀，则会根据模板引擎的设置，自动推断后缀；如果文件名带后缀，则会加载该后缀对应的模板引擎模块。如</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">res.render(<span class="string">'index'</span>);</div></pre></td></tr></table></figure></code></pre><p>如果默认的模板引擎是jade，则express会从对应的路径下查找index.jade文件并渲染。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://expressjs.com/en/4x/api.html" target="_blank" rel="external">4.x API</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://expressjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;express&lt;/a&gt;是nodejs的一个流行的web框架。本文主要介绍将express作为服务端对外提供API接口时，需要了解的入门知识。Express版本：&lt;code&gt;4.x&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;1-Hello-World&quot;&gt;&lt;a href=&quot;#1-Hello-World&quot; class=&quot;headerlink&quot; title=&quot;1. Hello World&quot;&gt;&lt;/a&gt;1. Hello World&lt;/h1&gt;&lt;p&gt;首先安装node（如果已安装，则略过）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ brew install node&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个项目，然后安装express：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ mkdir express-hello-world &amp;amp;&amp;amp; cd express-hello-world&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ npm init&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ npm install express --save&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;npm init&lt;/code&gt;会提示输入一些配置信息，回车使用默认值即可，执行完后，当前目录下会自动创建&lt;code&gt;package.json&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install express --save&lt;/code&gt;表示为当前项目安装express依赖，该依赖信息会保存在&lt;code&gt;package.json&lt;/code&gt;文件中。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="nodejs" scheme="http://nkcoder.github.io/tags/nodejs/"/>
    
      <category term="express" scheme="http://nkcoder.github.io/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令系列：sed命令</title>
    <link href="http://nkcoder.github.io/2016/08/06/linux-sed-note/"/>
    <id>http://nkcoder.github.io/2016/08/06/linux-sed-note/</id>
    <published>2016-08-06T06:23:42.000Z</published>
    <updated>2017-09-27T14:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>sed是一个面向行的流处理工具，主要用于对文件的增加、删除、替换等操作。</p><p>sed命令的语法：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed [options] commands [file-to-edit]</div></pre></td></tr></table></figure></code></pre><p>下面以annoying.txt文件作为示例数据源， 文件内容为：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># echo "this is the song that never ends</span></div><div class="line">&gt; yes, it goes on and on, my friend</div><div class="line">&gt; some people started singing it</div><div class="line">&gt; not knowing what it was</div><div class="line">&gt; and they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">&gt; just because..." &gt; annoying.txt</span></div></pre></td></tr></table></figure></code></pre><a id="more"></a><h1 id="1-命令及参数含义"><a href="#1-命令及参数含义" class="headerlink" title="1. 命令及参数含义"></a>1. 命令及参数含义</h1><h2 id="1-1-读取文件内容"><a href="#1-1-读取文件内容" class="headerlink" title="1.1 读取文件内容"></a>1.1 读取文件内容</h2><p>如果<code>commands</code>为空，表示对每一行没有做任何处理，相当于读取文件的内容（因为sed默认会将读到的内容打印出来），如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed '' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">yes, it goes on and on, my friend</div><div class="line">some people started singing it</div><div class="line">not knowing what it was</div><div class="line">and they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><p>这与执行：<code># cat annoying.txt | sed &#39;&#39;</code>的输出是一样的。</p><h2 id="1-2-打印命令p"><a href="#1-2-打印命令p" class="headerlink" title="1.2 打印命令p"></a>1.2 打印命令p</h2><p>p命令将读到的内容直接打印出来， 如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed 'p' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">this is the song that never ends</div><div class="line">yes, it goes on and on, my friend</div><div class="line">yes, it goes on and on, my friend</div><div class="line">some people started singing it</div><div class="line">some people started singing it</div><div class="line">not knowing what it was</div><div class="line">not knowing what it was</div><div class="line">and they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">and they'</span>ll <span class="built_in">continue</span> singing it forever</div><div class="line">just because...</div><div class="line">just because...</div></pre></td></tr></table></figure></code></pre><p>上面每一行都会打印两遍，是因为sed默认会将读到的内容输出，使用<code>-n</code>选项可以禁用默认的输出，如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed -n 'p' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">yes, it goes on and on, my friend</div><div class="line">some people started singing it</div><div class="line">not knowing what it was</div><div class="line">and they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><p>范围限制：可以在p命令前增加范围限制，数字表示具体的行数，+数字表示增量，$表示最后一行，~表示间隔的行数，如：</p><p>打印第1行：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed -n '1p' annoying.txt</span></div><div class="line">this is the song that never ends</div></pre></td></tr></table></figure></code></pre><p>打印第1行到第2行：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed -n '1,2p' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">yes, it goes on and on, my friend</div></pre></td></tr></table></figure></code></pre><p>打印第3行到最后一行：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed -n '3,$p' annoying.txt</span></div><div class="line">some people started singing it</div><div class="line">not knowing what it was</div><div class="line">and they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><p>打印第1行到后面的2行，即前3行:</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed -n '1,+2p' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">yes, it goes on and on, my friend</div><div class="line">some people started singing it</div></pre></td></tr></table></figure></code></pre><p>每隔2行打印，即打印奇数行：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed -n '1~2p' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">some people started singing it</div><div class="line">and they<span class="string">'ll continue singing it forever</span></div></pre></td></tr></table></figure></code></pre><p>仅打印pattern匹配到的行：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed -n '/this/p' annoying.txt</span></div><div class="line">this is the song that never ends</div></pre></td></tr></table></figure></code></pre><h2 id="1-3-删除命令d"><a href="#1-3-删除命令d" class="headerlink" title="1.3 删除命令d"></a>1.3 删除命令d</h2><p>删除命令d与打印命令p的用法基本类似，只需要将p换成d即可，如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed '1~2d' annoying.txt</span></div><div class="line">yes, it goes on and on, my friend</div><div class="line">not knowing what it was</div><div class="line">just because...</div><div class="line"></div><div class="line">root@a01:~/junk<span class="comment"># sed '1,3d' annoying.txt</span></div><div class="line">not knowing what it was</div><div class="line">and they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><p>使用删除命令，没有被删的行会被打印出来，但是原文件是不被影响的。可以使用<code>-i</code>选项，表示在原文件上直接修改，<br>但是这样是比较危险的，最好先备份，而<code>-i</code>选项支持备份，<code>-i</code>后面的参数值表示备份文件的后缀，如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed -i '1d' annoying.txt</span></div><div class="line"></div><div class="line">root@a01:~/junk<span class="comment"># sed -i.bak '1d' annoying.txt</span></div><div class="line">root@a01:~/junk<span class="comment"># ls</span></div><div class="line">annoying.txt  annoying.txt.bak</div><div class="line"></div><div class="line">root@a01:~/junk<span class="comment"># cat annoying.txt</span></div><div class="line">some people started singing it</div><div class="line">not knowing what it was</div><div class="line">and they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">just because...</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">root@a01:~/junk# cat annoying.txt.bak</span></div><div class="line"><span class="string">this is the song that never ends</span></div><div class="line"><span class="string">yes, it goes on and on, my friend</span></div><div class="line"><span class="string">some people started singing it</span></div><div class="line"><span class="string">not knowing what it was</span></div><div class="line"><span class="string">and they'</span>ll <span class="built_in">continue</span> singing it forever</div><div class="line">just because...</div></pre></td></tr></table></figure></code></pre><h2 id="1-4-替换命令s"><a href="#1-4-替换命令s" class="headerlink" title="1.4 替换命令s"></a>1.4 替换命令s</h2><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'s/old_word/new_word/'</span></div></pre></td></tr></table></figure></code></pre><p>s是替换命令，/是默认的分隔符，也可以使用其它字符作为分隔符（紧跟s之后），常见的有：|, :, _等，注意末尾的分隔符不能省略。<br>old_word为正则表达式，用于匹配，new_word是要替换的字符串。如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># echo http://www.thegeekstuff.com/2009/09/unix-sed | sed 's_2009/09_2016/07_'</span></div><div class="line">http://www.thegeekstuff.com/2016/07/unix-sed</div></pre></td></tr></table></figure></code></pre><p>s命令默认仅替换每一行出现的第1个匹配，如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed 's/on/forward/' annoying.txt</span></div><div class="line">this is the sforwardg that never ends</div><div class="line">yes, it goes forward and on, my friend</div><div class="line">some people started singing it</div><div class="line">not knowing what it was</div><div class="line">and they<span class="string">'ll cforwardtinue singing it forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><p>也可以仅替换每行的第n个匹配，如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed 's/on/forward/2' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">yes, it goes on and forward, my friend</div><div class="line">some people started singing it</div><div class="line">not knowing what it was</div><div class="line">and they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><p>全局替换使用g参数：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed 's/on/forward/g' annoying.txt</span></div><div class="line">this is the sforwardg that never ends</div><div class="line">yes, it goes forward and forward, my friend</div><div class="line">some people started singing it</div><div class="line">not knowing what it was</div><div class="line">and they<span class="string">'ll cforwardtinue singing it forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><p>如果仅替换独立的单词，不替换单词的部分，使用\b限制边界，如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed 's/\bon\b/forward/g' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">yes, it goes forward and forward, my friend</div><div class="line">some people started singing it</div><div class="line">not knowing what it was</div><div class="line">and they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><p>限制操作的行数，如仅全局替换前3行（&amp;表示引用匹配到的部分）：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk# sed &apos;1,2s/^.*/  &amp;/&apos; annoying.txt</div><div class="line">  this is the song that never ends</div><div class="line">  yes, it goes on and on, my friend</div><div class="line">some people started singing it</div><div class="line">not knowing what it was</div><div class="line">and they&apos;ll continue singing it forever</div><div class="line">just because...</div></pre></td></tr></table></figure></code></pre><p>可以使用-n选项和p参数，打印仅发生替换的内容，如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed -n 's/on/forward/gp' annoying.txt</span></div><div class="line">this is the sforwardg that never ends</div><div class="line">yes, it goes forward and forward, my friend</div><div class="line">and they<span class="string">'ll cforwardtinue singing it forever</span></div></pre></td></tr></table></figure></code></pre><p>可见，在s命令的最后，可以通过参数影响替换的行为，如i表示忽略大小写：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed -n 's/on/forward/gpi' annoying.txt</span></div><div class="line">this is the sforwardg that never ends</div><div class="line">yes, it goes forward and forward, my friend</div><div class="line">and they<span class="string">'ll cforwardtinue singing it forever</span></div></pre></td></tr></table></figure></code></pre><p>引用被匹配的部分：如果只有一个分组，则使用&amp;比较方便，表示引用被匹配的部分，如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed 's/.*/| &amp;/' annoying.txt</span></div><div class="line">| this is the song that never ends</div><div class="line">| yes, it goes on and on, my friend</div><div class="line">| some people started singing it</div><div class="line">| not knowing what it was</div><div class="line">| and they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">| just because...</span></div></pre></td></tr></table></figure></code></pre><p>如果有多个分组，首先在<code>old_word</code>里通过括号()分组，然后在<code>new_word</code>里通过数字序号去引用（分组的括号以及引用的数字都需要通过\转义）,<br>数字和前面的分组一一对应，最多可以使用9个数字。比如我们要反转每一行的前两个单词：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed 's/\([0-9a-zA-Z][0-9a-zA-Z]*\) \([0-9a-zA-Z][0-9a-zA-Z]*\)/\2 \1/' annoying.txt</span></div><div class="line">is this the song that never ends</div><div class="line">yes, goes it on and on, my friend</div><div class="line">people some started singing it</div><div class="line">knowing not what it was</div><div class="line">they and<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">because just...</span></div></pre></td></tr></table></figure></code></pre><p>\1可以用于用在new_word，也可以用在old_word中，如打印具有连续重复词的行：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed -n '/\([a-z][a-z]*\) \1/p' annoying.txt</span></div><div class="line">this is the song that never ends</div></pre></td></tr></table></figure></code></pre><h2 id="1-5-行之前插入命令i"><a href="#1-5-行之前插入命令i" class="headerlink" title="1.5 行之前插入命令i"></a>1.5 行之前插入命令i</h2><p>在文件中插入内容也是sed常见用法之一。i命令表示在匹配的行前插入内容，插入的内容作为一行显示，如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed '/singing/i before every line' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">yes, it goes on and on, my friend</div><div class="line">before every line</div><div class="line">some people started singing it</div><div class="line">not knowing what it was</div><div class="line">before every line</div><div class="line">and they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><h2 id="1-6-行之后插入命令a"><a href="#1-6-行之后插入命令a" class="headerlink" title="1.6 行之后插入命令a"></a>1.6 行之后插入命令a</h2><p>表示在匹配的行之后插入内容：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed '/it/a after it' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">yes, it goes on and on, my friend</div><div class="line">after it</div><div class="line">some people started singing it</div><div class="line">after it</div><div class="line">not knowing what it was</div><div class="line">after it</div><div class="line">and they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">after it</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><h2 id="1-7-行修改（替换）命令c"><a href="#1-7-行修改（替换）命令c" class="headerlink" title="1.7 行修改（替换）命令c"></a>1.7 行修改（替换）命令c</h2><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed '/it/c change it' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">change it</div><div class="line">change it</div><div class="line">change it</div><div class="line">change it</div><div class="line">just because...</div></pre></td></tr></table></figure></code></pre><h2 id="1-8-执行多条处理命令：-e选项"><a href="#1-8-执行多条处理命令：-e选项" class="headerlink" title="1.8 执行多条处理命令：-e选项"></a>1.8 执行多条处理命令：-e选项</h2><p>可以通过管道|，如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed 's/and/\&amp;/' annoying.txt | sed 's/people/horses/'</span></div><div class="line">this is the song that never ends</div><div class="line">yes, it goes on &amp; on, my friend</div><div class="line">some horses started singing it</div><div class="line">not knowing what it was</div><div class="line">&amp; they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><p>但是因为需要多次调用sed命令，因此效率不好。推荐使用sed的<code>-e</code>选项来执行多条命令（只有一条命令时，-e选项不是必须的），如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed -e 's/and/\&amp;/' -e 's/people/horses/' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">yes, it goes on &amp; on, my friend</div><div class="line">some horses started singing it</div><div class="line">not knowing what it was</div><div class="line">&amp; they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><p>还有一种方式，通过分号(;)将命令分割，如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed 's/and/\&amp;/;s/people/horses/' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">yes, it goes on &amp; on, my friend</div><div class="line">some horses started singing it</div><div class="line">not knowing what it was</div><div class="line">&amp; they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><h2 id="1-9-sed脚本文件：-f选项"><a href="#1-9-sed脚本文件：-f选项" class="headerlink" title="1.9 sed脚本文件：-f选项"></a>1.9 sed脚本文件：-f选项</h2><p>可以将sed命令放到文件里，然后执行这个脚本文件，语法为：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -f script-file file-to-edit</div></pre></td></tr></table></figure></code></pre><p>比如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># echo 's/and/\&amp;/</span></div><div class="line">&gt; s/people/horses/<span class="string">' &gt;&gt; sed-demo</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">root@a01:~/junk# sed -f sed-demo annoying.txt</span></div><div class="line"><span class="string">this is the song that never ends</span></div><div class="line"><span class="string">yes, it goes on &amp; on, my friend</span></div><div class="line"><span class="string">some horses started singing it</span></div><div class="line"><span class="string">not knowing what it was</span></div><div class="line"><span class="string">&amp; they'</span>ll <span class="built_in">continue</span> singing it forever</div><div class="line">just because...</div></pre></td></tr></table></figure></code></pre><h2 id="1-10-pattern"><a href="#1-10-pattern" class="headerlink" title="1.10 pattern"></a>1.10 pattern</h2><p>命令前面都可以通过pattern去匹配，pattern为正则表达式。</p><p>比如仅处理包含singing这个词的行：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed '/singing/s/it/&amp; loudly/' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">yes, it goes on and on, my friend</div><div class="line">some people started singing it loudly</div><div class="line">not knowing what it was</div><div class="line">and they<span class="string">'ll continue singing it loudly forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><p>pattern默认的分隔符也是/，如果第一个字符为\，则使用后面的字符作为分隔符，一般用于匹配本身带有/的值，如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># echo http://www.grymoire.com/Unix/sed.html | sed '\_/Unix/sed_s_/sed_/awk_'</span></div><div class="line">http://www.grymoire.com/Unix/awk.html</div></pre></td></tr></table></figure></code></pre><p>pattern除了直接匹配，还支持范围匹配，语法为：</p><pre><code>sed &apos;/start/,/stop/ s/#.*//&apos;</code></pre><p>start表示匹配开始，stop表示匹配结束，可以看作开关；如果是正则表达式，需要使用//，如果只是数字或者^$，则不需要//。</p><p>删除从some开头到not开头的中间所有行：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed '/^some/,/^not/d' annoying.txt</span></div><div class="line">this is the song that never ends</div><div class="line">yes, it goes on and on, my friend</div><div class="line">and they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><p>删除第1行到包含yes的那一行：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed '1,/yes/d' annoying.txt</span></div><div class="line">some people started singing it</div><div class="line">not knowing what it was</div><div class="line">and they<span class="string">'ll continue singing it forever</span></div><div class="line"><span class="string">just because...</span></div></pre></td></tr></table></figure></code></pre><p>删除包含yes那行到最后一行（命令d前面允许有空格的）：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed '/yes/,$ d' annoying.txt</span></div><div class="line">this is the song that never ends</div></pre></td></tr></table></figure></code></pre><p>命令前面使用!表示对命令取反，比如对上一条命令取反：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed '/^some/,/^not/!d' annoying.txt</span></div><div class="line">some people started singing it</div><div class="line">not knowing what it was</div></pre></td></tr></table></figure></code></pre><h1 id="2-应用示例"><a href="#2-应用示例" class="headerlink" title="2. 应用示例"></a>2. 应用示例</h1><h2 id="2-1-保留每一行的第一个单词"><a href="#2-1-保留每一行的第一个单词" class="headerlink" title="2.1 保留每一行的第一个单词"></a>2.1 保留每一行的第一个单词</h2><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># sed 's/\([a-zA-Z]*\).*/\1/' &lt; annoying.txt &gt; first_word.txt</span></div><div class="line">root@a01:~/junk<span class="comment"># cat first_word.txt</span></div><div class="line">this</div><div class="line">yes</div><div class="line">some</div><div class="line">not</div><div class="line">and</div><div class="line">just</div></pre></td></tr></table></figure></code></pre><h2 id="2-2-Here-is输入"><a href="#2-2-Here-is输入" class="headerlink" title="2.2 Here is输入"></a>2.2 <code>Here is</code>输入</h2><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@a01:~/junk<span class="comment"># cat sed-here-is.sh</span></div><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="built_in">echo</span> -n <span class="string">"what is the value?\n"</span></div><div class="line"><span class="built_in">read</span> value</div><div class="line">sed <span class="string">"s/XYZ/<span class="variable">$value</span>/"</span> &lt;&lt;EOF</div><div class="line">The value is XYZ</div><div class="line">EOF</div><div class="line">root@a01:~/junk<span class="comment"># sh sed-here-is.sh</span></div><div class="line">what is the value?</div><div class="line"><span class="built_in">test</span></div><div class="line">The value is <span class="built_in">test</span></div></pre></td></tr></table></figure></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.grymoire.com/Unix/sed.html" target="_blank" rel="external">Sed - An Introduction and Tutorial by Bruce Barnett</a></li><li><a href="https://www.digitalocean.com/community/tutorials/the-basics-of-using-the-sed-stream-editor-to-manipulate-text-in-linux" target="_blank" rel="external">The Basics of Using the Sed Stream Editor to Manipulate Text in Linux</a></li><li><a href="https://www.digitalocean.com/community/tutorials/intermediate-sed-manipulating-streams-of-text-in-a-linux-environment" target="_blank" rel="external">Intermediate Sed: Manipulating Streams of Text in a Linux Environment</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sed是一个面向行的流处理工具，主要用于对文件的增加、删除、替换等操作。&lt;/p&gt;
&lt;p&gt;sed命令的语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sed [options] commands [file-to-edit]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面以annoying.txt文件作为示例数据源， 文件内容为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;root@a01:~/junk&lt;span class=&quot;comment&quot;&gt;# echo &quot;this is the song that never ends&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; yes, it goes on and on, my friend&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; some people started singing it&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; not knowing what it was&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; and they&lt;span class=&quot;string&quot;&gt;&#39;ll continue singing it forever&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&amp;gt; just because...&quot; &amp;gt; annoying.txt&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="linux" scheme="http://nkcoder.github.io/tags/linux/"/>
    
      <category term="sed" scheme="http://nkcoder.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>使用LiquiBase管理数据库的迁移</title>
    <link href="http://nkcoder.github.io/2016/04/10/liquibase-in-maven-and-gradle/"/>
    <id>http://nkcoder.github.io/2016/04/10/liquibase-in-maven-and-gradle/</id>
    <published>2016-04-10T08:06:32.000Z</published>
    <updated>2017-09-27T14:21:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.liquibase.org/index.html" target="_blank" rel="external">LiquiBase</a>是一个用于数据库重构和迁移的开源工具，通过日志文件的形式记录数据库的变更，然后执行日志文件中的修改，将数据库更新或回滚到一致的状态。LiquiBase的主要特点有：</p><ul><li>支持几乎所有主流的数据库，如MySQL, PostgreSQL, Oracle, Sql Server, DB2等；</li><li>支持多开发者的协作维护；</li><li>日志文件支持多种格式，如XML, YAML, JSON, SQL等；</li><li>支持多种运行方式，如命令行、Spring集成、Maven插件、Gradle插件等；</li></ul><a id="more"></a><p>本文首先简单介绍一下LiquiBase的changelog文件的常用标签配置，然后介绍在Maven和Gradle中集成并运行LiquiBase。</p><h2 id="1-changelog文件格式"><a href="#1-changelog文件格式" class="headerlink" title="1. changelog文件格式"></a>1. changelog文件格式</h2><p>changelog是LiquiBase用来记录数据库的变更，一般放在<code>CLASSPATH</code>下，然后配置到执行路径中。</p><p>changelog支持多种格式，主要有XML/JSON/YAML/SQL，其中XML/JSON/YAML除了具体格式语法不同，节点配置很类似，SQL格式中主要记录SQL语句，这里仅给出XML格式和SQL格式的示例，更多的格式示例请参考<a href="http://www.liquibase.org/documentation/databasechangelog.html" target="_blank" rel="external">文档</a></p><p>changelog.xml</p><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">changeSet</span> <span class="attr">id</span>=<span class="string">"2"</span> <span class="attr">author</span>=<span class="string">"daniel"</span> <span class="attr">runOnChange</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">tableName</span>=<span class="string">"contest_info"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">column</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span>title 3<span class="tag">&lt;/<span class="name">column</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"content"</span>&gt;</span>content 3<span class="tag">&lt;/<span class="name">column</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">changeSet</span>&gt;</span></div></pre></td></tr></table></figure></code></pre><p>changelog.sql</p><pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--liquibase formatted sql</span></div><div class="line"><span class="comment">--changeset daniel:16040707</span></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`role_authority_sum`</span> (</div><div class="line">  <span class="string">`row_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增id'</span>,</div><div class="line">  <span class="string">`role_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'关联role的role_id'</span>,</div><div class="line">  <span class="string">`authority_sum`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'perms的值的和'</span>,</div><div class="line">  <span class="string">`data_type_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'关联data_type的id'</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`row_id`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'角色的权限值的和，如角色有RD权限，则和为2+8=10'</span>;</div></pre></td></tr></table></figure></code></pre><h2 id="2-常用的标签及命令"><a href="#2-常用的标签及命令" class="headerlink" title="2. 常用的标签及命令"></a>2. 常用的标签及命令</h2><h3 id="2-1-标签"><a href="#2-1-标签" class="headerlink" title="2.1 标签"></a>2.1 <changeset>标签</changeset></h3><p>一个<code>&lt;changeSet&gt;</code>标签对应一个变更集，由属性<code>id</code>、<code>name</code>，以及changelog的文件路径唯一标识。changelog在执行的时候并不是按照id的顺序，而是按照changeSet在changelog中出现的顺序。</p><p>LiquiBase在执行changelog时，会在数据库中插入两张表：<code>DATABASECHANGELOG</code>和<code>DATABASECHANGELOGLOCK</code>，分别记录changelog的执行日志和锁日志。</p><p>LiquiBase在执行changelog中的changeSet时，会首先查看<code>DATABASECHANGELOG</code>表，如果已经执行过，则会跳过（除非changeSet的<code>runAlways</code>属性为true，后面会介绍），如果没有执行过，则执行并记录changelog日志；</p><p>changelog中的一个changeSet对应一个事务，在changeSet执行完后commit，如果出现错误则rollback；</p><p><code>&lt;changeSet&gt;</code>标签的主要属性有：</p><ul><li><p>runAlways：即使已经执行过，仍然每次都执行；<strong>注意</strong>: 由于<code>DATABASECHANGELOG</code>表中还记录了changeSet的MD5校验值MD5SUM，如果changeSet的<code>id</code>和<code>name</code>没变，而内容变了，则由于MD5值变了，即使runAlways的值为True，执行也是失败的，会报错。这种情况应该使用<code>runOnChange</code>属性。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ERROR] Failed to execute goal org.liquibase:liquibase-maven-plugin:3.4.2:update (default-cli) on project tx_test: Error setting up or running Liquibase: Validation Failed:</div><div class="line">[ERROR] 1 change sets check sum</div></pre></td></tr></table></figure></li><li><p>runOnChange：第一次的时候执行以及当changeSet的内容发生变化时执行。不受MD5校验值的约束。</p></li><li><p>runInTransaction：是否作为一个事务执行，默认为true。设置为false时需要<strong>小心</strong>：如果执行过程中出错了则不会rollback，数据库很可能处于不一致的状态；</p></li></ul><p><code>&lt;changeSet&gt;</code>下有一个重要的子标签<code>&lt;rollback&gt;</code>，即定义回滚的SQL语句。对于<code>create table</code>, <code>rename column</code>和<code>add column</code>等，LiquiBase会自动生成对应的rollback语句，而对于<code>drop table</code>、<code>insert data</code>等则需要显示定义rollback语句。</p><h3 id="2-2-lt-include-gt-与-lt-includeAll-gt-标签"><a href="#2-2-lt-include-gt-与-lt-includeAll-gt-标签" class="headerlink" title="2.2 &lt;include&gt;与&lt;includeAll&gt;标签"></a>2.2 <code>&lt;include&gt;</code>与<code>&lt;includeAll&gt;</code>标签</h3><p>当changelog文件越来越多时，可以使用<code>&lt;include&gt;</code>将文件管理起来，如：</p><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">databaseChangeLog</span></span></div><div class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://www.liquibase.org/xml/ns/dbchangelog"</span></span></div><div class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.liquibase.org/xml/ns/dbchangelog</span></span></div><div class="line"><span class="tag"><span class="string">    http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"logset-20160408/0001_authorization_init.sql"</span> <span class="attr">relativeToChangelogFile</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">databaseChangeLog</span>&gt;</span></div></pre></td></tr></table></figure></code></pre><p><code>&lt;include&gt;</code>的<strong>file</strong>属性表示要包含的changelog文件的路径，这个文件可以是LiquiBase支持的任意格式，<strong>relativeToChangelogFile</strong>如果为true，则表示<strong>file</strong>属性表示的文件路径是相对于根changelog而不是<strong>CLASSPATH</strong>的，默认为false。</p><p><code>&lt;includeAll&gt;</code>指定的是changelog的目录，而不是为文件，如：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;includeAll path=&quot;com/example/changelogs/&quot;/&gt;</div></pre></td></tr></table></figure></code></pre><p><strong>注意</strong>: 目前<code>&lt;include&gt;</code>没有解决重复引用和循环引用的问题，重复引用还好，LiquiBase在执行的时候可以判断重复，而循环引用会导致无限循环，需要注意！</p><h3 id="2-3-diff命令"><a href="#2-3-diff命令" class="headerlink" title="2.3 diff命令"></a>2.3 diff命令</h3><p>diff命令用于比较数据库之间的异同。比如通过命令行执行：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">java -jar liquibase.jar --driver=com.mysql.jdbc.Driver \</div><div class="line">    --classpath=./mysql-connector-java-5.1.29.jar \</div><div class="line">    --url=jdbc:mysql://127.0.0.1:3306/test \</div><div class="line">    --username=root --password=passwd \</div><div class="line">    diff \</div><div class="line">    --referenceUrl=jdbc:mysql://127.0.0.1:3306/authorization \</div><div class="line">    --referenceUsername=root --referencePassword=passwd</div></pre></td></tr></table></figure></code></pre><h3 id="2-4-generateChangeLog"><a href="#2-4-generateChangeLog" class="headerlink" title="2.4 generateChangeLog"></a>2.4 generateChangeLog</h3><p>在已有的项目上使用LiquiBase，要生成当前数据库的changeset，可以采用两种方式，一种是使用数据库工具导出SQL数据，然后changelog文件以SQL格式记录即可；另一种方式就是用<code>generateChangeLog</code>命令，如：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">liquibase --driver=com.mysql.jdbc.Driver \</div><div class="line">      --classpath=./mysql-connector-java-5.1.29.jar \</div><div class="line">      --changeLogFile=liquibase/db.changelog.xml \</div><div class="line">      --url=&quot;jdbc:mysql://127.0.0.1:3306/test&quot; \</div><div class="line">      --username=root \</div><div class="line">      --password=yourpass \</div><div class="line">      generateChangeLog</div></pre></td></tr></table></figure></code></pre><p>不过<code>generateChangeLog</code>不支持以下功能：存储过程、函数以及触发器；</p><h2 id="3-Maven集成LiquiBase"><a href="#3-Maven集成LiquiBase" class="headerlink" title="3. Maven集成LiquiBase"></a>3. Maven集成LiquiBase</h2><h3 id="3-1-liquibase-maven-plugin的配置"><a href="#3-1-liquibase-maven-plugin的配置" class="headerlink" title="3.1 liquibase-maven-plugin的配置"></a>3.1 <code>liquibase-maven-plugin</code>的配置</h3><p>Maven中集成LiquiBase，主要是配置<code>liquibase-maven-plugin</code>，首先给出一个示例：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">  &lt;groupId&gt;org.liquibase&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;liquibase-maven-plugin&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;3.4.2&lt;/version&gt;</div><div class="line">  &lt;configuration&gt;</div><div class="line">      &lt;changeLogFile&gt;src/main/resources/liquibase/test_changelog.xml&lt;/changeLogFile&gt;</div><div class="line">      &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt;</div><div class="line">      &lt;url&gt;jdbc:mysql://127.0.0.1:3306/test&lt;/url&gt;</div><div class="line">      &lt;username&gt;root&lt;/username&gt;</div><div class="line">      &lt;password&gt;passwd&lt;/password&gt;</div><div class="line">  &lt;/configuration&gt;</div><div class="line">  &lt;executions&gt;</div><div class="line">      &lt;execution&gt;</div><div class="line">          &lt;phase&gt;process-resources&lt;/phase&gt;</div><div class="line">          &lt;goals&gt;</div><div class="line">              &lt;goal&gt;update&lt;/goal&gt;</div><div class="line">          &lt;/goals&gt;</div><div class="line">      &lt;/execution&gt;</div><div class="line">  &lt;/executions&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></code></pre><p>其中<code>&lt;configuration&gt;</code>节点中的配置可以放在单独的配置文件里。</p><p>如果需要在父项目中配置子项目共享的LiquiBase配置，而各个子项目可以定义自己的配置，并覆盖父项目中的配置，则只需要在父项目的pom中将<code>propertyFileWillOverride</code>设置为true即可，如：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">    &lt;groupId&gt;org.liquibase&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;liquibase-maven-plugin&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;3.4.2&lt;/version&gt;</div><div class="line">    &lt;configuration&gt;</div><div class="line">        &lt;propertyFileWillOverride&gt;true&lt;/propertyFileWillOverride&gt;</div><div class="line">        &lt;propertyFile&gt;liquibase/liquibase.properties&lt;/propertyFile&gt;</div><div class="line">    &lt;/configuration&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></code></pre><h3 id="3-2-liquibase-update"><a href="#3-2-liquibase-update" class="headerlink" title="3.2 liquibase:update"></a>3.2 <code>liquibase:update</code></h3><p>执行changelog中的变更：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn liquibase:update</div></pre></td></tr></table></figure></code></pre><h3 id="3-3-liquibase-rollback"><a href="#3-3-liquibase-rollback" class="headerlink" title="3.3 liquibase:rollback"></a>3.3 <code>liquibase:rollback</code></h3><p>rollback有3中形式，分别是：</p><ul><li>rollbackCount: 表示rollback的changeset的个数；</li><li>rollbackDate：表示rollback到指定的日期；</li><li>rollbackTag：表示rollback到指定的tag，需要使用LiquiBase在具体的时间点打上tag；</li></ul><p><code>rollbackCount</code>比较简单，示例如：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn liquibase:rollback -Dliquibase.rollbackCount=3</div></pre></td></tr></table></figure></code></pre><p><code>rollbackDate</code>需要注意日期的格式，必须匹配当前平台上执行<code>DateFormat.getDateInstance()</code>得到的格式，比如我的格式为<code>MMM d, yyyy</code>，示例如：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn liquibase:rollback -Dliquibase.rollbackDate=&quot;Apr 10, 2016&quot;</div></pre></td></tr></table></figure></code></pre><p><code>rollbackTag</code>使用tag标识，所以需要先打tag，示例如：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn liquibase:tag -Dliquibase.tag=tag20160410</div></pre></td></tr></table></figure></code></pre><p>然后rollback到tag20160410，如：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn liquibase:rollback -Dliquibase.rollbackTag=tag20160410</div></pre></td></tr></table></figure></code></pre><h2 id="4-Gradle集成LiquiBase"><a href="#4-Gradle集成LiquiBase" class="headerlink" title="4. Gradle集成LiquiBase"></a>4. Gradle集成LiquiBase</h2><p>首先在<code>build.gradle</code>中配置<code>liquibase-gradle-plugin</code>：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        mavenCentral()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &quot;org.liquibase:liquibase-gradle-plugin:1.2.1&quot;</div><div class="line">        classpath &quot;mysql:mysql-connector-java:5.1.38&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">apply plugin: &apos;org.liquibase.gradle&apos;</div></pre></td></tr></table></figure></code></pre><p>然后在<code>build.gradle</code>中配置该plugin的activities，其中一个activity表示一种运行环境：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">liquibase &#123;</div><div class="line">    activities &#123;</div><div class="line">        main &#123;</div><div class="line">            changeLogFile &quot;src/main/resources/web-bundle-config/liquibase/main-changelog.xml&quot;</div><div class="line">            url &quot;jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;</div><div class="line">            username &quot;root&quot;</div><div class="line">            password &quot;yourpass&quot;</div><div class="line">        &#125;</div><div class="line">        test &#123;</div><div class="line">            main &#123;</div><div class="line">                changeLogFile &quot;src/main/resources/web-bundle-config/liquibase/main-test-changelog.xml&quot;</div><div class="line">                url &quot;jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;</div><div class="line">                username &quot;root&quot;</div><div class="line">                password &quot;yourpass&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        runList = project.ext.runList</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p>比如执行main的命令为：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gradle update -PrunList=main</div></pre></td></tr></table></figure></code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="http://www.liquibase.org/documentation/index.html" target="_blank" rel="external">Building Changelogs</a></li><li><a href="http://stackoverflow.com/questions/11131978/how-to-tag-a-changeset-in-liquibase-to-rollback" target="_blank" rel="external">How to tag a changeset in liquibase to rollback</a></li><li><a href="http://izeye.blogspot.co.uk/2015/07/only-buildscript-and-other-plugins.html" target="_blank" rel="external">only buildscript {} and other plugins {} script blocks are allowed before plugins {} blocks, no other statements are allowed</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.liquibase.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LiquiBase&lt;/a&gt;是一个用于数据库重构和迁移的开源工具，通过日志文件的形式记录数据库的变更，然后执行日志文件中的修改，将数据库更新或回滚到一致的状态。LiquiBase的主要特点有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持几乎所有主流的数据库，如MySQL, PostgreSQL, Oracle, Sql Server, DB2等；&lt;/li&gt;
&lt;li&gt;支持多开发者的协作维护；&lt;/li&gt;
&lt;li&gt;日志文件支持多种格式，如XML, YAML, JSON, SQL等；&lt;/li&gt;
&lt;li&gt;支持多种运行方式，如命令行、Spring集成、Maven插件、Gradle插件等；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="LiquiBase" scheme="http://nkcoder.github.io/tags/LiquiBase/"/>
    
      <category term="Maven" scheme="http://nkcoder.github.io/tags/Maven/"/>
    
      <category term="Gradle" scheme="http://nkcoder.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Ehcache以及与MyBatis的集成</title>
    <link href="http://nkcoder.github.io/2016/04/09/ehcache-mybatis/"/>
    <id>http://nkcoder.github.io/2016/04/09/ehcache-mybatis/</id>
    <published>2016-04-09T14:23:36.000Z</published>
    <updated>2017-09-27T14:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Ehcache是目前使用很广泛的Java系的开源cache。可以把它当作通用的cache，或者作为Hibernate/MyBatis等的二级缓存。本文简要介绍在MyBatis中集成Ehcache，其中Ehcache的版本是<strong>2.10.1</strong>。</p><h2 id="1-Ehcache的配置"><a href="#1-Ehcache的配置" class="headerlink" title="1. Ehcache的配置"></a>1. Ehcache的配置</h2><p>Ehcache默认使用<strong>CLASSPATH</strong>根目录下的<code>ehcache.xml</code>作为配置文件，如果没找到，则使用Jar包下的<code>ehcache-failsafe.xml</code>作为配置文件，该配置文件提供了默认的简单配置：</p><a id="more"></a><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"../config/ehcache.xsd"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"java.io.tmpdir"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">defaultCache</span></span></div><div class="line"><span class="tag"><span class="attr">maxElementsInMemory</span>=<span class="string">"10000"</span></span></div><div class="line"><span class="tag"><span class="attr">eternal</span>=<span class="string">"false"</span></span></div><div class="line"><span class="tag"><span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span></span></div><div class="line"><span class="tag"><span class="attr">timeToLiveSeconds</span>=<span class="string">"120"</span></span></div><div class="line"><span class="tag"><span class="attr">maxElementsOnDisk</span>=<span class="string">"10000000"</span></span></div><div class="line"><span class="tag"><span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></div><div class="line"><span class="tag"><span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">persistence</span> <span class="attr">strategy</span>=<span class="string">"localTempSwap"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></div></pre></td></tr></table></figure></code></pre><p><code>&lt;ehcache&gt;</code>节点对应一个CacheManager，一个CacheManager可以管理多个cache实例。<code>ehcache</code>节点可配置参数主要有：</p><pre><code>- updateCheck: CacheManager是否自动在线检测Ehcache的新版本，默认为true；- dynamicConfig: 是否允许cache动态配置，即运行时动态调整内存、磁盘等的容量，默认为true；</code></pre><p>以下三个配置由CacheManager管理的所有cache共享，单位可以时B/M/G：</p><pre><code>- maxBytesLocalHeap: CacheManager可用的最大heap内存;- maxBytesLocalOffHeap: CacheManager可用的最大的off-heap内存；- maxBytesLocalDisk: CacheManager可用的最大的本地disk空间；</code></pre><p><code>&lt;diskStore&gt;</code>节点表示启用磁盘cache时的文件路径，如果使用了磁盘作为cache，但是没有指定<code>&lt;diskStore&gt;</code>，则Ehcache默认使用<code>java.io.tmpdir</code>作为cache的磁盘路径；</p><p><code>&lt;cache&gt;</code>节点和<code>&lt;defaultCache&gt;</code>都用于表示一个cache实例，不同的是<code>&lt;cache&gt;</code>需要配置<code>name</code>属性，而<code>&lt;defaultCache&gt;</code>不需要，因为它的name默认为<code>default</code>，<code>&lt;defaultCache&gt;</code>用于未显式配置的cache。</p><p><code>&lt;cache&gt;</code>节点中的主要参数有：</p><ul><li>name：唯一标识cache实例；</li><li>maxEntriesLocalHeap：Memory中可保存的对象的最大数量，默认为0表示不限；</li><li>maxEntriesLocalDisk：Disk中可保存的对象的最大数量，默认为0表示不限；</li><li>eternal：表示cache是否过期，如果eternal为true，则对象永不过期；</li><li>maxBytesLocalHeap：该实例的最大可用Heap，不能超过<code>&lt;ehcache&gt;</code>中配置到CacheManager的最大Heap容量，如果使用了maxBytesLocalHeap，则不能使用maxBytesLocalHeap；</li><li>maxBytesLocalDisk：该实例的最大可用磁盘容量；</li><li>timeToIdleSeconds：表示对象最后一次访问到过期的时间，默认为0，表示不过期，该参数仅当eternal为false时有效；</li><li>timeToLiveSeconds：表示对象从创建到过期的时间，默认为0，表示不过期，该参数仅当eternal为false时有效；</li><li>memoryStoreEvictionPolicy：当cache的对象达到maxEntriesLocalHeap限制时使用的剔除策略，默认为<code>LRU</code>，可用值有：LRU, FIFO, LFU</li></ul><p><code>&lt;persistence&gt;</code>节点的参数:</p><pre><code>- &lt;strategy&gt;表示持久化方式，值为localTempSwap表示当heap/off-heap满的时候，将缓存的对象持久化到disk，none表示不持久化chache；</code></pre><h2 id="2-MyBatis中配置Ehcache"><a href="#2-MyBatis中配置Ehcache" class="headerlink" title="2. MyBatis中配置Ehcache"></a>2. MyBatis中配置Ehcache</h2><p>首先添加<code>mybatis-ehcache</code>依赖，当前版本是<strong>1.0.3</strong>，然后配置<code>ehcache.xml</code>并放在CLASSPATH的根目录下，最后在mapper文件中定义<code>&lt;cache&gt;</code>节点，如：</p><pre><code>&lt;mapper namespace=&quot;xxx&quot;&gt;    &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;    &lt;select id=&quot;xxx&quot; parameterType=&quot;map&quot; resultType=&quot;xxx&quot;&gt;        ...    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>也可以在<code>&lt;cache&gt;</code>节点中配置ecache，就不需要额外的<code>.ecache.xml</code>配置了，如：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;</div><div class="line">      &lt;property name=&quot;timeToIdleSeconds&quot; value=&quot;3600&quot;/&gt;</div><div class="line">      &lt;property name=&quot;timeToLiveSeconds&quot; value=&quot;3600&quot;/&gt;</div><div class="line">      &lt;property name=&quot;maxEntriesLocalHeap&quot; value=&quot;1000&quot;/&gt;</div><div class="line">      &lt;property name=&quot;maxEntriesLocalDisk&quot; value=&quot;100000&quot;/&gt;</div><div class="line">      &lt;property name=&quot;memoryStoreEvictionPolicy&quot; value=&quot;LRU&quot;/&gt;</div><div class="line">  &lt;/cache&gt;</div></pre></td></tr></table></figure></code></pre><p>在<code>mybatis-ehcache</code>的1.1.0-SNAPSHOT中，cache的type，除了<code>EhcacheCache</code>，还可以是<code>EhBlockingCache</code>。<code>EhBlockingCache</code>的主要应用场景是要缓存的数据是动态变化的，而并发访问数据的请求非常高，此时使用阻塞cache，让第一个线程去cache，其它等待的限制只需要直接去cache中取数据即可。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="http://www.ehcache.org/generated/2.10.1/html/ehc-all/#page/Ehcache_Documentation_Set%2Fto-cfgbasics_configuring_cache.html%23" target="_blank" rel="external">Configuring Cache</a></li><li><a href="http://www.mybatis.org/ehcache-cache/index.html" target="_blank" rel="external">MyBatis Ehcache Adapter - Reference Documentation</a></li><li><a href="http://www.ehcache.org/ehcache.xml" target="_blank" rel="external">ehcache.xml</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ehcache是目前使用很广泛的Java系的开源cache。可以把它当作通用的cache，或者作为Hibernate/MyBatis等的二级缓存。本文简要介绍在MyBatis中集成Ehcache，其中Ehcache的版本是&lt;strong&gt;2.10.1&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;1-Ehcache的配置&quot;&gt;&lt;a href=&quot;#1-Ehcache的配置&quot; class=&quot;headerlink&quot; title=&quot;1. Ehcache的配置&quot;&gt;&lt;/a&gt;1. Ehcache的配置&lt;/h2&gt;&lt;p&gt;Ehcache默认使用&lt;strong&gt;CLASSPATH&lt;/strong&gt;根目录下的&lt;code&gt;ehcache.xml&lt;/code&gt;作为配置文件，如果没找到，则使用Jar包下的&lt;code&gt;ehcache-failsafe.xml&lt;/code&gt;作为配置文件，该配置文件提供了默认的简单配置：&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="缓存" scheme="http://nkcoder.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Ehcache" scheme="http://nkcoder.github.io/tags/Ehcache/"/>
    
      <category term="MyBatis" scheme="http://nkcoder.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Google编码规范：python</title>
    <link href="http://nkcoder.github.io/2016/02/26/google-python-style-guide/"/>
    <id>http://nkcoder.github.io/2016/02/26/google-python-style-guide/</id>
    <published>2016-02-26T14:23:36.000Z</published>
    <updated>2017-10-08T03:20:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-Language-Rules"><a href="#Python-Language-Rules" class="headerlink" title="Python Language Rules"></a>Python Language Rules</h1><h2 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h2><pre><code>使用`pylint`检查代码的bug和编码规范等问题。</code></pre><p><code>pylint</code>可以检测一些常见的错误，比如拼写错误、用<code>var</code>声明变量等，但是<code>pylint</code>并不完全准确，经常会有一些误报的warning，这些warning可以忽略。</p><h2 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h2><pre><code>`import`仅用于package和module。</code></pre><p><code>import x</code>: import一个package或module；<br><code>from x import y</code>: x是package名，y是不带前缀的module名；<br><code>from x import y as z</code>: 如果有两个module的名称都是y，或者y的名字比较长时，使用这种形式；</p><p>在import中不要使用相对名称，应该使用package的全名。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</div><div class="line">...</div><div class="line">echo.EchoFilter(input, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</div></pre></td></tr></table></figure><h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><pre><code>在import一个module的时候，使用module的全路径名。</code></pre><p>可以避免module名冲突。方便module的查找。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Reference in code with complete name.</span></div><div class="line"><span class="keyword">import</span> sound.effects.echo</div><div class="line"></div><div class="line"><span class="comment"># Reference in code with just module name (preferred).</span></div><div class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</div></pre></td></tr></table></figure><h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><pre><code>Exception可以使用，但是必须谨慎。</code></pre><p>使用Exception，需遵循以下原则：</p><ul><li><p>使用<code>raise MyException(&#39;Error message&#39;)</code>或<code>raise MyException</code>，不要使用两个参数的形式(<code>raise MyException, &#39;Error message&#39;</code>)，也不要使用过时的String形式(<code>raise &#39;Error message&#39;</code>)。</p></li><li><p>module或package应该定义自己的exception基类，该基类应该继承<code>Exception</code>类。<br>例如：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Error</span><span class="params">(Exception)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure><ul><li>不要使用捕获所有异常(catch-all)的形式，如<code>except:</code>, 或<code>except Exception:</code>, 以及<code>except StandardError</code>等，除非将异常重新抛出，或者当前处于线程的最外层。否则所有的异常（比如拼写错误、单元测试错误、Ctrl+C中断等）都会被捕获。</li><li>尽量简化<code>try/except</code>中的代码块，代码越多，发生错误的概率就越大，而真正的错误很可能被忽略了。</li><li>无论是否发生Exception，使用<code>finally</code>执行一些代码，比如关闭文件；</li><li>当捕获到Exception时，使用<code>as</code>而不是逗号。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">raise</span> Error</div><div class="line"><span class="keyword">except</span> Error <span class="keyword">as</span> error:</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure><h2 id="Global-Variables"><a href="#Global-Variables" class="headerlink" title="Global Variables"></a>Global Variables</h2><pre><code>尽量避免使用全局变量。</code></pre><p>当moduel被import后，module变量（全局变量）可以通过赋值修改。</p><p>尽量使用class变量，而不是全局变量。以下是例外情况：</p><ul><li>脚本的默认选项；</li><li>module的常量，例如：<code>PI = 3.14159</code>;</li><li>通过全局变量缓存值；</li></ul><h2 id="Nested-Local-Inner-Classes-and-Functions"><a href="#Nested-Local-Inner-Classes-and-Functions" class="headerlink" title="Nested/Local/Inner Classes and Functions"></a>Nested/Local/Inner Classes and Functions</h2><pre><code>嵌套定义class和function是允许的</code></pre><p>class可以定义在method/function/class中，function可以定义在method/function中。嵌套的函数对于上层的变量是只读的；适用于在一个作用域内定义工具类和函数。</p><h2 id="List-Comprehensions"><a href="#List-Comprehensions" class="headerlink" title="List Comprehensions"></a>List Comprehensions</h2><pre><code>适用于简单的情形</code></pre><p>例如：</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">result = []</div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">            <span class="keyword">if</span> x * y &gt; <span class="number">10</span>:</div><div class="line">                result.append((x, y))</div><div class="line"></div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">5</span>):</div><div class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">5</span>):</div><div class="line">            <span class="keyword">if</span> x != y:</div><div class="line">                <span class="keyword">for</span> z <span class="keyword">in</span> xrange(<span class="number">5</span>):</div><div class="line">                    <span class="keyword">if</span> y != z:</div><div class="line">                        <span class="keyword">yield</span> (x, y, z)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ((x, complicated_transform(x))</div><div class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> long_generator_function(parameter)</div><div class="line">            <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>)</div><div class="line"></div><div class="line">    squares = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</div><div class="line"></div><div class="line">    eat(jelly_bean <span class="keyword">for</span> jelly_bean <span class="keyword">in</span> jelly_beans</div><div class="line">        <span class="keyword">if</span> jelly_bean.color == <span class="string">'black'</span>)</div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">result = [(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">if</span> x * y &gt; <span class="number">10</span>]</div><div class="line"></div><div class="line"><span class="keyword">return</span> ((x, y, z)</div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">5</span>)</div><div class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">5</span>)</div><div class="line">        <span class="keyword">if</span> x != y</div><div class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> xrange(<span class="number">5</span>)</div><div class="line">        <span class="keyword">if</span> y != z)</div></pre></td></tr></table></figure><h2 id="Default-Iterators-and-Operators"><a href="#Default-Iterators-and-Operators" class="headerlink" title="Default Iterators and Operators"></a>Default Iterators and Operators</h2><pre><code>如果类型支持（如list/dictionary/file)，使用默认的iterator和operator。</code></pre><p>容器类型，如list/dictionary定义了默认的iterator和成员测试操作符(<code>in</code>和<code>not in</code>)，使用这些默认的iterator和operator，简单高效，没有额外的函数调用开销，例如：</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> adict: ...</div><div class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> adict: ...</div><div class="line"><span class="keyword">if</span> obj <span class="keyword">in</span> alist: ...</div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> afile: ...</div><div class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> dict.iteritems(): ...</div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> adict.keys(): ...</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> adict.has_key(key): ...</div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> afile.readlines(): ...</div></pre></td></tr></table></figure><h2 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h2><pre><code>在需要的时候使用generator.</code></pre><p>代码更简单，相比函数一次创建整个list，generator消耗的内存更少。</p><h2 id="Lambda-Functions"><a href="#Lambda-Functions" class="headerlink" title="Lambda Functions"></a>Lambda Functions</h2><pre><code>适用于`一行代码`的情形。</code></pre><p>Lambda表达式就是匿名函数，一般作为<code>map()</code>/<code>filter()</code>等高阶函数的回调或操作符；<br>如果lambda表达式中的代码比较长（超过60-80字符），最好定义成函数；<br>常用的操作，比如乘法运算，推荐使用<code>operator</code>模块(<code>operator.mul</code>)，而不是lambda函数(<code>lambda x, y: x * y</code>)。</p><h2 id="Conditional-Expressions"><a href="#Conditional-Expressions" class="headerlink" title="Conditional Expressions"></a>Conditional Expressions</h2><pre><code>适用于`一行代码`的情形。</code></pre><p>条件表达式就是if语句的简写形式，代码更短也更方便，但是如果表达式语句较长，则条件可能不容易定位。<br>适用于只有一行代码的情形，其它情况使用if语句。</p><h2 id="Default-Argument-Values"><a href="#Default-Argument-Values" class="headerlink" title="Default Argument Values"></a>Default Argument Values</h2><pre><code>大部分情况下都是可以的。</code></pre><p>函数的参数可以使用默认值，但是不要将可变对象作为函数的默认值：</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b=None)</span>:</span></div><div class="line">            <span class="keyword">if</span> b <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                b = []</div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">No:  <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b=[])</span>:</span></div><div class="line">            ...</div><div class="line">No:  <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b=time.time<span class="params">()</span>)</span>:</span>  <span class="comment"># The time the module was loaded???</span></div><div class="line">            ...</div><div class="line">No:  <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b=FLAGS.my_thing)</span>:</span>  <span class="comment"># sys.argv has not yet been parsed...</span></div><div class="line">            ...</div></pre></td></tr></table></figure><h2 id="True-False-evaluations"><a href="#True-False-evaluations" class="headerlink" title="True/False evaluations"></a>True/False evaluations</h2><pre><code>尽量使用`隐式`的false判断。</code></pre><p>所有含义为空的值，如<code>0</code>/<code>None</code>/<code>[]</code>/<code>{}</code>/<code>&#39;&#39;</code>都是false；</p><ul><li>使用<code>if foo:</code>，而不是<code>if foo != []</code>;</li><li>不要使用<code>==</code>或<code>!=</code>去比较<code>None</code>，应该用<code>is</code>或<code>is not</code>；</li><li>不要使用<code>==</code>去比较<code>False</code>，应该使用<code>if not x:</code>; 如果要区分<code>False</code>和<code>None</code>，使用<br><code>if not x and x is not None:</code>；</li><li>对于列表类型(string/list/tuple)，空值表示false，使用<code>if not seq:</code>或<code>if seq:</code>，比使用<code>if len(seq):</code>或<br><code>if not len(seq):</code>更好；</li><li>注意，’0’是true；</li><li>对于整数，必须额外小心，不要将<code>None</code>当作0处理：</li></ul><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> users:</div><div class="line">        <span class="keyword">print</span> <span class="string">'no users'</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> foo == <span class="number">0</span>:</div><div class="line">        self.handle_zero()</div><div class="line"></div><div class="line"><span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span>:</div><div class="line">        self.handle_multiple_of_ten()</div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> len(users) == <span class="number">0</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">'no users'</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> foo <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> foo:</div><div class="line">        self.handle_zero()</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> i % <span class="number">10</span>:</div><div class="line">        self.handle_multiple_of_ten()</div></pre></td></tr></table></figure><h2 id="Threading"><a href="#Threading" class="headerlink" title="Threading"></a>Threading</h2><pre><code>不要依赖内置类型的原子行(atomicity)</code></pre><p>有一些内置类型(如dictionary)的某些操作看起来是原子性的，但是它们不可靠；<br>使用<strong>Queue</strong>模块中的<code>Queue</code>作为线程间交互的数据结构，或者使用<strong>threading</strong>模块。</p><h1 id="Python-Style-Rules"><a href="#Python-Style-Rules" class="headerlink" title="Python Style Rules"></a>Python Style Rules</h1><h2 id="Semicolons"><a href="#Semicolons" class="headerlink" title="Semicolons"></a>Semicolons</h2><pre><code>语句结尾不要使用分号，也不要通过分号将两条语句写在同一行上。</code></pre><h2 id="Line-length"><a href="#Line-length" class="headerlink" title="Line length"></a>Line length</h2><pre><code>最大行宽为80个字符，除非：1. 很长的import语句；2. 注释中的URL。</code></pre><p>不要使用反斜线(<code>\</code>)做行连接。<br>使用<code>(), [], {}</code>的隐式连接方式，如果有必要，可以将表达式放在额外的括号中：</p><a id="more"></a><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo_bar(self, width, height, color=<span class="string">'black'</span>, design=<span class="keyword">None</span>, x=<span class="string">'foo'</span>,</div><div class="line">        emphasis=<span class="keyword">None</span>, highlight=<span class="number">0</span>)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (width == <span class="number">0</span> <span class="keyword">and</span> height == <span class="number">0</span> <span class="keyword">and</span></div><div class="line">        color == <span class="string">'red'</span> <span class="keyword">and</span> emphasis == <span class="string">'strong'</span>):</div></pre></td></tr></table></figure><p>如果字符串太长，一行容不下，使用括号进行隐式连接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = (<span class="string">'This will build a very long long '</span></div><div class="line">        <span class="string">'long long long long long long string'</span>)</div></pre></td></tr></table></figure><p>在注释中，URL始终在一行显示：</p><p>Yes:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># See details at</span></div><div class="line"><span class="comment"># http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html</span></div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># See details at</span></div><div class="line"><span class="comment"># http://www.example.com/us/developer/documentation/api/content/\</span></div><div class="line"><span class="comment"># v2.0/csv_file_name_extension_full_specification.html</span></div></pre></td></tr></table></figure><h2 id="Parentheses"><a href="#Parentheses" class="headerlink" title="Parentheses"></a>Parentheses</h2><pre><code>括号能不用则不用。</code></pre><p>在条件判断、返回语句中不要使用括号，除非用于较长字符串的隐式连接。<br>tuple用括号是可以的。</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> foo:</div><div class="line">    bar()</div><div class="line"><span class="keyword">while</span> x:</div><div class="line">    x = bar()</div><div class="line"><span class="keyword">if</span> x <span class="keyword">and</span> y:</div><div class="line">    bar()</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> x:</div><div class="line">    bar()</div><div class="line"><span class="keyword">return</span> foo</div><div class="line"><span class="keyword">for</span> (x, y) <span class="keyword">in</span> dict.items(): ...</div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (x):</div><div class="line">    bar()</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span>(x):</div><div class="line">    bar()</div><div class="line"><span class="keyword">return</span> (foo)</div></pre></td></tr></table></figure><h2 id="Indentation"><a href="#Indentation" class="headerlink" title="Indentation"></a>Indentation</h2><pre><code>代码缩进使用4个空格。</code></pre><p>不要使用tab或混用tab和空格。<br>在隐式行连接时，上一行如果没有参数，则两行元素垂直对齐；如果上一行有参数，则下一行缩进4个空格。</p><p>Yes:   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Aligned with opening delimiter</span></div><div class="line">foo = long_function_name(var_one, var_two,</div><div class="line">                            var_three, var_four)</div><div class="line"></div><div class="line"><span class="comment"># Aligned with opening delimiter in a dictionary</span></div><div class="line">foo = &#123;</div><div class="line">    long_dictionary_key: value1 +</div><div class="line">                            value2,</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 4-space hanging indent; nothing on first line</span></div><div class="line">foo = long_function_name(</div><div class="line">    var_one, var_two, var_three,</div><div class="line">    var_four)</div><div class="line"></div><div class="line"><span class="comment"># 4-space hanging indent in a dictionary</span></div><div class="line">foo = &#123;</div><div class="line">    long_dictionary_key:</div><div class="line">        long_dictionary_value,</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Stuff on first line forbidden</span></div><div class="line">foo = long_function_name(var_one, var_two,</div><div class="line">    var_three, var_four)</div><div class="line"></div><div class="line"><span class="comment"># 2-space hanging indent forbidden</span></div><div class="line">foo = long_function_name(</div><div class="line">    var_one, var_two, var_three,</div><div class="line">    var_four)</div><div class="line"></div><div class="line"><span class="comment"># No hanging indent in a dictionary</span></div><div class="line">foo = &#123;</div><div class="line">    long_dictionary_key:</div><div class="line">        long_dictionary_value,</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Blank-Lines"><a href="#Blank-Lines" class="headerlink" title="Blank Lines"></a>Blank Lines</h2><pre><code>顶层(top-level)的定义之间空两行，method之间空一行。</code></pre><p>top-level定义，无论是function还是class，空两行。<br>method之间，以及class与第一个method之间，空一行。</p><h2 id="Whitespace"><a href="#Whitespace" class="headerlink" title="Whitespace"></a>Whitespace</h2><pre><code>按照标准排印规则使用空格。</code></pre><p><code>(), [], {}</code>里面不要使用空格：</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spam(ham[<span class="number">1</span>], &#123;eggs: <span class="number">2</span>&#125;, [])</div></pre></td></tr></table></figure><p>No:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spam( ham[ <span class="number">1</span> ], &#123; eggs: <span class="number">2</span> &#125;, [ ] )</div></pre></td></tr></table></figure><p>逗号，分号和冒号前面没有空格。除非是在一行的末尾，否则逗号、分号和冒号的后面需要使用空格：</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> x == <span class="number">4</span>:</div><div class="line">    <span class="keyword">print</span> x, y</div><div class="line">    x, y = y, x</div></pre></td></tr></table></figure><p>No:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> x == <span class="number">4</span> :</div><div class="line">    <span class="keyword">print</span> x , y</div><div class="line">x , y = y , x</div></pre></td></tr></table></figure><p>作为参数列表或下标索引的小括号()和中括号[]的前面不要使用空格：</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spam(<span class="number">1</span>)</div></pre></td></tr></table></figure><p>No:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spam (<span class="number">1</span>)</div></pre></td></tr></table></figure><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dict[<span class="string">'key'</span>] = list[index]</div></pre></td></tr></table></figure><p>No:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dict [<span class="string">'key'</span>] = list [index]</div></pre></td></tr></table></figure><p>二元操作符(<code>==, &gt;, &lt; !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not, and, or, not</code>)的前后各使用一个空格：</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x == <span class="number">1</span></div></pre></td></tr></table></figure><p>No:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x&lt;<span class="number">1</span></div></pre></td></tr></table></figure><p><code>=</code>用于参数默认值时，前后不要使用空格：</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag=<span class="number">0.0</span>)</span>:</span> <span class="keyword">return</span> magic(r=real, i=imag)</div></pre></td></tr></table></figure><p>No:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag = <span class="number">0.0</span>)</span>:</span> <span class="keyword">return</span> magic(r = real, i = imag)</div></pre></td></tr></table></figure><p>对于连续的行，不要通过空格去垂直对齐(主要是<code>=</code>和<code>#</code>):</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo = <span class="number">1000</span>  <span class="comment"># comment</span></div><div class="line">long_name = <span class="number">2</span>  <span class="comment"># comment that should not be aligned</span></div><div class="line"></div><div class="line">dictionary = &#123;</div><div class="line">    <span class="string">'foo'</span>: <span class="number">1</span>,</div><div class="line">    <span class="string">'long_name'</span>: <span class="number">2</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo       = <span class="number">1000</span>  <span class="comment"># comment</span></div><div class="line">long_name = <span class="number">2</span>     <span class="comment"># comment that should not be aligned</span></div><div class="line"></div><div class="line">dictionary = &#123;</div><div class="line">    <span class="string">'foo'</span>      : <span class="number">1</span>,</div><div class="line">    <span class="string">'long_name'</span>: <span class="number">2</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Shebang-Line"><a href="#Shebang-Line" class="headerlink" title="Shebang Line"></a>Shebang Line</h2><pre><code>大多数的`.py`文件都不需要`#!`行，仅在main文件的第一行使用`#!/usr/bin/python`，版本号2/3后缀是可选的。</code></pre><p><code>#!</code>行被kernel用于查找Python解释器，但是在import module的时候被忽略，所以仅当文件被直接运行的时候才需要。</p><h2 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h2><pre><code>确保正确地使用各种不同形式的注释：module/function/method/inline.</code></pre><ul><li>Doc Strings</li></ul><p>对于<strong>doc strings</strong>，建议总是使用三个双引号(<code>&quot;&quot;&quot;</code>)形式：与<code>&quot;&quot;&quot;</code>同一行是注释的概述，然后空一行，与<code>&quot;&quot;&quot;</code>缩进相同的位置开始是注释的详细说明。</p><ul><li>Modules</li></ul><p>每一个文件都应该包含合适的<code>licence</code>引用信息（比如Apache 2.0, BSD, LGPL, GPL）。</p><ul><li>Functions and Methods</li></ul><p>function必须包含docstring，除非：1. 不被外部使用；2. 非常短；3. 非常明显；</p><p>docstring中应该包含调用function的所有信息，而不需要阅读function的代码。docstring应该描述调用函数的语法，而不是函数的实现。对于复杂代码实现，代码旁的注释比docstring更合适。</p><p>function的docstring分为不同的section：<code>Args</code>, <code>Returns</code>, <code>Raises</code>，section名后面使用冒号，section描述缩进显示。</p><p><code>Args</code>: 依次列出参数名，后跟一个冒号和空格，参数的描述应该包含需要的类型和参数的含义；参数名之间缩进对齐。如果函数接收可变参数列表(<em>foo)，或任意关键字(**bar)，应该以</em>foo和**bar列出。</p><p><code>Returns</code>: （对于generator，是<code>Yields</code>），返回值的含义，如果返回None，则该section可以省略。</p><p><code>Raises</code>: 列出所有的异常；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_bigtable_rows</span><span class="params">(big_table, keys, other_silly_variable=None)</span>:</span></div><div class="line">    <span class="string">"""Fetches rows from a Bigtable.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    Retrieves rows pertaining to the given keys from the Table instance</span></div><div class="line"><span class="string">    represented by big_table.  Silly things may happen if</span></div><div class="line"><span class="string">    other_silly_variable is not None.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    Args:</span></div><div class="line"><span class="string">        big_table: An open Bigtable Table instance.</span></div><div class="line"><span class="string">        keys: A sequence of strings representing the key of each table row</span></div><div class="line"><span class="string">            to fetch.</span></div><div class="line"><span class="string">        other_silly_variable: Another optional variable, that has a much</span></div><div class="line"><span class="string">            longer name than the other args, and which does nothing.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">        A dict mapping keys to the corresponding table row data</span></div><div class="line"><span class="string">        fetched. Each row is represented as a tuple of strings. For</span></div><div class="line"><span class="string">        example:</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        &#123;'Serak': ('Rigel VII', 'Preparer'),</span></div><div class="line"><span class="string">            'Zim': ('Irk', 'Invader'),</span></div><div class="line"><span class="string">            'Lrrr': ('Omicron Persei 8', 'Emperor')&#125;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        If a key from the keys argument is missing from the dictionary,</span></div><div class="line"><span class="string">        then that row was not found in the table.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    Raises:</span></div><div class="line"><span class="string">        IOError: An error occurred accessing the bigtable.Table object.</span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure><ul><li>Classes</li></ul><p>docstring应该位于class的定义下面，如果class包含public的属性，使用<code>Attributes</code>依次列出，格式和函数参数相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""Summary of class here.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    Longer class information....</span></div><div class="line"><span class="string">    Longer class information....</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    Attributes:</span></div><div class="line"><span class="string">        likes_spam: A boolean indicating if we like SPAM or not.</span></div><div class="line"><span class="string">        eggs: An integer count of the eggs we have laid.</span></div><div class="line"><span class="string">    """</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, likes_spam=False)</span>:</span></div><div class="line">        <span class="string">"""Inits SampleClass with blah."""</span></div><div class="line">        self.likes_spam = likes_spam</div><div class="line">        self.eggs = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_method</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Performs operation blah."""</span></div></pre></td></tr></table></figure><ul><li>Block and Inline Comments</li></ul><p>对于复杂的逻辑，注释应该在逻辑的上面单独说明，对于简单但不明显的逻辑，注释放在代码的行末，但是与代码至少有2个空格的间距。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># We use a weighted dictionary search to find out where i is in</span></div><div class="line"><span class="comment"># the array.  We extrapolate position based on the largest num</span></div><div class="line"><span class="comment"># in the array and the array size and then do binary search to</span></div><div class="line"><span class="comment"># get the exact number.</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> i &amp; (i<span class="number">-1</span>) == <span class="number">0</span>:        <span class="comment"># true iff i is a power of 2</span></div></pre></td></tr></table></figure><p>永远不要试图描述你的代码。要假设阅读代码的人比你更懂Python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># BAD COMMENT: Now go through the b array and make sure whenever i occurs</span></div><div class="line"><span class="comment"># the next element is i+1</span></div></pre></td></tr></table></figure><h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><pre><code>如果class没有继承别的class，则显式继承`object`，嵌套的class也是如此。</code></pre><p>继承<code>object</code>可以使<strong>properties</strong>正常工作，同时也避免了与Python 3的<code>new style class</code>的不兼容。而且，继承<code>object</code>，预定义了很多默认的属性和method，如<code>__new__, __init__, __delattr__, __getattribute__, __setattr__, __hash__, __repr__, __str__</code>。</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span><span class="params">(object)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span><span class="params">(object)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span><span class="params">(ParentClass)</span>:</span></div><div class="line"><span class="string">"""Explicitly inherits from another class already."""</span></div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span>:</span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span>:</span></div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure><h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><pre><code>使用`format()`或`%`格式化字符串，即使所有的参数都是string。</code></pre><p>Yes:    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = a + b</div><div class="line">x = <span class="string">'%s, %s!'</span> % (imperative, expletive)</div><div class="line">x = <span class="string">'&#123;&#125;, &#123;&#125;!'</span>.format(imperative, expletive)</div><div class="line">x = <span class="string">'name: %s; score: %d'</span> % (name, n)</div><div class="line">x = <span class="string">'name: &#123;&#125;; score: &#123;&#125;'</span>.format(name, n)</div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = <span class="string">'%s%s'</span> % (a, b)  <span class="comment"># use + in this case</span></div><div class="line">x = <span class="string">'&#123;&#125;&#123;&#125;'</span>.format(a, b)  <span class="comment"># use + in this case</span></div><div class="line">x = imperative + <span class="string">', '</span> + expletive + <span class="string">'!'</span></div><div class="line">x = <span class="string">'name: '</span> + name + <span class="string">'; score: '</span> + str(n)</div></pre></td></tr></table></figure><p>不要使用<code>+</code>和<code>+=</code>在循环中拼接字符串。因为字符串是不可变的，这样会创建很多不必要的临时对象，导致运行时间是乘方级的，而不是线性的。更好地做法应该是，循环将各个字串放到list中，循环结束后通过<code>&#39;&#39;.join()</code>连接：</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">items = [<span class="string">'&lt;table&gt;'</span>]</div><div class="line"><span class="keyword">for</span> last_name, first_name <span class="keyword">in</span> employee_list:</div><div class="line">    items.append(<span class="string">'&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;'</span> % (last_name, first_name))</div><div class="line">    items.append(<span class="string">'&lt;/table&gt;'</span>)</div><div class="line">employee_table = <span class="string">''</span>.join(items)</div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">employee_table = <span class="string">'&lt;table&gt;'</span></div><div class="line"><span class="keyword">for</span> last_name, first_name <span class="keyword">in</span> employee_list:</div><div class="line">    employee_table += <span class="string">'&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;'</span> % (last_name, first_name)</div><div class="line">employee_table += <span class="string">'&lt;/table&gt;'</span></div></pre></td></tr></table></figure><p>在同一个文件中，对于字符串引号的使用要保持一致。使用<code>&#39;&#39;</code>或<code>&quot;&quot;</code>都可以，保持一致即可。两者可以同时使用，避免通过<code>\</code>转义。</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Python(<span class="string">'Why are you hiding your eyes?'</span>)</div><div class="line">Gollum(<span class="string">"I'm scared of lint errors."</span>)</div><div class="line">Narrator(<span class="string">'"Good!" thought a happy Python reviewer.'</span>)</div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Python(<span class="string">"Why are you hiding your eyes?"</span>)</div><div class="line">Gollum(<span class="string">'The lint. It burns. It burns us.'</span>)</div><div class="line">Gollum(<span class="string">"Always the great lint. Watching. Watching."</span>)</div></pre></td></tr></table></figure><p>如果string占多行，建议使用<code>&quot;&quot;&quot;</code>，而不是<code>&#39;&#39;&#39;</code>。<br>当且仅当字符串使用<code>&#39;&#39;</code>表示，多行字符串可以使用<code>&#39;&#39;&#39;</code>表示。<br>docstring总是使用<code>&quot;&quot;&quot;</code>，无论什么情况下。<br>通常，对于多行字符串使用隐式连接(<code>()</code>)更清晰易读：</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> (<span class="string">"This is much nicer.\n"</span></div><div class="line">        <span class="string">"Do it this way.\n"</span>)</div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">print</span> <span class="string">"""This is pretty ugly.</span></div><div class="line"><span class="string">Don't do this.</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure><h2 id="Files-and-Sockets"><a href="#Files-and-Sockets" class="headerlink" title="Files and Sockets"></a>Files and Sockets</h2><pre><code>使用完之后，要显式关闭file和socket。</code></pre><p>没有合理地关闭file或socket会带来很多问题：</p><ul><li>会消耗很多系统资源，比如文件描述符。如果这类的对象很多，可能会耗尽系统资源。</li><li>file处于未关闭状态，可能会导致其它的操作不可用，比如移动或删除。</li><li>被共享的file和socket，可能被意外地读写，如果被显式关闭，则读写会立即产生异常。</li></ul><p>当file对象被销毁的时候，file和socket会被自动关闭，但是将file对象的存活期与其状态绑定并不是好的实践：</p><ul><li>无法保证runtime一定会执行file对象的析构函数。</li><li>对file对象意外的引用可能会延长其存活期。</li></ul><p>推荐使用<code>with</code>语句操作file：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">"hello.txt"</span>) <span class="keyword">as</span> hello_file:</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> hello_file:</div><div class="line">        <span class="keyword">print</span> line</div></pre></td></tr></table></figure><p>对于不支持<code>with</code>的类似对象，可以使用<code>contextlib.closing()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> contextlib</div><div class="line"></div><div class="line"><span class="keyword">with</span> contextlib.closing(urllib.urlopen(<span class="string">"http://www.python.org/"</span>)) <span class="keyword">as</span></div><div class="line">    front_page:</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> front_page:</div><div class="line">        <span class="keyword">print</span> line</div></pre></td></tr></table></figure><h2 id="TODO-Comments"><a href="#TODO-Comments" class="headerlink" title="TODO Comments"></a>TODO Comments</h2><pre><code>`TODO`注释用于临时的、短期的或不够优化的解决方法。</code></pre><p><code>TODO</code>的格式：TODO大写，后跟的小括号内是用户名/邮箱等，表示应该关注该TODO的人，接下来的冒号是可选的，后面的注<br>释表示TODO的内容。<br>TODO的用户并不一定是fix这个问题的人，所以这里的用户几乎都是自己。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># TODO(kl@gmail.com): Use a "*" here for string repetition.</span></div><div class="line"><span class="comment"># TODO(Zeke) Change this to use relations.</span></div></pre></td></tr></table></figure><p>如果<code>TODO</code>表示的是“在将来的某个时间点修复”，则务必包含具体的日期(<code>2009年11月前修复</code>)或事件<br>(<code>当所有的客户端都可以处理XML结果时删除这段代码</code>)。</p><h2 id="Imports-formatting"><a href="#Imports-formatting" class="headerlink" title="Imports formatting"></a>Imports formatting</h2><pre><code>import语句应该独占一行。</code></pre><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> sys</div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os, sys</div></pre></td></tr></table></figure><p>import总是位于文件的顶部，在module的注释和docstring的后面，而在module的全局变量和常量的前面。<br>import应该根据通用性进行分组：</p><ul><li>import标准库</li><li>import第三方库</li><li>import应用特定的库</li></ul><p>在每一个分组中，import应该根据module的全包名按照字母序排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> foo</div><div class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</div><div class="line"><span class="keyword">from</span> foo.bar <span class="keyword">import</span> baz</div><div class="line"><span class="keyword">from</span> foo.bar <span class="keyword">import</span> Quux</div><div class="line"><span class="keyword">from</span> Foob <span class="keyword">import</span> ar</div></pre></td></tr></table></figure><h2 id="Statements"><a href="#Statements" class="headerlink" title="Statements"></a>Statements</h2><pre><code>通常，一行仅允许一条语句。</code></pre><p>当if没有else分支，且一行可以容纳if的结果语句时，可以将if的结果语句和if的判断语句写在同一行。<br>不能将<code>try/except</code>的语句放在同一行：</p><p>Yes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> foo: bar(foo)</div></pre></td></tr></table></figure><p>No:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> foo: bar(foo)</div><div class="line"><span class="keyword">else</span>:   baz(foo)</div><div class="line"></div><div class="line"><span class="keyword">try</span>:               bar(foo)</div><div class="line"><span class="keyword">except</span> ValueError: baz(foo)</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    bar(foo)</div><div class="line"><span class="keyword">except</span> ValueError: baz(foo)</div></pre></td></tr></table></figure><h2 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h2><pre><code>命名规范：module_name, package_name, ClassName, method_name, ExceptionName,function_name, GLOBAL_CONSTANT_NAME, global_var_name, instance_var_name,function_parameter_name, local_var_name.</code></pre><p>避免使用的命名：</p><ul><li>除了计数(counter)和迭代(iterator)，不要使用单字符变量名。</li><li>不要在package/module名中使用连字符(-)。</li><li>不要使用双下划线开头和双下划线结尾的变量(<strong>double_leading_and_trailing</strong>)。</li></ul><p>命名规范：</p><ul><li><strong>Internal</strong>表示module内部的，或者class的<code>private</code>或<code>protected</code>。</li><li>以<code>_</code>开头表示module内部的变量或函数(不包含在<code>import * from</code>)，使用<code>__</code>开头表示class的private变量或函数。</li><li>将相关的class和顶层的function放在一个module里。与Java不同的是，一个module中可以包含多个class。</li><li>class使用首字母大写(CapWord)的命名方式，而module名使用小写和下划线(lower_with_uder.py)形式。</li></ul><p>Python之父Guido推荐的命名规范：</p><table><thead><tr><th style="text-align:center">Type</th><th style="text-align:center">Public</th><th style="text-align:center">Internal</th></tr></thead><tbody><tr><td style="text-align:center">Packages</td><td style="text-align:center">lower_with_under</td></tr><tr><td style="text-align:center">Modules</td><td style="text-align:center">lower_with_under</td><td style="text-align:center">_lower_with_under</td></tr><tr><td style="text-align:center">Classes</td><td style="text-align:center">CapWords</td><td style="text-align:center">_CapWords</td></tr><tr><td style="text-align:center">Exceptions</td><td style="text-align:center">CapWords</td></tr><tr><td style="text-align:center">Functions</td><td style="text-align:center">lower_with_under()</td><td style="text-align:center">_lower_with_under()</td></tr><tr><td style="text-align:center">Global/Class Constants</td><td style="text-align:center">CAPS_WITH_UNDER</td><td style="text-align:center">_CAPS_WITH_UNDER</td></tr><tr><td style="text-align:center">Global/Class Variables</td><td style="text-align:center">lower_with_under</td><td style="text-align:center">_lower_with_under</td></tr><tr><td style="text-align:center">Instance Variables</td><td style="text-align:center">lower_with_under</td><td style="text-align:center">_lower_with_under (protected) or __lower_with_under (private)</td></tr><tr><td style="text-align:center">Method Names</td><td style="text-align:center">lower_with_under()</td><td style="text-align:center">_lower_with_under() (protected) or __lower_with_under() (private)</td></tr><tr><td style="text-align:center">Function/Method Parameters</td><td style="text-align:center">lower_with_under</td></tr><tr><td style="text-align:center">Local Variables</td><td style="text-align:center">lower_with_under</td></tr></tbody></table><h2 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h2><pre><code>即使是脚本文件，也应该是可以被其它文件import的，因此在import时，不要产生副作用，即不要执行脚本的主功能。主功能应该被放在`main()`函数里。</code></pre><p><code>pydoc</code>和单元测试都需要import文件，所以文件中应该总是添加<code>if __name__ == &#39;__main__&#39;</code>确保当module被import的时候，不会执行其主功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    ...</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure><p>在module被import的时候，所有顶层(top-level)的代码都会被执行。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://google.github.io/styleguide/pyguide.html" target="_blank" rel="external">Google Python Style Guide</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-Language-Rules&quot;&gt;&lt;a href=&quot;#Python-Language-Rules&quot; class=&quot;headerlink&quot; title=&quot;Python Language Rules&quot;&gt;&lt;/a&gt;Python Language Rules&lt;/h1&gt;&lt;h2 id=&quot;Lint&quot;&gt;&lt;a href=&quot;#Lint&quot; class=&quot;headerlink&quot; title=&quot;Lint&quot;&gt;&lt;/a&gt;Lint&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;使用`pylint`检查代码的bug和编码规范等问题。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;pylint&lt;/code&gt;可以检测一些常见的错误，比如拼写错误、用&lt;code&gt;var&lt;/code&gt;声明变量等，但是&lt;code&gt;pylint&lt;/code&gt;并不完全准确，经常会有一些误报的warning，这些warning可以忽略。&lt;/p&gt;
&lt;h2 id=&quot;Imports&quot;&gt;&lt;a href=&quot;#Imports&quot; class=&quot;headerlink&quot; title=&quot;Imports&quot;&gt;&lt;/a&gt;Imports&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;`import`仅用于package和module。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;import x&lt;/code&gt;: import一个package或module；&lt;br&gt;&lt;code&gt;from x import y&lt;/code&gt;: x是package名，y是不带前缀的module名；&lt;br&gt;&lt;code&gt;from x import y as z&lt;/code&gt;: 如果有两个module的名称都是y，或者y的名字比较长时，使用这种形式；&lt;/p&gt;
&lt;p&gt;在import中不要使用相对名称，应该使用package的全名。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; sound.effects &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; echo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;echo.EchoFilter(input, output, delay=&lt;span class=&quot;number&quot;&gt;0.7&lt;/span&gt;, atten=&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Packages&quot;&gt;&lt;a href=&quot;#Packages&quot; class=&quot;headerlink&quot; title=&quot;Packages&quot;&gt;&lt;/a&gt;Packages&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;在import一个module的时候，使用module的全路径名。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以避免module名冲突。方便module的查找。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Reference in code with complete name.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sound.effects.echo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Reference in code with just module name (preferred).&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; sound.effects &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; echo&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Exceptions&quot;&gt;&lt;a href=&quot;#Exceptions&quot; class=&quot;headerlink&quot; title=&quot;Exceptions&quot;&gt;&lt;/a&gt;Exceptions&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Exception可以使用，但是必须谨慎。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用Exception，需遵循以下原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用&lt;code&gt;raise MyException(&amp;#39;Error message&amp;#39;)&lt;/code&gt;或&lt;code&gt;raise MyException&lt;/code&gt;，不要使用两个参数的形式(&lt;code&gt;raise MyException, &amp;#39;Error message&amp;#39;&lt;/code&gt;)，也不要使用过时的String形式(&lt;code&gt;raise &amp;#39;Error message&amp;#39;&lt;/code&gt;)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;module或package应该定义自己的exception基类，该基类应该继承&lt;code&gt;Exception&lt;/code&gt;类。&lt;br&gt;例如：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Exception)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;不要使用捕获所有异常(catch-all)的形式，如&lt;code&gt;except:&lt;/code&gt;, 或&lt;code&gt;except Exception:&lt;/code&gt;, 以及&lt;code&gt;except StandardError&lt;/code&gt;等，除非将异常重新抛出，或者当前处于线程的最外层。否则所有的异常（比如拼写错误、单元测试错误、Ctrl+C中断等）都会被捕获。&lt;/li&gt;
&lt;li&gt;尽量简化&lt;code&gt;try/except&lt;/code&gt;中的代码块，代码越多，发生错误的概率就越大，而真正的错误很可能被忽略了。&lt;/li&gt;
&lt;li&gt;无论是否发生Exception，使用&lt;code&gt;finally&lt;/code&gt;执行一些代码，比如关闭文件；&lt;/li&gt;
&lt;li&gt;当捕获到Exception时，使用&lt;code&gt;as&lt;/code&gt;而不是逗号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; Error&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt; Error &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; error:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Global-Variables&quot;&gt;&lt;a href=&quot;#Global-Variables&quot; class=&quot;headerlink&quot; title=&quot;Global Variables&quot;&gt;&lt;/a&gt;Global Variables&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;尽量避免使用全局变量。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当moduel被import后，module变量（全局变量）可以通过赋值修改。&lt;/p&gt;
&lt;p&gt;尽量使用class变量，而不是全局变量。以下是例外情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脚本的默认选项；&lt;/li&gt;
&lt;li&gt;module的常量，例如：&lt;code&gt;PI = 3.14159&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;通过全局变量缓存值；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Nested-Local-Inner-Classes-and-Functions&quot;&gt;&lt;a href=&quot;#Nested-Local-Inner-Classes-and-Functions&quot; class=&quot;headerlink&quot; title=&quot;Nested/Local/Inner Classes and Functions&quot;&gt;&lt;/a&gt;Nested/Local/Inner Classes and Functions&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;嵌套定义class和function是允许的
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;class可以定义在method/function/class中，function可以定义在method/function中。嵌套的函数对于上层的变量是只读的；适用于在一个作用域内定义工具类和函数。&lt;/p&gt;
&lt;h2 id=&quot;List-Comprehensions&quot;&gt;&lt;a href=&quot;#List-Comprehensions&quot; class=&quot;headerlink&quot; title=&quot;List Comprehensions&quot;&gt;&lt;/a&gt;List Comprehensions&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;适用于简单的情形
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;Yes:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;result = []&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; y &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x * y &amp;gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                result.append((x, y))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; xrange(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; y &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; xrange(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x != y:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; z &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; xrange(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; y != z:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; (x, y, z)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ((x, complicated_transform(x))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; long_generator_function(parameter)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    squares = [x * x &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    eat(jelly_bean &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; jelly_bean &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; jelly_beans&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; jelly_bean.color == &lt;span class=&quot;string&quot;&gt;&#39;black&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;No:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;result = [(x, y) &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; y &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x * y &amp;gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ((x, y, z)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; xrange(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; y &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; xrange(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x != y&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; z &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; xrange(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; y != z)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Default-Iterators-and-Operators&quot;&gt;&lt;a href=&quot;#Default-Iterators-and-Operators&quot; class=&quot;headerlink&quot; title=&quot;Default Iterators and Operators&quot;&gt;&lt;/a&gt;Default Iterators and Operators&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;如果类型支持（如list/dictionary/file)，使用默认的iterator和operator。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;容器类型，如list/dictionary定义了默认的iterator和成员测试操作符(&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;not in&lt;/code&gt;)，使用这些默认的iterator和operator，简单高效，没有额外的函数调用开销，例如：&lt;/p&gt;
&lt;p&gt;Yes:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; adict: ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; adict: ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; obj &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; alist: ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; afile: ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dict.iteritems(): ...&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;No:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; adict.keys(): ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; adict.has_key(key): ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; afile.readlines(): ...&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Generators&quot;&gt;&lt;a href=&quot;#Generators&quot; class=&quot;headerlink&quot; title=&quot;Generators&quot;&gt;&lt;/a&gt;Generators&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;在需要的时候使用generator.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码更简单，相比函数一次创建整个list，generator消耗的内存更少。&lt;/p&gt;
&lt;h2 id=&quot;Lambda-Functions&quot;&gt;&lt;a href=&quot;#Lambda-Functions&quot; class=&quot;headerlink&quot; title=&quot;Lambda Functions&quot;&gt;&lt;/a&gt;Lambda Functions&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;适用于`一行代码`的情形。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Lambda表达式就是匿名函数，一般作为&lt;code&gt;map()&lt;/code&gt;/&lt;code&gt;filter()&lt;/code&gt;等高阶函数的回调或操作符；&lt;br&gt;如果lambda表达式中的代码比较长（超过60-80字符），最好定义成函数；&lt;br&gt;常用的操作，比如乘法运算，推荐使用&lt;code&gt;operator&lt;/code&gt;模块(&lt;code&gt;operator.mul&lt;/code&gt;)，而不是lambda函数(&lt;code&gt;lambda x, y: x * y&lt;/code&gt;)。&lt;/p&gt;
&lt;h2 id=&quot;Conditional-Expressions&quot;&gt;&lt;a href=&quot;#Conditional-Expressions&quot; class=&quot;headerlink&quot; title=&quot;Conditional Expressions&quot;&gt;&lt;/a&gt;Conditional Expressions&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;适用于`一行代码`的情形。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;条件表达式就是if语句的简写形式，代码更短也更方便，但是如果表达式语句较长，则条件可能不容易定位。&lt;br&gt;适用于只有一行代码的情形，其它情况使用if语句。&lt;/p&gt;
&lt;h2 id=&quot;Default-Argument-Values&quot;&gt;&lt;a href=&quot;#Default-Argument-Values&quot; class=&quot;headerlink&quot; title=&quot;Default Argument Values&quot;&gt;&lt;/a&gt;Default Argument Values&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;大部分情况下都是可以的。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数的参数可以使用默认值，但是不要将可变对象作为函数的默认值：&lt;/p&gt;
&lt;p&gt;Yes:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a, b=None)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; b &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                b = []&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;No:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;No:  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a, b=[])&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;No:  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a, b=time.time&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# The time the module was loaded???&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;No:  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a, b=FLAGS.my_thing)&lt;/span&gt;:&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# sys.argv has not yet been parsed...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            ...&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;True-False-evaluations&quot;&gt;&lt;a href=&quot;#True-False-evaluations&quot; class=&quot;headerlink&quot; title=&quot;True/False evaluations&quot;&gt;&lt;/a&gt;True/False evaluations&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;尽量使用`隐式`的false判断。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所有含义为空的值，如&lt;code&gt;0&lt;/code&gt;/&lt;code&gt;None&lt;/code&gt;/&lt;code&gt;[]&lt;/code&gt;/&lt;code&gt;{}&lt;/code&gt;/&lt;code&gt;&amp;#39;&amp;#39;&lt;/code&gt;都是false；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;if foo:&lt;/code&gt;，而不是&lt;code&gt;if foo != []&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;不要使用&lt;code&gt;==&lt;/code&gt;或&lt;code&gt;!=&lt;/code&gt;去比较&lt;code&gt;None&lt;/code&gt;，应该用&lt;code&gt;is&lt;/code&gt;或&lt;code&gt;is not&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;不要使用&lt;code&gt;==&lt;/code&gt;去比较&lt;code&gt;False&lt;/code&gt;，应该使用&lt;code&gt;if not x:&lt;/code&gt;; 如果要区分&lt;code&gt;False&lt;/code&gt;和&lt;code&gt;None&lt;/code&gt;，使用&lt;br&gt;&lt;code&gt;if not x and x is not None:&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;对于列表类型(string/list/tuple)，空值表示false，使用&lt;code&gt;if not seq:&lt;/code&gt;或&lt;code&gt;if seq:&lt;/code&gt;，比使用&lt;code&gt;if len(seq):&lt;/code&gt;或&lt;br&gt;&lt;code&gt;if not len(seq):&lt;/code&gt;更好；&lt;/li&gt;
&lt;li&gt;注意，’0’是true；&lt;/li&gt;
&lt;li&gt;对于整数，必须额外小心，不要将&lt;code&gt;None&lt;/code&gt;当作0处理：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Yes:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; users:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;no users&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; foo == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.handle_zero()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i % &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.handle_multiple_of_ten()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;No:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(users) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;no users&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; foo &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; foo:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.handle_zero()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; i % &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.handle_multiple_of_ten()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Threading&quot;&gt;&lt;a href=&quot;#Threading&quot; class=&quot;headerlink&quot; title=&quot;Threading&quot;&gt;&lt;/a&gt;Threading&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;不要依赖内置类型的原子行(atomicity)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有一些内置类型(如dictionary)的某些操作看起来是原子性的，但是它们不可靠；&lt;br&gt;使用&lt;strong&gt;Queue&lt;/strong&gt;模块中的&lt;code&gt;Queue&lt;/code&gt;作为线程间交互的数据结构，或者使用&lt;strong&gt;threading&lt;/strong&gt;模块。&lt;/p&gt;
&lt;h1 id=&quot;Python-Style-Rules&quot;&gt;&lt;a href=&quot;#Python-Style-Rules&quot; class=&quot;headerlink&quot; title=&quot;Python Style Rules&quot;&gt;&lt;/a&gt;Python Style Rules&lt;/h1&gt;&lt;h2 id=&quot;Semicolons&quot;&gt;&lt;a href=&quot;#Semicolons&quot; class=&quot;headerlink&quot; title=&quot;Semicolons&quot;&gt;&lt;/a&gt;Semicolons&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;语句结尾不要使用分号，也不要通过分号将两条语句写在同一行上。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Line-length&quot;&gt;&lt;a href=&quot;#Line-length&quot; class=&quot;headerlink&quot; title=&quot;Line length&quot;&gt;&lt;/a&gt;Line length&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;最大行宽为80个字符，除非：1. 很长的import语句；2. 注释中的URL。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不要使用反斜线(&lt;code&gt;\&lt;/code&gt;)做行连接。&lt;br&gt;使用&lt;code&gt;(), [], {}&lt;/code&gt;的隐式连接方式，如果有必要，可以将表达式放在额外的括号中：&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="python" scheme="http://nkcoder.github.io/tags/python/"/>
    
      <category term="Google编码规范" scheme="http://nkcoder.github.io/tags/Google%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Java 8新的日期和时间API</title>
    <link href="http://nkcoder.github.io/2016/01/31/java-8-date-time-api/"/>
    <id>http://nkcoder.github.io/2016/01/31/java-8-date-time-api/</id>
    <published>2016-01-31T08:23:29.000Z</published>
    <updated>2017-09-27T14:38:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Instant-与-Duration"><a href="#1-Instant-与-Duration" class="headerlink" title="1. Instant 与 Duration"></a>1. Instant 与 Duration</h2><p>1) <code>Instant</code>表示某一个时间点的时间戳，可以类比于<code>java.uti.Date</code>。支持各种运算操作：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Instant begin = Instant.now();</div><div class="line">begin.plus(<span class="number">5</span>, ChronoUnit.SECONDS);</div><div class="line">begin.minusMillis(<span class="number">50</span>);</div><div class="line">begin.isBefore(Instant.now());</div><div class="line"></div><div class="line">begin.toEpochMilli();</div></pre></td></tr></table></figure></code></pre><a id="more"></a><p>2) <code>Duration</code>表示<code>Instant</code>之间的时间差，可以用来统计任务的执行时间，也支持各种运算操作，比如：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Instant begin = Instant.now();</div><div class="line"><span class="comment">// do some work</span></div><div class="line">Instant end = Instant.now();</div><div class="line">Duration elapsed = Duration.between(begin, end);</div><div class="line">elapsed.toMillis()</div><div class="line"></div><div class="line">elapsed.dividedBy(<span class="number">10</span>).minus(Duration.ofMillis(<span class="number">10</span>)).isNegative();</div><div class="line">elapsed.isZero();</div><div class="line">elapsed.plusHours(<span class="number">3</span>);</div></pre></td></tr></table></figure></code></pre><h2 id="2-LocalDate-与-Period"><a href="#2-LocalDate-与-Period" class="headerlink" title="2. LocalDate 与 Period"></a>2. LocalDate 与 Period</h2><p>1) <code>LocalDate</code>用于表示日期，与时区(TimeZone)无关。</p><p>创建<code>LocalDate</code>：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LocalDate now = LocalDate.now();</div><div class="line">LocalDate today = LocalDate.of(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">31</span>);</div><div class="line">LocalDate today2 = LocalDate.of(<span class="number">2016</span>, Month.JANUARY, <span class="number">31</span>);   <span class="comment">// JANUARY = 1, ..., DECEMBER = 12</span></div></pre></td></tr></table></figure></code></pre><p>支持的操作：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">today2.getDayOfWeek().getValue();   <span class="comment">// Monday = 1, ..., Sunday = 7</span></div><div class="line">LocalDate dayOfYear = Year.now().atDay(<span class="number">220</span>);</div><div class="line">YearMonth april = Year.of(<span class="number">2016</span>).atMonth(Month.APRIL);</div></pre></td></tr></table></figure></code></pre><p>注意，有些操作得到的日期可能是不存在的，比如<code>2016-01-31</code>增加1个月后为<code>2016-02-31</code>，该日期是不存在的，返回值为该月的最后一天，即<code>2016-02-29</code>:</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LocalDate nextMonth = LocalDate.of(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">31</span>).plusMonths(<span class="number">1</span>);  <span class="comment">// 2016-02-29</span></div></pre></td></tr></table></figure></code></pre><p>2) <code>Period</code>用来表示两个<code>LocalDate</code>之间的时间差，支持各种运算操作：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LocalDate fiveDaysLater = LocalDate.now().plusDays(<span class="number">5</span>);</div><div class="line">Period period = LocalDate.now().until(fiveDaysLater).plusMonths(<span class="number">2</span>);</div><div class="line">period.isNegative();</div></pre></td></tr></table></figure></code></pre><p>3) <code>TemporalAdjusters</code>用于表示<strong>某个月第一天、下个周一</strong>等日期：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LocalDate.now().with(TemporalAdjusters.firstDayOfMonth());</div><div class="line">   LocalDate.now().with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY));</div><div class="line">   LocalDate.now().with(TemporalAdjusters.nextOrSame(DayOfWeek.MONDAY));</div></pre></td></tr></table></figure></code></pre><h2 id="3-LocalTime"><a href="#3-LocalTime" class="headerlink" title="3. LocalTime"></a>3. LocalTime</h2><p>1) <code>LocalTime</code>表示时间，没有日期，与时区(TimeZone)无关：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalTime.now().isBefore(LocalTime.of(<span class="number">16</span>, <span class="number">2</span>, <span class="number">1</span>));</div><div class="line">   LocalTime.now().plusHours(<span class="number">2</span>).getHour();</div></pre></td></tr></table></figure></code></pre><p>2) <code>LocalDateTime</code>表示日期和时间，适用于时区固定不变的场合(<code>LocalDateTime</code>使用系统默认的时区)，如果需要根据时区调整日期和时间，应该使用<code>ZonedDateTime</code>:</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LocalDateTime.now().plusDays(<span class="number">3</span>).minusHours(<span class="number">5</span>).isAfter(LocalDateTime.of(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>));</div></pre></td></tr></table></figure></code></pre><h2 id="4-ZonedDateTime"><a href="#4-ZonedDateTime" class="headerlink" title="4. ZonedDateTime"></a>4. ZonedDateTime</h2><p>1) <code>ZonedDateTime</code>表示带时区的日期和时间，支持的操作与<code>LocalDateTime</code>非常类似：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Set&lt;String&gt; zones = ZoneId.getAvailableZoneIds();</div><div class="line">ZonedDateTime.now(ZoneId.of(<span class="string">"Asia/Shanghai"</span>)).plusMonths(<span class="number">1</span>).minusHours(<span class="number">3</span>)</div><div class="line">       .isBefore(ZonedDateTime.now());</div></pre></td></tr></table></figure></code></pre><p>2) <code>ZonedDateTime</code>与<code>LocalDateTime</code>、<code>Instant</code>之间可以相互转换：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ZonedDateTime nowOfShanghai = LocalDateTime.now().atZone(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</div><div class="line">ZonedDateTime.now(ZoneId.of(<span class="string">"UTC"</span>)).toLocalDate();</div><div class="line">ZonedDateTime nowOfShanghai2 = Instant.now().atZone(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</div><div class="line">ZonedDateTime.of(LocalDate.now(), LocalTime.now(), ZoneId.of(<span class="string">"UTC"</span>)).toInstant();</div></pre></td></tr></table></figure></code></pre><h2 id="5-Formatting-与-Parsing"><a href="#5-Formatting-与-Parsing" class="headerlink" title="5. Formatting 与 Parsing"></a>5. Formatting 与 Parsing</h2><p>1) 要格式化或者解析日期时，需要使用到<code>DateTimeFormatter</code>，用来定义日期或时间的格式：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 2016-01-31T15:39:31.481</span></div><div class="line">DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now());</div><div class="line"><span class="comment">// Jan 31, 2016 3:50:04 PM</span></div><div class="line">DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(LocalDateTime.now());</div><div class="line"><span class="comment">// Sun 2016-01-31 15:50:04</span></div><div class="line">DateTimeFormatter.ofPattern(<span class="string">"E yyyy-MM-dd HH:mm:ss"</span>).format(LocalDateTime.now());</div><div class="line"></div><div class="line">LocalDateTime.parse(<span class="string">"2016-01-31 15:51:00-0400"</span>, </div><div class="line">       DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ssxx"</span>));</div><div class="line">   LocalDate.parse(<span class="string">"2016-01-31"</span>);</div></pre></td></tr></table></figure></code></pre><p>2) 日期和时间格式化的常见格式：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">年       yy: 16      yyyy: 2016</div><div class="line">月       M: 1        MM: 01</div><div class="line">日       d: 3        dd: 03</div><div class="line">周       e: 3        E:Web</div><div class="line">时       H: 9        HH: 09</div><div class="line">钟       mm: 02</div><div class="line">秒       ss: 00</div><div class="line">纳秒      nnnnnn:000000</div><div class="line">时区偏移    x: -04     xx:-0400</div></pre></td></tr></table></figure></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.amazon.cn/Java-SE8-for-the-Really-Impatient-A-Short-Course-on-the-Basics-Horstmann-Cay-S/dp/0321927761/ref=sr_1_2" target="_blank" rel="external">Java SE8 for the Really Impatient</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Instant-与-Duration&quot;&gt;&lt;a href=&quot;#1-Instant-与-Duration&quot; class=&quot;headerlink&quot; title=&quot;1. Instant 与 Duration&quot;&gt;&lt;/a&gt;1. Instant 与 Duration&lt;/h2&gt;&lt;p&gt;1) &lt;code&gt;Instant&lt;/code&gt;表示某一个时间点的时间戳，可以类比于&lt;code&gt;java.uti.Date&lt;/code&gt;。支持各种运算操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Instant begin = Instant.now();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;begin.plus(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, ChronoUnit.SECONDS);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;begin.minusMillis(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;begin.isBefore(Instant.now());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;begin.toEpochMilli();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="Java" scheme="http://nkcoder.github.io/tags/Java/"/>
    
      <category term="Java8" scheme="http://nkcoder.github.io/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>使用Java 8中的Stream</title>
    <link href="http://nkcoder.github.io/2016/01/24/java-8-stream-api/"/>
    <id>http://nkcoder.github.io/2016/01/24/java-8-stream-api/</id>
    <published>2016-01-24T12:45:15.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文链接为：<a href="http://nkcoder.github.io/2016/01/24/java-8-stream-api/">http://nkcoder.github.io/2016/01/24/java-8-stream-api/</a>  ，转载请注明出处，谢谢！</p></blockquote><p>Stream是Java 8 提供的高效操作集合类（Collection）数据的API。</p><h2 id="1-从Iterator到Stream"><a href="#1-从Iterator到Stream" class="headerlink" title="1. 从Iterator到Stream"></a>1. 从Iterator到Stream</h2><p>有一个字符串的list，要统计其中长度大于7的字符串的数量，用迭代来实现：</p><pre><code>List&lt;String&gt; wordList = Arrays.asList(&quot;regular&quot;, &quot;expression&quot;, &quot;specified&quot;, &quot;as&quot;, &quot;a&quot;,    &quot;string&quot;, &quot;must&quot;);int countByIterator = 0;for (String word: wordList) {    if (word.length() &gt; 7) {        countByIterator++;    }}</code></pre><a id="more"></a><p>用Stream实现：</p><pre><code>long countByStream = wordList.stream().filter(w -&gt; w.length() &gt; 7).count();</code></pre><p>显然，用stream实现更简洁，不仅如此，stream很容易实现并发操作，比如：</p><pre><code>long countByParallelStream = wordList.parallelStream().    filter(w -&gt; w.length() &gt; 7).count();</code></pre><p>stream遵循的原则是：告诉我做什么，不用管我怎么做。比如上例：告诉stream通过多线程统计字符串长度，至于以什么顺序、在哪个线程中执行，由stream来负责；而在迭代实现中，由于计算的方式已确定，很难优化了。</p><p>Stream和Collection的区别主要有：</p><ol><li>stream本身并不存储数据，数据是存储在对应的collection里，或者在需要的时候才生成的；</li><li>stream不会修改数据源，总是返回新的stream；</li><li>stream的操作是懒执行(lazy)的：仅当最终的结果需要的时候才会执行，比如上面的例子中，结果仅需要前3个长度大于7的字符串，那么在找到前3个长度符合要求的字符串后，<code>filter()</code>将停止执行；</li></ol><p>使用stream的步骤如下：</p><ol><li>创建stream；</li><li>通过一个或多个中间操作(intermediate operations)将初始stream转换为另一个stream；</li><li>通过中止操作(terminal operation)获取结果；该操作触发之前的懒操作的执行，中止操作后，该stream关闭，不能再<br>使用了；</li></ol><p>在上面的例子中，<code>wordList.stream()</code>和<code>wordList.parallelStream()</code>是创建stream，<code>filter()</code>是中间操作，过滤后生成一个新的stream，<code>count()</code>是中止操作，获取结果。</p><h2 id="2-创建Stream的方式"><a href="#2-创建Stream的方式" class="headerlink" title="2. 创建Stream的方式"></a>2. 创建Stream的方式</h2><p>1) 从array或list创建stream：</p><pre><code>Stream&lt;Integer&gt; integerStream = Stream.of(10, 20, 30, 40);String[] cityArr = {&quot;Beijing&quot;, &quot;Shanghai&quot;, &quot;Chengdu&quot;};Stream&lt;String&gt; cityStream = Stream.of(cityArr);Stream&lt;String&gt; nameStream = Arrays.asList(&quot;Daniel&quot;, &quot;Peter&quot;, &quot;Kevin&quot;).    stream();Stream&lt;String&gt; cityStream2 = Arrays.stream(cityArr, 0, 1);Stream&lt;String&gt; emptyStream = Stream.empty();</code></pre><p>2) 通过<code>generate</code>和<code>iterate</code>创建无穷stream：</p><pre><code>Stream&lt;String&gt; echos = Stream.generate(() -&gt; &quot;echo&quot;);Stream&lt;Integer&gt; integers = Stream.iterate(0, num -&gt; num + 1);</code></pre><p>3) 通过其它API创建stream：</p><pre><code>Stream&lt;String&gt; lines = Files.lines(Paths.get(&quot;test.txt&quot;))String content = &quot;AXDBDGXC&quot;;Stream&lt;String&gt; contentStream = Pattern.compile(&quot;[ABC]{1,3}&quot;).    splitAsStream(content);</code></pre><h2 id="3-Stream转换"><a href="#3-Stream转换" class="headerlink" title="3. Stream转换"></a>3. Stream转换</h2><p>1) <code>filter()</code>用于过滤，即使原stream中满足条件的元素构成新的stream：</p><pre><code>List&lt;String&gt; langList = Arrays.asList(&quot;Java&quot;, &quot;Python&quot;, &quot;Swift&quot;, &quot;HTML&quot;);Stream&lt;String&gt; filterStream = langList.stream().filter(lang -&gt; lang.equalsIgnoreCase(&quot;java&quot;));</code></pre><p>2) <code>map()</code>用于映射，遍历原stream中的元素，转换后构成新的stream：</p><pre><code>List&lt;String&gt; langList = Arrays.asList(&quot;Java&quot;, &quot;Python&quot;, &quot;Swift&quot;, &quot;HTML&quot;);Stream&lt;String&gt; mapStream = langList.stream().map(String::toUpperCase);</code></pre><p>3) <code>flatMap()</code>用于将<code>[[&quot;ABC&quot;, &quot;DEF&quot;], [&quot;FGH&quot;, &quot;IJK&quot;]]</code>的形式转换为<br><code>[&quot;ABC&quot;, &quot;DEF&quot;, &quot;FGH&quot;, &quot;IJK&quot;]</code>：</p><pre><code>Stream&lt;String&gt; cityStream = Stream.of(&quot;Beijing&quot;, &quot;Shanghai&quot;, &quot;Shenzhen&quot;);// [[&apos;B&apos;, &apos;e&apos;, &apos;i&apos;, &apos;j&apos;, &apos;i&apos;, &apos;n&apos;, &apos;g&apos;], [&apos;S&apos;, &apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;a&apos;, &apos;i&apos;], ...]Stream&lt;Stream&lt;Character&gt;&gt; characterStream1 = cityStream.    map(city -&gt; characterStream(city));Stream&lt;String&gt; cityStreamCopy = Stream.of(&quot;Beijing&quot;, &quot;Shanghai&quot;, &quot;Shenzhen&quot;);// [&apos;B&apos;, &apos;e&apos;, &apos;i&apos;, &apos;j&apos;, &apos;i&apos;, &apos;n&apos;, &apos;g&apos;, &apos;S&apos;, &apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;a&apos;, &apos;i&apos;, ...]Stream&lt;Character&gt; characterStreamCopy = cityStreamCopy.    flatMap(city -&gt; characterStream(city));</code></pre><blockquote><p>其中，<code>characterStream()</code>返回有参数字符串的字符构成的Stream<character>;</character></p></blockquote><p>4)  <code>limit()</code>表示限制stream中元素的数量，<code>skip()</code>表示跳过stream中前几个元素，<code>concat</code>表示将多个stream连接<br>起来，<code>peek()</code>主要用于debug时查看stream中元素的值：</p><pre><code>Stream&lt;Integer&gt; limitStream = Stream.of(18, 20, 12, 35, 89).sorted().limit(3);Stream&lt;Integer&gt; skipStream = Stream.of(18, 20, 12, 35, 89).sorted(Comparator.reverseOrder())    .skip(1);Stream&lt;Integer&gt; concatStream = Stream.concat(Stream.of(1, 2, 3), Stream.of(4, 5, 6));concatStream.peek(i -&gt; System.out.println(i)).count();</code></pre><blockquote><p><code>peek()</code>是<strong>intermediate operation</strong>，所以后面需要一个<strong>terminal operation</strong>，如<code>count()</code>才能在输出中<br>看到结果；</p></blockquote><p>5) 有状态的(stateful)转换，即元素之间有依赖关系，如<code>distinct()</code>返回由唯一元素构成的stream，<code>sorted()</code>返回排<br>序后的stream：</p><pre><code>Stream&lt;String&gt; distinctStream = Stream.of(&quot;Beijing&quot;, &quot;Tianjin&quot;, &quot;Beijing&quot;).distinct();Stream&lt;String&gt; sortedStream = Stream.of(&quot;Beijing&quot;, &quot;Shanghai&quot;, &quot;Chengdu&quot;)    .sorted(Comparator.comparing(String::length).reversed());</code></pre><h2 id="4-Stream-reduction"><a href="#4-Stream-reduction" class="headerlink" title="4. Stream reduction"></a>4. Stream reduction</h2><p><code>reduction</code>就是从stream中取出结果，是<code>terminal operation</code>，因此经过<code>reduction</code>后的stream不能再使用了。</p><h3 id="4-1-Optional"><a href="#4-1-Optional" class="headerlink" title="4.1 Optional"></a>4.1 Optional</h3><p>Optional<t>表示或者有一个T类型的对象，或者没有值；</t></p><p>1) 创建Optional对象：</p><p>直接通过Optional的类方法：<code>of()</code>/<code>empty()</code>/<code>ofNullable()</code>：</p><pre><code>Optional&lt;Integer&gt; intOpt = Optional.of(10);Optional&lt;String&gt; emptyOpt = Optional.empty();Optional&lt;Double&gt; doubleOpt = Optional.ofNullable(5.5);</code></pre><p>2) 使用Optional对象：</p><p>你当然可以这么使用：</p><pre><code>if (intOpt.isPresent()) {    intOpt.get();}</code></pre><p>但是，最好这么使用：</p><pre><code>doubleOpt.orElse(0.0);doubleOpt.orElseGet(() -&gt; 1.0);doubleOpt.orElseThrow(RuntimeException::new);List&lt;Double&gt; doubleList = new ArrayList&lt;&gt;();doubleOpt.ifPresent(doubleList::add);</code></pre><p><code>map()</code>方法与<code>ifPresent()</code>用法相同，就是多个返回值，<code>flatMap()</code>用于Optional的链式表达：</p><pre><code>Optional&lt;Boolean&gt; addOk = doubleOpt.map(doubleList::add);Optional.of(4.0).flatMap(num -&gt; Optional.ofNullable(num * 100))    .flatMap(num -&gt; Optional.ofNullable(Math.sqrt(num)));</code></pre><h3 id="4-2-简单的reduction"><a href="#4-2-简单的reduction" class="headerlink" title="4.2 简单的reduction"></a>4.2 简单的reduction</h3><p>主要包含以下操作： <code>findFirst()</code>/<code>findAny()</code>/<code>allMatch</code>/<code>anyMatch()</code>/<code>noneMatch</code>，比如：</p><pre><code>Optional&lt;String&gt; firstWord = wordStream.filter(s -&gt; s.startsWith(&quot;Y&quot;)).findFirst();Optional&lt;String&gt; anyWord = wordStream.filter(s -&gt; s.length() &gt; 3).findAny();wordStream.allMatch(s -&gt; s.length() &gt; 3);wordStream.anyMatch(s -&gt; s.length() &gt; 3);wordStream.noneMatch(s -&gt; s.length() &gt; 3);</code></pre><h3 id="4-3-reduce方法"><a href="#4-3-reduce方法" class="headerlink" title="4.3 reduce方法"></a>4.3 reduce方法</h3><p>1) <code>reduce(accumulator)</code>：参数是一个执行双目运算的<code>Functional Interface</code>，假如这个参数表示的操作为op，<br>stream中的元素为x, y, z, …，则<code>reduce()</code>执行的就是<code>x op y op z ...</code>，所以要求op这个操作具有结合性<br>(associative)，即满足：<code>(x op y) op z = x op (y op z)</code>，满足这个要求的操作主要有：求和、求积、求最大值、<br>求最小值、字符串连接、集合并集和交集等。另外，该函数的返回值是Optional的：</p><pre><code>Optional&lt;Integer&gt; sum1 = numStream.reduce((x, y) -&gt; x + y);</code></pre><p>2) <code>reduce(identity, accumulator)</code>：可以认为第一个参数为默认值，但需要满足<code>identity op x = x</code>，所以对于求<br>和操作，<code>identity</code>的值为0，对于求积操作，<code>identity</code>的值为1。返回值类型是stream元素的类型：</p><pre><code>Integer sum2 = numStream.reduce(0, Integer::sum);</code></pre><h2 id="5-collect结果"><a href="#5-collect结果" class="headerlink" title="5. collect结果"></a>5. collect结果</h2><p>1) <code>collect()</code>方法：</p><p><code>reduce()</code>和<code>collect()</code>的区别是：</p><ul><li><code>reduce()</code>的结果是一个值；</li><li><code>collect()</code>可以对stream中的元素进行各种处理后，得到stream中元素的值；</li></ul><p><code>Collectors</code>接口提供了很方便的创建<code>Collector</code>对象的工厂方法：</p><pre><code>// collect to CollectionStream.of(&quot;You&quot;, &quot;may&quot;, &quot;assume&quot;).collect(Collectors.toList());Stream.of(&quot;You&quot;, &quot;may&quot;, &quot;assume&quot;).collect(Collectors.toSet());Stream.of(&quot;You&quot;, &quot;may&quot;, &quot;assume&quot;).collect(Collectors.toCollection(TreeSet::new));// join elementStream.of(&quot;You&quot;, &quot;may&quot;, &quot;assume&quot;).collect(Collectors.joining());Stream.of(&quot;You&quot;, &quot;may&quot;, &quot;assume&quot;).collect(Collectors.joining(&quot;, &quot;));// summarize elementIntSummaryStatistics summary = Stream.of(&quot;You&quot;, &quot;may&quot;, &quot;assume&quot;)    .collect(Collectors.summarizingInt(String::length));summary.getMax();</code></pre><p>2) <code>foreach()</code>方法：</p><p><code>foreach()</code>用于遍历stream中的元素，属于<code>terminal operation</code>；<br><code>forEachOrdered()</code>是按照stream中元素的顺序遍历，也就无法利用并发的优势；</p><pre><code>Stream.of(&quot;You&quot;, &quot;may&quot;, &quot;assume&quot;, &quot;you&quot;, &quot;can&quot;, &quot;fly&quot;).parallel()    .forEach(w -&gt; System.out.println(w));Stream.of(&quot;You&quot;, &quot;may&quot;, &quot;assume&quot;, &quot;you&quot;, &quot;can&quot;, &quot;fly&quot;)    .forEachOrdered(w -&gt; System.out.println(w));</code></pre><p>3) <code>toArray()</code>方法：</p><p>得到由stream中的元素得到的数组，默认是Object[]，可以通过参数设置需要结果的类型：</p><pre><code>Object[] words1 = Stream.of(&quot;You&quot;, &quot;may&quot;, &quot;assume&quot;).toArray();String[] words2 = Stream.of(&quot;You&quot;, &quot;may&quot;, &quot;assume&quot;).toArray(String[]::new);</code></pre><p>4) <code>toMap()</code>方法：</p><p><code>toMap</code>: 将stream中的元素映射为<key, value="">的形式，两个参数分别用于生成对应的key和value的值。比如有一个字符串stream，将首字母作为key，字符串值作为value，得到一个map：</key,></p><pre><code>Stream&lt;String&gt; introStream = Stream.of(&quot;Get started with UICollectionView and the photo library&quot;.split(&quot; &quot;));Map&lt;String, String&gt; introMap =    introStream.collect(Collectors.toMap(s -&gt; s.substring(0, 1), s -&gt; s));</code></pre><p>如果一个key对应多个value，则会抛出异常，需要使用第三个参数设置如何处理冲突，比如仅使用原来的value、使用新的value，或者合并：</p><pre><code>Stream&lt;String&gt; introStream = Stream.of(&quot;Get started with UICollectionView and the photo library&quot;    .split(&quot; &quot;));Map&lt;Integer, String&gt; introMap2 = introStream.collect(Collectors.toMap(s -&gt; s.length(),    s -&gt; s, (existingValue, newValue) -&gt; existingValue));</code></pre><p>如果value是一个集合，即将key对应的所有value放到一个集合中，则需要使用第三个参数，将多个value合并：</p><pre><code>Stream&lt;String&gt; introStream3 = Stream.of(&quot;Get started with UICollectionView and the photo library&quot;    .split(&quot; &quot;));Map&lt;Integer, Set&lt;String&gt;&gt; introMap3 = introStream3.collect(Collectors.toMap(s -&gt; s.length(),        s -&gt; Collections.singleton(s), (existingValue, newValue) -&gt; {            HashSet&lt;String&gt; set = new HashSet&lt;&gt;(existingValue);            set.addAll(newValue);            return set;        }    ));introMap3.forEach((k, v) -&gt; System.out.println(k + &quot;: &quot; + v));</code></pre><p>如果value是对象自身，则使用<code>Function.identity()</code>，如：</p><pre><code>Map&lt;Integer, Person&gt; idToPerson = people.collect(Collectors    .toMap(Person::getId, Function.identity()));</code></pre><p><code>toMap()</code>默认返回的是HashMap，如果需要其它类型的map，比如TreeMap，则可以在第四个参数指定构造方法：</p><pre><code>Map&lt;Integer, String&gt; introMap2 = introStream.collect(    Collectors.toMap(s -&gt; s.length(), s -&gt; s, (existingValue, newValue)        -&gt; existingValue, TreeMap::new));</code></pre><h2 id="6-Grouping和Partitioning"><a href="#6-Grouping和Partitioning" class="headerlink" title="6. Grouping和Partitioning"></a>6. Grouping和Partitioning</h2><p>1)  <code>groupingBy()</code>表示根据某一个字段或条件进行分组，返回一个Map，其中key为分组的字段或条件，value默认为list，<code>groupingByConcurrent()</code>是其并发版本：</p><pre><code>Map&lt;String, List&lt;Locale&gt;&gt; countryToLocaleList = Stream.of(Locale.getAvailableLocales())    .collect(Collectors.groupingBy(l -&gt; l.getDisplayCountry()));</code></pre><p>2) 如果<code>groupingBy()</code>分组的依据是一个bool条件，则key的值为true/false，此时与<code>partitioningBy()</code>等价，且<br><code>partitioningBy()</code>的效率更高：</p><pre><code>// predicateMap&lt;Boolean, List&lt;Locale&gt;&gt; englishAndOtherLocales = Stream.of(Locale.getAvailableLocales())    .collect(Collectors.groupingBy(l -&gt; l.getDisplayLanguage().equalsIgnoreCase(&quot;English&quot;)));// partitioningByMap&lt;Boolean, List&lt;Locale&gt;&gt; englishAndOtherLocales2 = Stream.of(Locale.getAvailableLocales())    .collect(Collectors.partitioningBy(l -&gt; l.getDisplayLanguage().equalsIgnoreCase(&quot;English&quot;)));</code></pre><p>3) <code>groupingBy()</code>提供第二个参数，表示<code>downstream</code>，即对分组后的value作进一步的处理：</p><p>返回set，而不是list：</p><pre><code>Map&lt;String, Set&lt;Locale&gt;&gt; countryToLocaleSet = Stream.of(Locale.getAvailableLocales())          .collect(Collectors.groupingBy(l -&gt; l.getDisplayCountry(), Collectors.toSet()));</code></pre><p>返回value集合中元素的数量：</p><pre><code>Map&lt;String, Long&gt; countryToLocaleCounts = Stream.of(Locale.getAvailableLocales())          .collect(Collectors.groupingBy(l -&gt; l.getDisplayCountry(), Collectors.counting()));</code></pre><p>对value集合中的元素求和：</p><pre><code>Map&lt;String, Integer&gt; cityToPopulationSum = Stream.of(cities)        .collect(Collectors.groupingBy(City::getName, Collectors.summingInt(City::getPopulation)));</code></pre><p>对value的某一个字段求最大值，注意value是Optional的：</p><pre><code>Map&lt;String, Optional&lt;City&gt;&gt; cityToPopulationMax = Stream.of(cities)        .collect(Collectors.groupingBy(City::getName,            Collectors.maxBy(Comparator.comparing(City::getPopulation))));</code></pre><p>使用mapping对value的字段进行map处理：</p><pre><code>Map&lt;String, Optional&lt;String&gt;&gt; stateToNameMax = Stream.of(cities)    .collect(Collectors.groupingBy(City::getState, Collectors.mapping(City::getName,        Collectors.maxBy(Comparator.comparing(String::length)))));Map&lt;String, Set&lt;String&gt;&gt; stateToNameSet = Stream.of(cities).collect(Collectors.groupingBy(City::getState,    Collectors.mapping(City::getName, Collectors.toSet())));</code></pre><p>通过<code>summarizingXXX</code>获取统计结果：</p><pre><code>Map&lt;String, IntSummaryStatistics&gt; stateToPopulationSummary = Stream.of(cities)    .collect(Collectors.groupingBy(City::getState, Collectors.summarizingInt(City::getPopulation)));</code></pre><p><code>reducing()</code>可以对结果作更复杂的处理，但是<code>reducing()</code>却并不常用：</p><pre><code>Map&lt;String, String&gt; stateToNameJoining = Stream.of(cities)    .collect(Collectors.groupingBy(City::getState, Collectors.reducing(&quot;&quot;, City::getName,        (s, t) -&gt; s.length() == 0 ? t : s + &quot;, &quot; + t)));</code></pre><p>比如上例可以通过mapping达到同样的效果：</p><pre><code>Map&lt;String, String&gt; stateToNameJoining2 = Stream.of(cities)        .collect(Collectors.groupingBy(City::getState,            Collectors.mapping(City::getName, Collectors.joining(&quot;, &quot;)        )));</code></pre><h2 id="7-Primitive-Stream"><a href="#7-Primitive-Stream" class="headerlink" title="7. Primitive Stream"></a>7. Primitive Stream</h2><p><code>Stream&lt;Integer&gt;</code>对应的Primitive Stream就是<code>IntStream</code>，类似的还有<code>DoubleStream</code>和<code>LongStream</code>。</p><p>1) Primitive Stream的构造：<code>of()</code>, <code>range()</code>, <code>rangeClosed()</code>, <code>Arrays.stream()</code>:</p><pre><code>IntStream intStream = IntStream.of(10, 20, 30);IntStream zeroToNintyNine = IntStream.range(0, 100);IntStream zeroToHundred = IntStream.rangeClosed(0, 100);double[] nums = {10.0, 20.0, 30.0};DoubleStream doubleStream = Arrays.stream(nums, 0, 3);</code></pre><p>2) Object Stream与Primitive Stream之间的相互转换，通过<code>mapToXXX()</code>和<code>boxed()</code>：</p><pre><code>// map toStream&lt;String&gt; cityStream = Stream.of(&quot;Beijing&quot;, &quot;Tianjin&quot;, &quot;Chengdu&quot;);IntStream lengthStream = cityStream.mapToInt(String::length);// boxStream&lt;Integer&gt; oneToNine = IntStream.range(0, 10).boxed();</code></pre><p>3) 与Object Stream相比，Primitive Stream的特点：</p><p><code>toArray()</code>方法返回的是对应的Primitive类型：</p><pre><code>int[] intArr = intStream.toArray();</code></pre><p>自带统计类型的方法，如：<code>max()</code>, <code>average()</code>, <code>summaryStatistics()</code>:</p><pre><code>OptionalInt maxNum = intStream.max();IntSummaryStatistics intSummary = intStream.summaryStatistics();</code></pre><h2 id="8-Parallel-Stream"><a href="#8-Parallel-Stream" class="headerlink" title="8. Parallel Stream"></a>8. Parallel Stream</h2><p>1) Stream支持并发操作，但需要满足以下几点：</p><p>构造一个paralle stream，默认构造的stream是顺序执行的，调用<code>paralle()</code>构造并行的stream：</p><pre><code>IntStream scoreStream = IntStream.rangeClosed(10, 30).parallel();</code></pre><p>要执行的操作必须是可并行执行的，即并行执行的结果和顺序执行的结果是一致的，而且必须保证stream中执行的操作是线程安全的：</p><pre><code>int[] wordLength = new int[12];Stream.of(&quot;It&quot;, &quot;is&quot;, &quot;your&quot;, &quot;responsibility&quot;).parallel().forEach(s -&gt; {    if (s.length() &lt; 12) wordLength[s.length()]++;});</code></pre><p>这段程序的问题在于，多线程访问共享数组<code>wordLength</code>，是非线程安全的。解决的思路有：1）构造AtomicInteger数组；2）使用<code>groupingBy()</code>根据length统计；</p><p>2) 可以通过并行提高效率的常见场景：</p><p>使stream无序：对于<code>distinct()</code>和<code>limit()</code>等方法，如果不关心顺序，则可以使用并行：</p><pre><code>LongStream.rangeClosed(5, 10).unordered().parallel().limit(3);IntStream.of(14, 15, 15, 14, 12, 81).unordered().parallel().distinct();</code></pre><p>在<code>groupingBy()</code>的操作中，map的合并操作是比较重的，可以通过<code>groupingByConcurrent()</code>来并行处理，不过前提是parallel stream：</p><pre><code>Stream.of(cities).parallel().collect(Collectors.groupingByConcurrent(City::getState));</code></pre><p>在执行stream操作时不能修改stream对应的collection；</p><p>stream本身是不存储数据的，数据保存在对应的collection中，所以在执行stream操作的同时修改对应的collection，结果是未定义的：</p><pre><code>// okStream&lt;String&gt; wordStream = wordList.stream();wordList.add(&quot;number&quot;);wordStream.distinct().count();// ConcurrentModificationExceptionStream&lt;String&gt; wordStream = wordList.stream();wordStream.forEach(s -&gt; { if (s.length() &gt;= 6) wordList.remove(s);});</code></pre><h2 id="9-Functional-Interface"><a href="#9-Functional-Interface" class="headerlink" title="9. Functional Interface"></a>9. Functional Interface</h2><p>仅包含一个抽象方法的interface被成为<code>Functional Interface</code>，比如：<code>Predicate</code>, <code>Function</code>, <code>Consumer</code>等。<br>此时我们一般传入一个lambda表达式或<code>Method Reference</code>。</p><p>常见的<code>Functional Interface</code>有：</p><pre><code>Functional Interface     Parameter     Return Type     Description TypesSupplier&lt;T&gt;             None         T                Supplies a value of type TConsumer&lt;T&gt;             T             void            Consumes a value of type TBiConsumer&lt;T, U&gt;         T,U         void            Consumes values of types T and UPredicate&lt;T&gt;             T            boolean            A Boolean-valued functionToIntFunction&lt;T&gt;         T             int                An int-, long-, or double-valued functionToLongFunction&lt;T&gt;         T            longToDoubleFunction&lt;T&gt;     T            doubleIntFunction&lt;R&gt;             int         R                A function with argument of type int, long, or doubleLongFunction&lt;R&gt;         longDoubleFunction&lt;R&gt;         doubleFunction&lt;T, R&gt;             T             R                A function with argument of type TBiFunction&lt;T, U, R&gt;     T,U         R                A function with arguments of types T and UUnaryOperator&lt;T&gt;         T             T                A unary operator on the type TBinaryOperator&lt;T&gt;         T,T         T                A binary operator on the type T</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.amazon.cn/Java-SE8-for-the-Really-Impatient-A-Short-Course-on-the-Basics-Horstmann-Cay-S/dp/0321927761/ref=sr_1_2" target="_blank" rel="external">Java SE8 for the Really Impatient</a></li><li><a href="https://gist.github.com/nkcoder/50c115a96c4e67164580#file-java-8-stream-api-java" target="_blank" rel="external">Stream示例代码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文链接为：&lt;a href=&quot;http://nkcoder.github.io/2016/01/24/java-8-stream-api/&quot;&gt;http://nkcoder.github.io/2016/01/24/java-8-stream-api/&lt;/a&gt;  ，转载请注明出处，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Stream是Java 8 提供的高效操作集合类（Collection）数据的API。&lt;/p&gt;
&lt;h2 id=&quot;1-从Iterator到Stream&quot;&gt;&lt;a href=&quot;#1-从Iterator到Stream&quot; class=&quot;headerlink&quot; title=&quot;1. 从Iterator到Stream&quot;&gt;&lt;/a&gt;1. 从Iterator到Stream&lt;/h2&gt;&lt;p&gt;有一个字符串的list，要统计其中长度大于7的字符串的数量，用迭代来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; wordList = Arrays.asList(&amp;quot;regular&amp;quot;, &amp;quot;expression&amp;quot;, &amp;quot;specified&amp;quot;, &amp;quot;as&amp;quot;, &amp;quot;a&amp;quot;,
    &amp;quot;string&amp;quot;, &amp;quot;must&amp;quot;);

int countByIterator = 0;
for (String word: wordList) {
    if (word.length() &amp;gt; 7) {
        countByIterator++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="java" scheme="http://nkcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 Lambda表达式入门</title>
    <link href="http://nkcoder.github.io/2016/01/16/java-8-lambda-expression-guide/"/>
    <id>http://nkcoder.github.io/2016/01/16/java-8-lambda-expression-guide/</id>
    <published>2016-01-16T10:03:04.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文链接为：<a href="http://nkcoder.github.io/2016/01/16/java-8-lambda-expression-guide/">http://nkcoder.github.io/2016/01/16/java-8-lambda-expression-guide/</a>  ，转载请注明出处，谢谢！</p></blockquote><h2 id="1-1-为什么使用Lambda表达式"><a href="#1-1-为什么使用Lambda表达式" class="headerlink" title="1.1 为什么使用Lambda表达式"></a>1.1 为什么使用Lambda表达式</h2><p>先看几个例子：</p><p>第一个例子，在一个独立的线程中执行某项任务，我们通常这么实现：</p><pre><code>class Worker implements Runnable {    public void run() {        for (int i = 0; i &lt; 100; i++)            doWork();    }    ...}Worker w = new Worker();new Thread(w).start();</code></pre><a id="more"></a><p>第二个例子，自定义字符串比较的方法（通过字符串长度），一般这么做：</p><pre><code>class LengthComparator implements Comparator&lt;String&gt; {    public int compare(String first, String second) {        return Integer.compare(first.length(), second.length());    }}Arrays.sort(strings, new LengthComparator());</code></pre><p>第三个例子，在JavaFX中，给一个button添加一个callback：</p><pre><code>button.setOnAction(new EventHandler&lt;ActionEvent&gt;() {    public void handle(ActionEvent event) {        System.out.println(&quot;Thanks for clicking!&quot;);    }});</code></pre><p>这些例子有一个共同点，就是：先定义一段代码块，传给某个对象或方法，然后被执行。在Lambda表达式之前，Java是不允许直接传递代码块的，因为Java是面向对象的，因此必须传递一个对象，将要执行的代码块封装到对象里。</p><h2 id="1-2-Lambda表达式的语法"><a href="#1-2-Lambda表达式的语法" class="headerlink" title="1.2 Lambda表达式的语法"></a>1.2 Lambda表达式的语法</h2><p>将上面第二个例子中的<code>LengthComparator</code>，用Lambda表达式表示为：</p><pre><code>(String first, String second) -&gt; Integer.compare(first.length(),    second.length());</code></pre><p><code>-&gt;</code>前为参数列表，其后为表达式语句体；</p><p>如果表达式语句体不止一行，则将语句体写在{}中，与普通的函数一样：</p><pre><code>(String first, String second) -&gt; {    if (first.length() &gt; second.length()) {        return 1;    } else if (first.length() == second.length()) {        return 0;    } else {        return -1;    }};</code></pre><p>如果没有参数，<code>()</code>还是需要带上，比如上面的第一个例子，可以表示为：</p><pre><code>() -&gt; {    for (int i = 0; i &lt; 1000; i ++) {        doWork();    }}</code></pre><p>如果参数的类型可以从上下文自动推断，则可以省略：</p><pre><code>Comparator&lt;String&gt; comp    = (first, second) // Same as (String first, String second)    -&gt; Integer.compare(first.length(), second.length());</code></pre><p>如果参数只有一个，且类型可以自动推断，则小括号<code>()</code>也可以省略：</p><pre><code>// Instead of (event) -&gt; or (ActionEvent event) -&gt;eventHandler&lt;ActionEvent&gt; listener =    event -&gt; System.out.println(&quot;Thanks for clicking!&quot;);</code></pre><p>lambda表达式的返回值的类型是自动推断的，因此不需要指明；在lambda表达式，某些条件分支中有返回值，而其它分支没有返回值，是不允许的，如：</p><pre><code>(x) -&gt; {    if (x &gt;= 0) {        return 1;    }}</code></pre><p>另外，<code>expression lambda</code>和<code>statement lambda</code>的区别是，<code>expression lambda</code>不需要写<code>return</code>关键字，Java runtime会将表达式的结果作为返回值返回，而<code>statement lambda</code>是写在<code>{}</code>中的表达式，需要使用<code>return</code>关键字，比如：</p><pre><code>// expression lambdaComparator&lt;String&gt; comp1 =    (first, second) -&gt; Integer.compare(first.length(), second.length());// statement lambdaComparator&lt;String&gt; comp2 = (first, second) -&gt;    { return Integer.compare(first.length(), second.length());};</code></pre><h2 id="1-3-Functional-Interface"><a href="#1-3-Functional-Interface" class="headerlink" title="1.3 Functional Interface"></a>1.3 Functional Interface</h2><p>如果一个接口（interface）仅有一个抽象方法（abstract method），就称为<code>Functional Interface</code>，比如<code>Runnable</code>、<code>Comparator</code>等。在任何一个需要<code>Functional Interface</code>对象的地方，都可以使用lambda表达式：</p><pre><code>Arrays.sort(words,    (first, second) -&gt; Integer.compare(first.length(), second.length()));</code></pre><p>这里，<code>sort()</code>的第二个参数需要的是一个<code>Comparator</code>对象，而<code>Comparator</code>是<code>Functional Interface</code>，因此可以直接传入lambda表达式，在调用该对象的<code>compare()</code>方法时，就是执行该lambda表达式中的语句体；</p><p>如果lambda表达式的语句体会抛出异常，则对应的<code>Functional Interface</code>中的抽象方法必须抛出了该异常，否则就需要在lambda表达式中显式捕获异常：</p><pre><code>Runnable r = () -&gt; {   System.out.println(&quot;------&quot;);   try {       Thread.sleep(10);   } catch (InterruptedException e) {       // catch exception   }};Callable&lt;String&gt; c = () -&gt; {    System.out.println(&quot;--------&quot;);    Thread.sleep(10);    return &quot;&quot;;};</code></pre><h2 id="1-4-Method-Reference"><a href="#1-4-Method-Reference" class="headerlink" title="1.4 Method Reference"></a>1.4 Method Reference</h2><p>如果将lambda表达式的参数作为参数传递给一个方法，他们的执行效果是相同的，则该lambda表达式可以使用<code>Method Reference</code>表达，以下两种方式是等价的：</p><pre><code>(x) -&gt; System.out.println(x)System.out::println</code></pre><p>其中<code>System.out::println</code>被称为<code>Method Reference</code>。</p><p><code>Method Reference</code>主要有三种形式：</p><pre><code>object::instanceMethodClass::staticMethodClass::instanceMethod</code></pre><p>对于前两种方式，对应的lambda表达式的参数和method的参数是一致的，比如：</p><pre><code>System.out::println(x) -&gt; System.out.println(x)Math::pow  (x, y) -&gt; Math.pow(x, y)</code></pre><p>对于第三种方式，对应的lambda表达式的语句体中，第一个参数作为对象，调用method，将其它参数作为method的参数，比如：</p><pre><code>String::compareToIgnoreCase(s1, s2) -&gt; s1.compareToIgnoreCase(s2)</code></pre><h2 id="1-5-Constructor-Reference"><a href="#1-5-Constructor-Reference" class="headerlink" title="1.5 Constructor Reference"></a>1.5 Constructor Reference</h2><p><code>Constructor Reference</code>与<code>Method Reference</code>类似，只不过是特殊的method：<code>new</code>，具体调用的是哪个构造函数，由上下文环境决定，比如：</p><pre><code>List&lt;String&gt; labels = ...;Stream&lt;Button&gt; stream = labels.stream().map(Button::new);</code></pre><p><code>Button::new</code>等价于<code>(x) -&gt; Button(x)</code>，所以调用的构造函数是：<code>Button(x)</code>;</p><p>除了创建单个对象，也可以创建对象数组，如下面两种方式等价：</p><pre><code>int[]::new  (x) -&gt; new int[x]</code></pre><h2 id="1-6-变量作用域"><a href="#1-6-变量作用域" class="headerlink" title="1.6 变量作用域"></a>1.6 变量作用域</h2><p>lambd表达式会捕获当前作用域下可用的变量，比如：</p><pre><code>public void repeatMessage(String text, int count) {    Runnable r = () -&gt; {        for (int i = 0; i &lt; count; i ++) {            System.out.println(text);            Thread.yield();        }    };    new Thread(r).start();}</code></pre><p>但是这些变量必须是不可变的，为什么呢？看下面这个例子：</p><pre><code>int matches = 0;for (Path p : files)    new Thread(() -&gt; { if (p has some property) matches++; }).start();    // Illegal to mutate matches</code></pre><p>因为可变的变量在lambda表达式中不是线程安全的，这和内部类的要求是一致的，内部类中只能引用外部定义的<code>final</code>变量；</p><p>lambda表达式的作用域与嵌套代码块的作用域是一样的，所以在lambd表达式中的参数名或变量名不能与局部变量冲突，如：</p><pre><code>Path first = Paths.get(&quot;/usr/bin&quot;);Comparator&lt;String&gt; comp = (first, second) -&gt; Integer.compare(first.length(),     second.length()); // Error: Variable first already defined</code></pre><p>如果在lambda表达式中引用<code>this</code>变量，则引用的是创建该lambda表达式的方法的<code>this</code>变量，如：</p><pre><code>public class Application() {    public void doWork() {        Runnable runner = () -&gt; {            ...;            System.out.println(this.toString());            ...        };    }}</code></pre><p>所以这里的<code>this.toString()</code>调用的是<code>Application</code>对象的<code>toString()</code>，而不是<code>Runnable</code>对象的。</p><h2 id="1-7-Default-Method"><a href="#1-7-Default-Method" class="headerlink" title="1.7 Default Method"></a>1.7 Default Method</h2><p>接口中只能有抽象方法，如果在已有的接口中新增一个方法，则该接口所有的实现类都需要实现该方法。Java 8中引入了<code>Default Method</code>的概念，在接口中新增一个<code>default</code>方法，不会破坏已有的接口规则，接口的实现类可以选择重写或直接继承该<code>default</code>方法，比如：</p><pre><code>interface Person {    long getId();    default String getName() { return &quot;John Q. Public&quot;; }}</code></pre><p>Java是允许多继承的，如果一个类的父类中定义的方法和接口中定义的<code>default</code>方法完全相同，或者一个类的两个接口中定义了完全相同的方法， 则如何处理这种冲突呢？处理规则如下：</p><ul><li>如果是父类和接口的方法冲突：以父类中的方法为准，接口中的方法被忽略；</li><li>如果两个接口中的<code>default</code>方法冲突，则需要重写该方法解决冲突；</li></ul><h2 id="1-8-Static-Method"><a href="#1-8-Static-Method" class="headerlink" title="1.8 Static Method"></a>1.8 Static Method</h2><p>Java 8之前，接口中只能定义<code>static</code>变量，Java 8开始，接口中可以添加<code>static</code>方法，比如<br><code>Comparator</code>接口新增了一系列<code>comparingXXX</code>的<code>static</code>方法，比如：</p><pre><code>public static &lt;T&gt; Comparator&lt;T&gt; comparingInt(ToIntFunction&lt;? super T&gt;    keyExtractor) {    Objects.requireNonNull(keyExtractor);    return (Comparator&lt;T&gt; &amp; Serializable)      (c1, c2) -&gt; Integer.compare(keyExtractor.applyAsInt(c1),              keyExtractor.applyAsInt(c2));}</code></pre><p>使用这个<code>static</code>方法，以下两种方式也是等价的：</p><pre><code>Arrays.sort(cities, (first, second) -&gt; Integer.compare(first.length(),    second.length()));Arrays.sort(cities, Comparator.comparingInt(String::length));</code></pre><p>所以，以后我们在设计自己的接口时，不需要再定义单独的工具类（如Collections/Collection)，在接口中使用<code>static</code>方法就行了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.amazon.cn/Java-SE8-for-the-Really-Impatient-A-Short-Course-on-the-Basics-Horstmann-Cay-S/dp/0321927761/ref=sr_1_2" target="_blank" rel="external">Java SE8 for the Really Impatient</a></li><li><a href="https://gist.github.com/nkcoder/50c115a96c4e67164580#file-lambda-note-java" target="_blank" rel="external">Lambda示例代码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文链接为：&lt;a href=&quot;http://nkcoder.github.io/2016/01/16/java-8-lambda-expression-guide/&quot;&gt;http://nkcoder.github.io/2016/01/16/java-8-lambda-expression-guide/&lt;/a&gt;  ，转载请注明出处，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-1-为什么使用Lambda表达式&quot;&gt;&lt;a href=&quot;#1-1-为什么使用Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;1.1 为什么使用Lambda表达式&quot;&gt;&lt;/a&gt;1.1 为什么使用Lambda表达式&lt;/h2&gt;&lt;p&gt;先看几个例子：&lt;/p&gt;
&lt;p&gt;第一个例子，在一个独立的线程中执行某项任务，我们通常这么实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Worker implements Runnable {
    public void run() {
        for (int i = 0; i &amp;lt; 100; i++)
            doWork();
    }
    ...
}

Worker w = new Worker();
new Thread(w).start();
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="java" scheme="http://nkcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Python Tips 2: String模块与reversed关键字</title>
    <link href="http://nkcoder.github.io/2016/01/12/python-tips2-string-and-reversed/"/>
    <id>http://nkcoder.github.io/2016/01/12/python-tips2-string-and-reversed/</id>
    <published>2016-01-12T11:56:14.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-使用string模块"><a href="#1-使用string模块" class="headerlink" title="1. 使用string模块"></a>1. 使用string模块</h2><p>如果需要构造这样一个dict：</p><pre><code>&apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2&apos;C&apos; -&gt; 3...&apos;Z&apos; -&gt; 26</code></pre><a id="more"></a><p>你当然不想写26遍赋值语句，我们知道，内置函数<code>ord()</code>和<code>chr()</code>可以在unicode字符和值之间进行转换，而对于ASCII字符，unicode编码和ASCII编码的值相同，所以，可以这样来实现：</p><pre><code>ascii_of_A = ord(&apos;A&apos;)ascii_dict = {}for index in range(26):    c = chr(ascii_of_A + index)    ascii_dict[c] = index + 1</code></pre><p>其实，<code>string</code>模块有可以直接拿来用的函数：</p><pre><code>string.ascii_lettersstring.ascii_uppercasestring.ascii_lowercase</code></pre><p>所以，可以这样实现：</p><pre><code>ascii_dict = {}for index, c in enumerate(string.ascii_uppercase):    ascii_dict[c] = index + 1</code></pre><h2 id="2-使用reversed反转列表"><a href="#2-使用reversed反转列表" class="headerlink" title="2. 使用reversed反转列表"></a>2. 使用reversed反转列表</h2><p>现在，有个list或一个string，我们想逆序遍历，怎么实现呢？</p><p>最直觉简单的做法就是先拿到列表的长度，然后使用下标索引逆序遍历，像这样：</p><pre><code>num_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]i = len(num_list) - 1while i &gt;= 0:    print(num_list[i])    i -= 1</code></pre><p>python的内置函数<code>reversed()</code>就是用来反转一个列表的（list和string都可以）：</p><pre><code>for x in reversed(num_list):    print(x)</code></pre><p>如果在逆序遍历的同时，还希望得到对应的索引呢，使用<code>enumerate()</code>:</p><pre><code>for i, x in reversed(list(enumerate(num_list))):    print(i, x)</code></pre><p>其实，除了使用<code>reversed()</code>函数，也可以使用list和string的<strong>slicing</strong>机制，这里简单介绍一下：</p><pre><code>a_list[start:end:step]</code></pre><ul><li>默认是顺序遍历，且挨个元素遍历，因为step的值默认是1；</li><li>遍历的范围是list[start, end)，包含前一个索引，不包含后一个索引；</li><li>当start省略的时候，值为0，当end省略的时候，值为list的长度，所以a_list[::]表示整个列表；</li><li>start和end可以为负数，比如-1表示倒数第一个元素，可以认为此时的索引值为(list长度-1)；</li><li>step大于0时，表示顺序遍历，step小于0时，表示逆序遍历，所以[::-1]表示逆序遍历列表；</li></ul><p>明白了<strong>slicing</strong>的机制，上面的问题就很容易这样来实现了：</p><pre><code>for x in num_list[::-1]:    print(x)</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="external">Built-in Functions¶</a></li><li><a href="http://stackoverflow.com/questions/529424/traverse-a-list-in-reverse-order-in-python" target="_blank" rel="external">Traverse a list in reverse order in Python</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-使用string模块&quot;&gt;&lt;a href=&quot;#1-使用string模块&quot; class=&quot;headerlink&quot; title=&quot;1. 使用string模块&quot;&gt;&lt;/a&gt;1. 使用string模块&lt;/h2&gt;&lt;p&gt;如果需要构造这样一个dict：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;A&amp;apos; -&amp;gt; 1
&amp;apos;B&amp;apos; -&amp;gt; 2
&amp;apos;C&amp;apos; -&amp;gt; 3
...
&amp;apos;Z&amp;apos; -&amp;gt; 26
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="python" scheme="http://nkcoder.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python Tips 1: 循环与Enumerate</title>
    <link href="http://nkcoder.github.io/2016/01/10/python-tips1-loop-and-enumerate/"/>
    <id>http://nkcoder.github.io/2016/01/10/python-tips1-loop-and-enumerate/</id>
    <published>2016-01-10T14:07:42.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发的时候，经常会有这样的需求：遍历一个集合（比如数组），索引不是从0开始，而是从某一个具体的值开始，在Java或Swift中，可以直接用for循环实现：</p><p>Java代码：</p><pre><code>for (int i = 3; i &lt; dataList.size(); i++) {    // do someting with dataList[i]}</code></pre><a id="more"></a><p>Swift代码：</p><pre><code>for var i = 3; i &lt; dataList.count; i++ {    // do someting with dataList[i]}for i in 3 ..&lt; dataList.count {    // do someting with dataList[i]}</code></pre><p>但是python的for循环没有类似的形式，当然可以用while循环实现，但总感觉不够简洁：</p><pre><code>i = 3while i &lt; len(data_list):    // do someting with data_list[i]    i += 1</code></pre><p>借助<code>range()</code>函数，使用<code>for...in...</code>循环也是可以实现的：</p><pre><code>for i in range(3, len(data_list)):    // do someting with data_list[i]</code></pre><p>另外一种实现，可以使用<code>enumerate()</code>方法，起始索引通过参数设置：</p><pre><code>i = 3for (i, value) in enumerate(data_list[i:], start=i):    // do someting with value</code></pre><p>这里需要说明一下的是，<code>enumerate()</code>的第一个参数表示的数组，必须和第二个参数表示的索引是对应的，如果是<code>enumerate(data_list, start=i)</code>，那么i的值从3开始，而value的值还是从data_list[0]开始的，而不是从data_list[3]开始的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发的时候，经常会有这样的需求：遍历一个集合（比如数组），索引不是从0开始，而是从某一个具体的值开始，在Java或Swift中，可以直接用for循环实现：&lt;/p&gt;
&lt;p&gt;Java代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (int i = 3; i &amp;lt; dataList.size(); i++) {
    // do someting with dataList[i]
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="python" scheme="http://nkcoder.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python学习笔记之Native Datatypes</title>
    <link href="http://nkcoder.github.io/2015/12/25/python3-learn-note-datatypes/"/>
    <id>http://nkcoder.github.io/2015/12/25/python3-learn-note-datatypes/</id>
    <published>2015-12-25T15:43:17.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文来自<a href="http://www.diveintopython3.net/native-datatypes.html" target="_blank" rel="external">Dive Into Python 3-Native Datatypes</a>的学习笔记，记录重点，用于加深印象。</p></blockquote><p><strong>所有变量都是有数据类型，但是不需要声明，python会在第一次赋值时确定变量的类型；</strong></p><h2 id="1-1-Boolean"><a href="#1-1-Boolean" class="headerlink" title="1.1 Boolean"></a>1.1 Boolean</h2><ul><li>True/False</li></ul><a id="more"></a><h2 id="1-2-Number"><a href="#1-2-Number" class="headerlink" title="1.2 Number"></a>1.2 Number</h2><ul><li><code>isinstance(1, int)</code>方法可以用来确定变量的类型；</li><li>整数和浮点数可以通过<code>int(float1), float(int1)</code>进行转换；</li><li>运算符：<code>/, //, %, **</code>;</li><li>分数：<code>fractions.Fraction(1, 3)</code>;</li><li>三角函数：<code>math.pi; math.sin(2)</code>;</li><li>条件判断：0(包括0.0, Fraction(0, n))-&gt; False；非0 -&gt; True；</li><li>注意：python没有运算符++/–，可以通过num += 1实现自增；</li></ul><h2 id="1-3-List"><a href="#1-3-List" class="headerlink" title="1.3 List"></a>1.3 List</h2><ul><li><code>list1 = []; list2 = [2, &#39;a&#39;]</code>;</li><li>子list：<code>list2[0:3]; list2[:-1]; list2[1:]; list2[:]</code>;</li><li>增加元素：+操作符；<code>append(&#39;a&#39;); extend([2, 3, 4]); insert(0, &#39;a&#39;)</code>;</li><li>查找元素：in操作；<code>index(&#39;b&#39;); len(list1)</code>;</li><li>删除元素：<code>del list1[1]; list1.remove(&#39;a&#39;); list1.pop()</code>; <code>remove()</code>方法仅会删除第一个元素；</li><li>判断list是否为空：<code>if not list1:</code></li><li>条件判断：空list（[]） -&gt; False；非空list -&gt; True;</li><li>将list作为queue使用，可以通过<code>append(x); pop(0)</code>实现;<br>但是当数据量较大时，通过<code>collections.deque()</code>效率会更高一些：<code>append(x); popleft()</code></li></ul><h2 id="1-4-Tuple"><a href="#1-4-Tuple" class="headerlink" title="1.4 Tuple"></a>1.4 Tuple</h2><ul><li>tuple1(); tuple2(3,);(只有一个元素时必须加逗号)；tuple3(‘a’, ‘b’, 3);</li><li>可以看成是不可变的list；tuple比list更快；</li><li>list和tuple可以通过tuple(list1)和list(tuple1)相互转换；</li><li>查找：in操作；len(set1);</li><li>条件判断：空tuple(()) -&gt; False; 非空tuple -&gt; True;</li></ul><h2 id="1-5-Set"><a href="#1-5-Set" class="headerlink" title="1.5 Set"></a>1.5 Set</h2><ul><li><code>set1 = {1, 2}</code>;</li><li>创建空set：<code>set1 = set()</code>; 而<code>set1 = {}</code>创建的是一个空dict；</li><li>set和list可以通过<code>set(list1), list(set1)</code>相互转换；</li><li>修改：<code>add()/update()/discard()/remove()/clear()</code>;</li><li>集合操作: <code>union()/intersection()/difference()/symmetric_difference()/issubset()/issuperset()</code>;</li><li>查找：in操作；<code>len(set1)</code>;</li><li>条件判断：空set（set()) -&gt; False, 非空set -&gt; True</li></ul><h2 id="1-6-dictionary"><a href="#1-6-dictionary" class="headerlink" title="1.6 dictionary"></a>1.6 dictionary</h2><ul><li><code>dict1 = {}; dict2 = {&#39;key1&#39;: &#39;value1&#39;}</code></li><li>dict支持in操作，判断key是否存在；</li><li>dict的key和value都可以是任意类型；</li><li>方法：len();</li><li>空dict({}) -&gt; False, 非空dict -&gt; True</li></ul><h2 id="1-7-None"><a href="#1-7-None" class="headerlink" title="1.7 None"></a>1.7 None</h2><ul><li>None是python的null，仅与None比较时为True，与其它任意值比较都为False；</li><li>在条件判断时，None -&gt; False; not None -&gt; True;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文来自&lt;a href=&quot;http://www.diveintopython3.net/native-datatypes.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dive Into Python 3-Native Datatypes&lt;/a&gt;的学习笔记，记录重点，用于加深印象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;所有变量都是有数据类型，但是不需要声明，python会在第一次赋值时确定变量的类型；&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-1-Boolean&quot;&gt;&lt;a href=&quot;#1-1-Boolean&quot; class=&quot;headerlink&quot; title=&quot;1.1 Boolean&quot;&gt;&lt;/a&gt;1.1 Boolean&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;True/False&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="python" scheme="http://nkcoder.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>移动社交App服务端开发总结</title>
    <link href="http://nkcoder.github.io/2015/12/24/social-app-backend-tech-stack/"/>
    <id>http://nkcoder.github.io/2015/12/24/social-app-backend-tech-stack/</id>
    <published>2015-12-24T07:15:03.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前在一创业公司，开发一款移动社交app，作为服务端首席码农（服务端就我一个人），也算是见证了服务端从无到有的全过程。<br>客户端从最初上线至今5个月以来，迭代了8个版本，服务端都比较稳定（当然， 这跟我们处于发展初期，用户量和数据<br>量不大有很大关系）。在这里分享一下，和大家交流一下，本文不谈具体的技术实现，主要谈技术栈和一些感受。由于技术能力和<br>视野的欠缺，不足之处，欢迎指点。</p><a id="more"></a><h2 id="1-云服务"><a href="#1-云服务" class="headerlink" title="1. 云服务"></a>1. 云服务</h2><h3 id="1-1-阿里云"><a href="#1-1-阿里云" class="headerlink" title="1.1 阿里云"></a>1.1 阿里云</h3><p>服务器用了2台ECS，做高可用，ECS前用nginx做负载均衡，当然，也可以使用阿里云提供的负载均衡服务，不过那是要花银子<br>的，创业初期，能省就省了，不过ngingx服务也是蛮稳定的。<br>（<strong>2016-02-26更新</strong>：负载均衡已更改为阿里云的LB，每天差不多0.5元，但是LB的状态监控不太准确，一会儿显示异常，一<br>会儿显示正常，异常的原因不具体，根据异常的原因去查或报工单，完全对应不上！）</p><p>由于我们的产品面向海外用户，所以使用的是阿里云在洛杉矶的服务器，海外访问的速度应该还可以，国内稍差点，导致阿里云<br>的监控经常超时报警。2台ECS的配置均为：2核/8G/4Mbps。</p><p>数据库用了1台RDS MySQL，可靠性和可用性由阿里云保障，自己只要针对性地做一些参数调整和优化即可，也没什么运维成本。<br>RDS的配置为：1200M内存/50G空间/300最大连接数/600最大IOPS。</p><p>测试环境用了1台单独的ECS，然后在上面安装了MySQL。</p><p>总体来讲，阿里云提供的技术服务还是不错的，至于售后服务，至今没打过交道，无法评价。</p><p><strong>2016-06-02更新</strong>：补充一下阿里云的工单服务，处理地比较及时，一般半个小时内会有相应的技术对接。但是，处理结果并<br>不总是让人满意！</p><h3 id="1-2-环信"><a href="#1-2-环信" class="headerlink" title="1.2 环信"></a>1.2 环信</h3><p>社交产品肯定少不了消息模块，我们用的是环信。其实我是被选择了环信，因为我接手的时候，客户端已经基于环信开发了。其<br>实对消息服务提供商，我个人印象最好的是<a href="https://leancloud.cn/" target="_blank" rel="external">LeanCloud</a>，这里就多说两句（有点广告的嫌疑了，<br>哈哈），对这个创业公司最初的印象来自于他们的创始团队，创始人来自Google，很有极客范，后来了解了一下他们的产品，感<br>觉他们的API和Demo比环信的专业和规范太多了，大家可以自己去比较，我打算以后有机会体验一下他家的一站式后端服务。</p><p>说回环信，功能上没啥问题，该有的都有。这里说几点感受：1. 接口文档不全：有一次，我需要一个接口，很常见的需求，文档<br>上没有（确实没有），我问了一下技术咨询，他说有啊，然后发过来一个接口示例，我想，如果写在文档上，那不是节省了双方<br>的时间么！2. 技术客服有的很专业，有的很水，经常是问一个问题，客服转来转去的；3.环信没有部署海外节点，所以海外服务<br>的质量一般，消息存在延时的问题。</p><h3 id="1-3-七牛"><a href="#1-3-七牛" class="headerlink" title="1.3 七牛"></a>1.3 七牛</h3><p>我们的图片存在七牛上，七牛提供各种图片处理方式，是很方便的。</p><p>我们的产品面向海外，晒图又是主要功能之一，所以为了优化用户体验，选择部署了海外节点的服务商是重要考量。目前来看，<br>基本没得选，就七牛可以。但是七牛海外加速下载的费用非常高，是国内下载流量的5倍/G，创业公司伤不起哇！</p><p>另外，10月8日的故障（官方说是电缆被挖断）影响甚广，我们也是受害者，当时app内的图片基本全部无法显示（技术客服说<br>有CDN缓存，但是并没有什么卵用），故障持续了差不多一个半小时，后来赔付方案出炉，一共赔了我们7.6元，还是百倍赔付哦，<br>我们都表示七牛好大方！</p><p>我觉得七牛的文档和示例都很一般，举个例子，服务端通过七牛的接口上传下载图片经常超时报错，我找了技术客服很多次，<br>各种日志截图，各种解释，他们最后告诉我海外上传下载有单独的域名和ip，但是文档上一字不提，跟别提配置方法了。关于七<br>牛的客服，我有个经验，就是通过QQ交流时，他们爱搭不理，但是如果提交工单，回复会很及时。</p><p>对七牛的服务，印象并不算太好，只是现在没有更好地解决方案。</p><p><strong>2016-02-26更新</strong>：现在还一直在使用七牛图片存储，从2016-01-28开始，七牛海外CDN服务降价了，从原来的1.5元/G，<br>降到现在的0.39元/G，对我们面向海外的创业公司而言，是个大大的利好消息，因为每月开销是原来的1/4了。</p><h2 id="2-技术栈"><a href="#2-技术栈" class="headerlink" title="2. 技术栈"></a>2. 技术栈</h2><h3 id="2-1-SpringMVC-Spring-MyBatis"><a href="#2-1-SpringMVC-Spring-MyBatis" class="headerlink" title="2.1 SpringMVC + Spring + MyBatis"></a>2.1 SpringMVC + Spring + MyBatis</h3><p>典型的Java Web结构，通过SpringMVC提供API接口与客户端交互，使用Spring处理业务逻辑，使用MyBatis处理数据逻辑。</p><p>虽然前期数据量不大，但是功能模块比较多，导致数据库的表也比较多。目前的功能主要分为两大块：社交和社区。社交模块已<br>经有50多个表了，所以我提前进行了分库处理，将新增的社区模块放到新库，由于数据量不大，所以目前没有分表的需求。</p><p>分库可以通过MyBatis实现，在定义<code>MapperScannerConfigurer</code>的bean时，通过<code>basePackage</code>设置不同的package访问<br>不同的数据库。</p><p>另外，项目使用logback打印日志，通过git进行版本管理，使用gradle构建，使用jetty部署项目。gradle可以实现类似于<br>Maven的profile功能，将正式环境和测试环境的配置隔离开。</p><h3 id="2-2-quartz"><a href="#2-2-quartz" class="headerlink" title="2.2 quartz"></a>2.2 quartz</h3><p>定时任务，用<a href="https://quartz-scheduler.org/" target="_blank" rel="external">quartz</a>实现的，开启了quartz的集群功能和持久化功能。因为项目会<br>在两台服务器上单独部署，quartz刚好可以构成集群；同时，将任务调度信息持久化到MySQL中，则不会因为服务器的重启或<br>宕机导致定时任务的重复调度或错过调度。</p><p>关于quartz的使用，可以参考我之前的博文<a href="http://nkcoder.github.io/tags/quartz/">Quartz教程系列</a>和在<br><a href="https://github.com/nkcoder/quartz-explained" target="_blank" rel="external">github上的小项目</a>。</p><h3 id="2-3-ElasticSearch"><a href="#2-3-ElasticSearch" class="headerlink" title="2.3 ElasticSearch"></a>2.3 ElasticSearch</h3><p>app具有基于用户的个人信息进行多维度的个性化推荐的功能，维度包括：位置、性别、年龄、身高、星座、国家、家乡等等，<br>其中最主要的还是地理位置。我们使用的RDS的MySQL版本是5.6， 我们知道MySQL在5.7之前，对空间数据（Spatial Data）<br>的支持是不太友好的，所以其它维度还好，而基于地理位置的查询，使用MySQL来实现是比较麻烦的，而且效率不高。</p><p>后来，我就决定不通过MySQL实现，采用NoSQL来做，<a href="https://www.elastic.co/" target="_blank" rel="external">ElasticSearch</a>和<br><a href="https://www.mongodb.org/" target="_blank" rel="external">MongoDB</a>都支持空间索引，而且我之前也都有过一些了解，最后选择ElasticSearch的主<br>要原因是，考虑到app以后可能会增加搜索功能，而这可是ElasticSearch的强项啊。</p><p>然后我就用两台ECS，搭建了一个ElasticSearch集群，创建一个index和一个type，然后将用户的基本信息从MySQL同步过<br>来，将不同的维度作为查询条件，就实现了一个简单的推荐系统。</p><p>ElasticSearch集群运行非常稳定，目前偶尔会接到内存达到阀值的报警，主要是由于搜索时需要排除之前已经推荐过的用户，<br>导致内存有时会飙到80%，等腾出时间了想办法优化一下。</p><h3 id="2-4-Scrapy"><a href="#2-4-Scrapy" class="headerlink" title="2.4 Scrapy"></a>2.4 Scrapy</h3><p>在推广前期，有些模块是没有数据的，所以需要从网络上爬取一些相关数据。爬虫使用的是python的<br><a href="http://scrapy.org/" target="_blank" rel="external">Scrapy框架</a>，使用起来比较简单，目前可以实现不登录爬取、登录爬取，但是具有复杂验证码验证的<br>登录爬取要麻烦，还没有时间去研究。</p><p>关于Scrapy爬虫入门，可以参考我之前的博文：</p><ol><li><a href="http://nkcoder.github.io/2015/11/17/Scrapy-crawl-intro-install-and-config/">搭建Scrapy爬虫的开发环境</a>；</li><li><a href="http://nkcoder.github.io/2015/12/10/scrapy-crawl-simple-in-action/">Scrapy爬虫入门实例</a>。</li></ol><h3 id="2-5-Django"><a href="#2-5-Django" class="headerlink" title="2.5 Django"></a>2.5 Django</h3><p>还有一个后台管理系统，使用python的<a href="https://www.djangoproject.com/" target="_blank" rel="external">Django框架</a>写的，是让一个朋友在业余时间帮忙开发的，我基本没有参与。</p><p>Django不个不错的CMS框架，适合快速开发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前在一创业公司，开发一款移动社交app，作为服务端首席码农（服务端就我一个人），也算是见证了服务端从无到有的全过程。&lt;br&gt;客户端从最初上线至今5个月以来，迭代了8个版本，服务端都比较稳定（当然， 这跟我们处于发展初期，用户量和数据&lt;br&gt;量不大有很大关系）。在这里分享一下，和大家交流一下，本文不谈具体的技术实现，主要谈技术栈和一些感受。由于技术能力和&lt;br&gt;视野的欠缺，不足之处，欢迎指点。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="elasticsearch" scheme="http://nkcoder.github.io/tags/elasticsearch/"/>
    
      <category term="quartz" scheme="http://nkcoder.github.io/tags/quartz/"/>
    
      <category term="redis" scheme="http://nkcoder.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Swift的guard语句</title>
    <link href="http://nkcoder.github.io/2015/12/18/swift-guard-statement/"/>
    <id>http://nkcoder.github.io/2015/12/18/swift-guard-statement/</id>
    <published>2015-12-18T00:15:33.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 2引入了<code>guard</code>关键字，特性可以概括为以下两点：</p><ul><li>仅关注需要满足的条件，一旦条件不满足，快速返回（fast return）；</li><li>对于optional的变量，使用<code>guard let</code>解绑后，在包含<code>guard</code>的作用域内（guard语句已结束），该解绑后的值仍然可用；</li></ul><a id="more"></a><h2 id="1-失败快速返回"><a href="#1-失败快速返回" class="headerlink" title="1. 失败快速返回"></a>1. 失败快速返回</h2><p>使用<code>if</code>语句，如果关注点是需要满足的条件，则：</p><pre><code>if firstName != &quot;&quot; &amp;&amp; lastName != &quot;&quot; {    // do stuff with firstName and lastName} else {    // fast return}</code></pre><blockquote><p>如果条件满足后要执行的逻辑很长，则当条件不满足时，无法快速返回；</p></blockquote><p>如果失败快速返回，则关注点是不满足的条件，如果不满足的条件很多，则这是不合理的：</p><pre><code>if firstName == &quot;&quot; || lastName == &quot;&quot; {    // fast return} else {    // do stuff with firstName and lastName}</code></pre><p>使用<code>guard</code>语句，关注需要满足的条件，不满足快速返回：</p><pre><code>guard firstName != &quot;&quot; &amp;&amp; lastName != &quot;&quot; else {    // fast return}// do stuff with firstName and lastName</code></pre><h2 id="2-optional解绑"><a href="#2-optional解绑" class="headerlink" title="2. optional解绑"></a>2. optional解绑</h2><p>使用<code>if let</code>解绑optional变量，在if作用域外，解绑的值是不可用的：</p><pre><code>func checkAge(ageOfUser:Int?) {    if let age = ageOfUser where age &gt; 17 {        // do stuff with age    }     // cannot use age anymore    //    print(&quot;you age is: \(age), continue.&quot;)}</code></pre><p>使用<code>guard let</code>解绑optional变量后，在包含guard的作用域内，解绑后的值是可用的：</p><pre><code>func checkAge(ageOfUser: Int?) {    guard let age = ageOfUser where age &gt; 17 else {        // fast return        return    }    // do stuff with age    print(&quot;you age is: \(age), continue.&quot;)}</code></pre><p>鉴于<code>guard</code>语句带来的好处，如果可以，尽量使用<code>guard</code>语句。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html" target="_blank" rel="external">Statements</a></li><li><a href="https://www.hackingwithswift.com/new-syntax-swift-2-guard" target="_blank" rel="external">The guard keyword in Swift 2: early returns made easy</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift 2引入了&lt;code&gt;guard&lt;/code&gt;关键字，特性可以概括为以下两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅关注需要满足的条件，一旦条件不满足，快速返回（fast return）；&lt;/li&gt;
&lt;li&gt;对于optional的变量，使用&lt;code&gt;guard let&lt;/code&gt;解绑后，在包含&lt;code&gt;guard&lt;/code&gt;的作用域内（guard语句已结束），该解绑后的值仍然可用；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://nkcoder.github.io/categories/iOS/"/>
    
    
      <category term="Swift" scheme="http://nkcoder.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy爬虫入门实例</title>
    <link href="http://nkcoder.github.io/2015/12/10/scrapy-crawl-simple-in-action/"/>
    <id>http://nkcoder.github.io/2015/12/10/scrapy-crawl-simple-in-action/</id>
    <published>2015-12-10T08:20:48.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>在搭建好了Scrapy的开发环境后（如果配置过程中遇到问题，请参考上一篇文章<br><a href="http://nkcoder.github.io/2015/11/17/Scrapy-crawl-intro-install-and-config/">搭建Scrapy爬虫的开发环境</a>，<br>或者在博客里留言），我们开始演示爬取实例。</p><p>我们试图爬取<a href="http://www.xiaochuncnjp.com/forum-19-1.html" target="_blank" rel="external">论坛-东京版</a>的主题贴。该网<br>站需要登录后才能查看帖子附带的大图，适合演示登录过程。</p><a id="more"></a><h2 id="1-定义item"><a href="#1-定义item" class="headerlink" title="1. 定义item"></a>1. 定义item</h2><p>我们需要保存标题、帖子详情、帖子详情的url、图片列表，所以定义item如下：</p><pre><code>class RentItem(scrapy.Item):    &quot;&quot;&quot;item类&quot;&quot;&quot;    title = scrapy.Field()          # 标题    rent_desc = scrapy.Field()      # 描述    url = scrapy.Field()            # 详情的url    pic_list = scrapy.Field()       # 图片列表</code></pre><h2 id="2-使用FormRequest模拟登录"><a href="#2-使用FormRequest模拟登录" class="headerlink" title="2. 使用FormRequest模拟登录"></a>2. 使用FormRequest模拟登录</h2><p>首先我们需要分析页面，找到登录的form，以及需要提交的数据（用Fiddler或Firebug分析请求即可），<br>然后使用Scrapy提供<code>FormRequest.from_response()</code>模拟页面的登录过程，主要代码如下：</p><pre><code># 需要登录，使用FormRequest.from_response模拟登录if &quot;id=&apos;lsform&apos;&quot; in response.body:    logging.info(&quot;in parse, need to login, url: {0}&quot;.format(response.url))    form_data = {        &quot;handlekey&quot;: &quot;ls&quot;,        &quot;quickforward&quot;: &quot;yes&quot;,        &quot;username&quot;: &quot;loginname&quot;,        &quot;password&quot;: &quot;passwd&quot;    }    request = FormRequest.from_response(            response=response,            headers=self.headers,            formxpath=&quot;//form[contains(@id, &apos;lsform&apos;)]&quot;,            formdata=form_data,            callback=self.parse_list            )else:    logging.info(&quot;in parse, NOT need to login, url: {0}&quot;                 .format(response.url))    request = Request(url=response.url,                      headers=self.headers,                      callback=self.parse_list,                      )</code></pre><p>如果请求的页面需要登录，则通过xpath定位到对应的form，将登录需要的数据作为参数，提交登录，<br>在callback对应的回调方法里，处理登录成功后的爬取逻辑。</p><h2 id="3-使用XPath提取页面数据"><a href="#3-使用XPath提取页面数据" class="headerlink" title="3. 使用XPath提取页面数据"></a>3. 使用XPath提取页面数据</h2><p>Scrapy使用XPath或CSS表达式分析页面结构，由基于lxml的Selector提取数据。XPath或者CSS都可<br>以，另外<a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank" rel="external">BeautifulSoup</a><br>分析HTML/XML文件非常方便，这里采用XPath分析页面，请参考<br><a href="http://zvon.org/comp/r/tut-XPath_1.html" target="_blank" rel="external">zvon-XPath 1.0 Tutorial</a>，示例丰富且易<br>懂，看完这个入门教程，常见的爬取需求基本都能满足。我这里简单解释一下几个重要的点：</p><ul><li><p>/表示绝对路径，即匹配从根节点开始，./表示当前路径，//表示匹配任意开始节点；</p></li><li><p>*是通配符，可以匹配任意节点；</p></li><li><p>在一个节点上使用[]，如果是数字n表示匹配第n个element，如果是@表示匹配属性，还可以使用函数，<br>比如常用的contains()表示包含，starts-with()表示字符串起始匹配等。</p></li><li><p>在取节点的值时，text()只是取该节点下的值，而不会取该节点的子节点的值，而.则会取包括子节点<br>在内的所有值，比如：</p></li></ul><pre><code>&lt;div&gt;Welcome to &lt;strong&gt;Chengdu&lt;/strong&gt;&lt;/div&gt;sel.xpath(&quot;div/text()&quot;)     // Welcome tosel.xpath(&quot;div&quot;).xpath(&quot;string(.)&quot;)        // Welcome to Chengdu</code></pre><h2 id="4-不同的spider使用不同的pipeline"><a href="#4-不同的spider使用不同的pipeline" class="headerlink" title="4. 不同的spider使用不同的pipeline"></a>4. 不同的spider使用不同的pipeline</h2><p>我们可能有很多的spider，不同的spider爬取的数据的结构不一样，对应的存储格式也不尽相同，因此<br>我们会定义多个pipeline，让不同的spider使用不同的pipeline。</p><p>首先我们需要定义一个decorator，表示如果spider的<code>pipeline</code>属性中包含了添加该注解的pipeline，<br>则执行该pipeline，否则跳过该pipeline：</p><pre><code>def check_spider_pipeline(process_item_method):    &quot;&quot;&quot;该注解用在pipeline上    :param process_item_method:    :return:    &quot;&quot;&quot;    @functools.wraps(process_item_method)    def wrapper(self, item, spider):        # message template for debugging        msg = &quot;{1} {0} pipeline step&quot;.format(self.__class__.__name__)        # if class is in the spider&quot;s pipeline, then use the        # process_item method normally.        if self.__class__ in spider.pipeline:            logging.info(msg.format(&quot;executing&quot;))            return process_item_method(self, item, spider)        # otherwise, just return the untouched item (skip this step in        # the pipeline)        else:            logging.info(msg.format(&quot;skipping&quot;))            return item    return wrapper</code></pre><p>然后，我们还需要在所有pipeline类的回调方法<code>process_item()</code>上添加该decrator注解：</p><pre><code>@check_spider_pipelinedef process_item(self, item, spider):</code></pre><p>最后，在spider类中添加一个数组属性<code>pipeline</code>，里面是所有与该spider对应的pipeline，比如：</p><pre><code># 应该交给哪个pipeline去处理pipeline = set([    pipelines.RentMySQLPipeline,])</code></pre><h2 id="5-将爬取的数据保存到mysql"><a href="#5-将爬取的数据保存到mysql" class="headerlink" title="5. 将爬取的数据保存到mysql"></a>5. 将爬取的数据保存到mysql</h2><p>数据存储的逻辑在pipeline中实现，可以使用<code>twisted adbapi</code>以线程池的方式与数据库交互。首<br>先从setttings中加载mysql配置：</p><pre><code>@classmethoddef from_settings(cls, settings):    &quot;&quot;&quot;加载mysql配置&quot;&quot;&quot;    dbargs = dict(        host=settings[&quot;MYSQL_HOST&quot;],        db=settings[&quot;MYSQL_DBNAME&quot;],        user=settings[&quot;MYSQL_USER&quot;],        passwd=settings[&quot;MYSQL_PASSWD&quot;],        charset=&quot;utf8&quot;,        use_unicode=True    )    dbpool = adbapi.ConnectionPool(&quot;MySQLdb&quot;, **dbargs)    return cls(dbpool)</code></pre><p>然后在回调方法<code>process_item</code>中使用dbpool保存数据到mysql：</p><pre><code>@check_spider_pipelinedef process_item(self, item, spider):    &quot;&quot;&quot;pipeline的回调.    注解用于pipeline与spider之间的对应，只有spider注册了该pipeline，pipeline才    会被执行    &quot;&quot;&quot;    # run db query in the thread pool，在独立的线程中执行    deferred = self.dbpool.runInteraction(self._do_upsert, item, spider)    deferred.addErrback(self._handle_error, item, spider)    # 当_do_upsert方法执行完毕，执行以下回调    deferred.addCallback(self._get_id_by_guid)    # at the end, return the item in case of success or failure    # deferred.addBoth(lambda _: item)    # return the deferred instead the item. This makes the engine to    # process next item (according to CONCURRENT_ITEMS setting) after this    # operation (deferred) has finished.    time.sleep(10)    return deferred</code></pre><h2 id="6-将图片保存到七牛云"><a href="#6-将图片保存到七牛云" class="headerlink" title="6. 将图片保存到七牛云"></a>6. 将图片保存到七牛云</h2><p>查看七牛的python接口即可，这里要说明的是，上传图片的时候，不要使用BucketManager的<br><code>bucket.fetch()</code>接口，因为经常上传失败，建议使用<code>put_data()</code>接口，比如：</p><pre><code>def upload(self, file_data, key):    &quot;&quot;&quot;通过二进制流上传文件    :param file_data:   二进制数据    :param key:         key    :return:    &quot;&quot;&quot;    try:        token = self.auth.upload_token(QINIU_DEFAULT_BUCKET)        ret, info = put_data(token, key, file_data)    except Exception as e:        logging.error(&quot;upload error, key: {0}, exception: {1}&quot;                      .format(key, e))    if info.status_code == 200:        logging.info(&quot;upload data to qiniu ok, key: {0}&quot;.format(key))        return True    else:        logging.error(&quot;upload data to qiniu error, key: {0}&quot;.format(key))        return False</code></pre><h2 id="7-项目部署"><a href="#7-项目部署" class="headerlink" title="7. 项目部署"></a>7. 项目部署</h2><p>部署可以使用<a href="http://scrapyd.readthedocs.org/en/latest/api.html" target="_blank" rel="external">scrapyd</a>和<a href="https://github.com/scrapy/scrapyd-client/tree/master/scrapyd-client" target="_blank" rel="external">scrapyd-client</a>。<br>首先安装：</p><pre><code>$ pip install scrapyd$ pip install scrapyd-client</code></pre><p>启动scrapyd:</p><pre><code>$ sudo scrapyd &amp;</code></pre><p>修改部署的配置文件scrapy.cfg:</p><pre><code>[settings]default = scrapy_start.settings[deploy:dev]url = http://localhost:6800/project = scrapy_start</code></pre><p>其中dev表示target，scrapy_start表示project，部署即可：</p><pre><code>$ scrapyd-deploy dev -p scrapy_start</code></pre><p>ok，这篇入门实例的重点就这么多，项目的源码<a href="https://gitlab.com/daniel-blogcode/scrapy_in_practice" target="_blank" rel="external">在gitlab</a>。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://doc.scrapy.org/en/latest/index.html" target="_blank" rel="external">Scrapy 1.0 documentation</a></li><li><a href="http://zvon.org/comp/r/tut-XPath_1.html#intro" target="_blank" rel="external">XPath 1.0 Tutorial</a></li><li><a href="http://stackoverflow.com/questions/8372703/how-can-i-use-different-pipelines-for-different-spiders-in-a-single-scrapy-proje" target="_blank" rel="external">How can I use different pipelines for different spiders in a single Scrapy project</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在搭建好了Scrapy的开发环境后（如果配置过程中遇到问题，请参考上一篇文章&lt;br&gt;&lt;a href=&quot;http://nkcoder.github.io/2015/11/17/Scrapy-crawl-intro-install-and-config/&quot;&gt;搭建Scrapy爬虫的开发环境&lt;/a&gt;，&lt;br&gt;或者在博客里留言），我们开始演示爬取实例。&lt;/p&gt;
&lt;p&gt;我们试图爬取&lt;a href=&quot;http://www.xiaochuncnjp.com/forum-19-1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;论坛-东京版&lt;/a&gt;的主题贴。该网&lt;br&gt;站需要登录后才能查看帖子附带的大图，适合演示登录过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="Scrapy" scheme="http://nkcoder.github.io/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>记App Store审核被拒的经历</title>
    <link href="http://nkcoder.github.io/2015/11/24/ios-app-review-reject-process/"/>
    <id>http://nkcoder.github.io/2015/11/24/ios-app-review-reject-process/</id>
    <published>2015-11-24T15:13:37.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们的app最近一次上架的过程颇费周折，被拒了两次。我试图还原整个过程，包括被拒的原因以及我与<code>App Review Team</code>的沟通内容，将本文作为经验教训给看到的朋友一个参考。</p><a id="more"></a><h2 id="1-第一次被拒"><a href="#1-第一次被拒" class="headerlink" title="1. 第一次被拒"></a>1. 第一次被拒</h2><p>我们的app是<code>Oct 31, 2015 at 6:34 PM</code>提交的，第一次审核结果出来是<code>Nov 10, 2015 at 7:56 AM</code>，差不多9天。被拒的原因如下：</p><p><img src="/images/post/app-reject-v2.0.0-1.0.jpg" alt="app-reject-v2.0.0-1.0"></p><p>被拒的原因说得很详细，就是我们的app描述文字里出现了<code>逼格</code>关键字，app的启动页中有一张图片上出现了<code>逗逼</code>的关键字。</p><p>相关的文字是：</p><pre><code>3. 晒图大厅，一个涵盖了世界的逼格大秀场！4. 社区，整合了大部分的海外租房、二手信息，以及海归招聘信息！</code></pre><p>涉及的图片是：</p><p><img src="/images/post/app-reject-v2.0.0-1.1.png" alt="app-reject-v2.0.0-1.1"></p><p>将文字和图片修改后，需要重新打包提交（因为启动页图片修改了），所以重新排队<code>Waiting For Review</code>。这是我们自己的错误，所以没什么可抱怨的。</p><blockquote><p>反思：我们这次上线的是V2.0.0版本，是一个大版本，有很多的功能改进和优化，所以介绍性文字和图片有一些调整，但是在提交审核的时候又没有引起足够的重视，一方面可能是之前的提交太顺利了（V2.0.0之前共提交了7个版本，每次都是一次过，每次审核都没有超过7天），导致这次有点大意，另一方面确实是我自己的疏忽，提交之前没有仔细检查。所以，这样的教训也提醒大家，在提交有较多更新的大版本时，最好把更新的部分好好检查一下。</p></blockquote><h2 id="2-第二次被拒"><a href="#2-第二次被拒" class="headerlink" title="2. 第二次被拒"></a>2. 第二次被拒</h2><p><code>Nov 10, 2015 at 7:56 AM</code>第二次提交后，<code>Nov 18, 2015 at 6:39 AM</code>有了结果，不过还是被拒：<code>Metadata Rejected</code>：</p><p><img src="/images/post/app-reject-v2.0.0-2.0.jpg" alt="app-reject-v2.0.0-2.0"><br><img src="/images/post/app-reject-v2.0.0-2.1.jpg" alt="app-reject-v2.0.0-2.1"></p><p>被拒的原因是我们提供的演示帐号失效了。我测试了一下，果然如此！！！因为提供的演示帐号带有<code>test</code>关键字，肯定是哪个后台管理员（我们得好好聊聊了）误操作把它清除了，真是自作孽，不可活！</p><p>含着悲愤的心情，准备好演示帐号后，我在想接下来该怎么办？因为按照被拒的提示，我只需要提供需要的信息，保存，重新提交，review过程会继续，但是网上也有很多朋友说，重新提交就意味着重新排队！最后我还是选择了相信官方的提示，保存，然后重新提交， App的状态变成了<code>Waiting For Review</code>。</p><blockquote><p>反思：演示帐号失效，应该是最不应该犯的一个低级错误了。我自己吸取的教训就是：1）演示帐号不要带有<code>test</code>等可被忽略的关键字；2）以后提交审核时，所有被审核的内容都应该重新测试，检查其有效性，包括演示帐号、app描述、app支持URL等；3）确保线上数据可控，以免被随意修改。</p></blockquote><h2 id="3-与App-Review-Team的沟通"><a href="#3-与App-Review-Team的沟通" class="headerlink" title="3. 与App Review Team的沟通"></a>3. 与<code>App Review Team</code>的沟通</h2><p>重新提交之后，我忐忑不安地等待了一天半，但是App的状态一直没变。网上有一些朋友的经验是：<code>Metadata Rejected</code>的情况下一般很快就会进入<code>In Review</code>的状态，有的是立即，有的是两三个小时。那我这个不太正常啊，不会是重新进入排队了吧？！于是我试着发信询问，选择的是<a href="https://developer.apple.com/contact/app-store/" target="_blank" rel="external">get the status of my app</a>，询问的内容为：</p><pre><code>Hi App Review Team:Yesterday morning, I got a message of &quot;Metadata Rejected&quot; for my app. According to the message, I just need to provide some information(new binary is not required), and save it and then &quot;Submit for Review&quot;, you can continue the review. I did that exactly.The status of my app is still &quot;Waiting for review&quot; after one and a half days. I just want to know that if you will continue the review or I have to wait for about one week, so that I can prepare for it. It&apos;s very kind of you to give some feedback!</code></pre><p>第二天就收到了邮件回复，内容如下：</p><p><img src="/images/post/app-review-reply-1.jpg" alt="app-review-reply-1"></p><p>他说我reject了app，意思就是修改了上传的程序包并重新提交了！天啊，冤枉啊！于是我觉得有必要再发信澄清一下，这次选择了<a href="https://developer.apple.com/contact/app-store/" target="_blank" rel="external">get clarification  on an app rejection</a>，询问的内容为：</p><pre><code>Dear App Review Team:Thanks for your replay, but sorry I have to appeal for my app review.You reply to me that: &quot;We noticed that you have rejected your app on at least one occasion.&quot;. but I didn&apos;t. &quot;Metadata Rejected&quot; messages ask me to do the following:    - Login to iTunes Connect    - Click on “My Apps”    - Select your app    - Click on the app version on the left side of the screen    - Scroll down to “App Review Information”    - Provide information in “Demo Account” and/or “Notes” as appropriate    - Click “Save”    - Once you’ve completed all changes, click the “Submit for Review” button at the top of the App version information page.    While your iTunes Connect Application State shows as Metadata Rejected, we don&apos;t require a new binary to correct this issue. Once this information is available, we can continue your review.And I did exactly following the above steps, I promise. I didn&apos;t reject or update the binary, it doesn&apos;t make sense because it&apos;s not necessary. I don&apos;t think it&apos;s fair to add our app to the end of the review queue. I&apos;m really confused, please help to clarify, thank you!</code></pre><p>我的意思就是我只是更新了一些信息，并没有重新提交程序包（后来想到，程序包的上传是有个时间戳的，那个完全可以证明我没有重新上传呀，只是当时没想到这一点）。还是第二天，不是邮件回复，而是<code>Itunes Connect</code>中的<code>Resolution Center</code>中有回复，内容如下：</p><p><img src="/images/post/app-review-reply-2.jpg" alt="app-review-reply-2"></p><p>意思是说，由于我重新提交了，为了尽快审核，他们需要关闭当前的申诉会话，继续审核；如果我执意申诉，他们就会取消审核过程！好吧，惹不起，那我保持沉默，麻烦您尽快审核吧！</p><p>过了差不多4个小时，也是在当天，状态变成了<code>In Review</code>，第二天早上，状态成为了<code>Pending Developer Release</code>：</p><p><img src="/images/post/app-v2.0.0-status.jpg" alt="app-v2.0.0-status"></p><p>其中，从18号到21号那几天就是与<code>App Review Team</code>的沟通耗时。</p><p>至此，我终于松了一口气！这个版本，从第一次提交，到最后上线，花了整整21天，这是我们预先没有想到的，因此对整体的规划有一定的影响。</p><blockquote><p>反思：app被拒时，最好按照官方的提示进行修改，因为每个人被拒的情形都不太一样，所以别人的经验不一定适合，即使后面遇到问题需要沟通，这个也是可以作为证据的嘛。另外，如果对审核的过程不理解、不明白，可以直接与<code>App Review Team</code>沟通，他们的回复还是挺及时有效的。我想，如果我没有发信询问，也许在第二次被拒后，还需要再等一周也说不定呢！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们的app最近一次上架的过程颇费周折，被拒了两次。我试图还原整个过程，包括被拒的原因以及我与&lt;code&gt;App Review Team&lt;/code&gt;的沟通内容，将本文作为经验教训给看到的朋友一个参考。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://nkcoder.github.io/categories/iOS/"/>
    
    
      <category term="app-review" scheme="http://nkcoder.github.io/tags/app-review/"/>
    
  </entry>
  
  <entry>
    <title>搭建Scrapy爬虫的开发环境</title>
    <link href="http://nkcoder.github.io/2015/11/17/Scrapy-crawl-intro-install-and-config/"/>
    <id>http://nkcoder.github.io/2015/11/17/Scrapy-crawl-intro-install-and-config/</id>
    <published>2015-11-17T13:33:22.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一章主要介绍Scrapy的安装、安装过程中可能遇到的问题以及解决方式。由于我在Mac和Ubuntu环境下都尝试过，所以会将两个平台上遇到的问题都记下来以供参考。</p><p>在安装Scrapy之前，首先需要安装以下组件：</p><ul><li>python 2.7</li><li>pip</li><li>lxml</li><li>openssl</li></ul><p>接下来分别介绍。</p><a id="more"></a><h2 id="1-安装python-2-7"><a href="#1-安装python-2-7" class="headerlink" title="1. 安装python 2.7"></a>1. 安装python 2.7</h2><p>目前Scrapy 1.x仅支持python2.x（官方说以后会支持python 3.x，但目前不支持）。一般系统都预装了python，可以通过<code>-V</code>命令查看版本：</p><pre><code>GuoDaniel:~ nkcoder$ python -VPython 2.7.10</code></pre><p>当然你可以直接使用系统的python，但更好地做法是通过<code>virtualenv</code>虚拟化一个python环境，与系统的python隔离，避免依赖冲突等问题。</p><p>安装<code>virtualenv</code>：</p><pre><code>$ [sudo] pip install virtualenv</code></pre><p>创建一个python虚拟环境：</p><pre><code>GuoDaniel:start_scrapy nkcoder$ virtualenv startenvNew python executable in /Users/nkcoder/Projects/python/start_scrapy/startenv/bin/pythonInstalling setuptools, pip, wheel...done.GuoDaniel:start_scrapy nkcoder$ source startenv/bin/activate(startenv) GuoDaniel:start_scrapy nkcoder$ lsstartenv(startenv) GuoDaniel:start_scrapy nkcoder$ which pip/Users/nkcoder/Projects/python/start_scrapy/startenv/bin/pip(startenv) GuoDaniel:start_scrapy nkcoder$ python -VPython 2.7.10</code></pre><p>virtualenv也可以指定python解释器，默认使用PATH定义的python解释器。比如创建一个python 3的虚拟环境：</p><pre><code>GuoDaniel:start_scrapy nkcoder$ virtualenv -p /Library/Frameworks/Python.framework/Versions/3.5/bin/python3 python3envRunning virtualenv with interpreter /Library/Frameworks/Python.framework/Versions/3.5/bin/python3Using base prefix &apos;/Library/Frameworks/Python.framework/Versions/3.5&apos;New python executable in /Users/nkcoder/Projects/python/start_scrapy/python3env/bin/python3Also creating executable in /Users/nkcoder/Projects/python/start_scrapy/python3env/bin/pythonInstalling setuptools, pip, wheel...done.GuoDaniel:start_scrapy nkcoder$ source python3env/bin/activate(python3env) GuoDaniel:start_scrapy nkcoder$ which python/Users/nkcoder/Projects/python/start_scrapy/python3env/bin/python(python3env) GuoDaniel:start_scrapy nkcoder$ python -VPython 3.5.0</code></pre><ul><li>参考：<a href="https://virtualenv.readthedocs.org/en/latest/installation.html" target="_blank" rel="external">VirtualEnv Installation</a></li></ul><h2 id="2-安装pip"><a href="#2-安装pip" class="headerlink" title="2. 安装pip"></a>2. 安装pip</h2><p>通过virtualenv安装的python，默认已经安装了对应版本的pip，查看pip版本：</p><pre><code>GuoDaniel:start_scrapy nkcoder$ source startenv/bin/activate(startenv) GuoDaniel:start_scrapy nkcoder$ which pip/Users/nkcoder/Projects/python/start_scrapy/startenv/bin/pip(startenv) GuoDaniel:start_scrapy nkcoder$ pip -Vpip 7.1.2 from /Users/nkcoder/Projects/python/start_scrapy/startenv/lib/python2.7/site-packages (python 2.7)</code></pre><p>如果需要自己安装pip，也很简单，首先<a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="external">下载get-pip.py脚本</a>，然后安装：</p><pre><code>$ python get-pip.py</code></pre><ul><li>参考：<a href="http://pip.readthedocs.org/en/stable/installing/" target="_blank" rel="external">Pip Installation</a></li></ul><h2 id="3-安装lxml"><a href="#3-安装lxml" class="headerlink" title="3. 安装lxml"></a>3. 安装lxml</h2><p>通过<code>pip</code>安装lxml：</p><pre><code>$ sudo pip install lxml</code></pre><p><strong>在Mac环境下安装lxml可能会遇到以下错误</strong>：</p><pre><code>In file included from src/lxml/lxml.etree.c:314:/private/tmp/pip_build_root/lxml/src/lxml/includes/etree_defs.h:9:10: fatal error: &apos;libxml/xmlversion.h&apos; file not found#include &quot;libxml/xmlversion.h&quot;             ^1 error generated.error: command &apos;cc&apos; failed with exit status 1</code></pre><p>安装或更新xcode-select即可：</p><pre><code>$ xcode-select --install</code></pre><ul><li>参考：<a href="http://stackoverflow.com/questions/19548011/cannot-install-lxml-on-mac-os-x-10-9" target="_blank" rel="external">Cannot install Lxml on Mac os x 10.9</a></li></ul><p><strong>在Ubuntu环境下可能会遇到以下错误</strong>：</p><pre><code>libxml/xmlversion.h: No such file or directory compilation terminated.</code></pre><p>需要安装相应的dev包：</p><pre><code>$ sudo apt-get install libxml2-dev libxslt1-dev python-dev</code></pre><ul><li>参考：<a href="http://stackoverflow.com/questions/6504810/how-to-install-lxml-on-ubuntu" target="_blank" rel="external">how-to-install-lxml-on-ubuntu</a></li></ul><h2 id="4-安装openssl"><a href="#4-安装openssl" class="headerlink" title="4. 安装openssl"></a>4. 安装openssl</h2><p>系统一般都预装有openssl：</p><pre><code>$ openssl versionOpenSSL 0.9.8zg 14 July 2015</code></pre><h2 id="5-安装Scrapy"><a href="#5-安装Scrapy" class="headerlink" title="5. 安装Scrapy"></a>5. 安装Scrapy</h2><p>通过pip安装Scrapy：</p><pre><code>$ sudo pip install scrapy</code></pre><p><strong>在Mac环境下，如果系统版本是<code>OS X EI Capitan</code>，并且使用的是系统的python，而不是virtualenv的虚拟环境，则可能会遇到如下问题</strong>：</p><pre><code>OSError: [Errno 1] Operation not permitted: &apos;/tmp/pip-nIfswi-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six-1.4.1-py2.7.egg-info&apos;</code></pre><p>原因是Scrapy的依赖库Six与系统搞得依赖库Six发生了冲突，一种解决方式是将系统的<code>System Integrity Protection</code>临时禁用，更好地解决方式当然是使用virtualenv创建一个隔离的python环境。</p><ul><li>参考：<a href="http://stackoverflow.com/questions/31900008/oserror-errno-1-operation-not-permitted-when-installing-scrapy-in-osx-10-11" target="_blank" rel="external">“OSError: [Errno 1] Operation not permitted”</a></li></ul><p><strong>在ubuntu环境下，可能会遇到这个问题</strong>：</p><pre><code>fatal error: openssl/aes.h: No such file or directory</code></pre><p>安装<code>libssl-dev</code>即可：</p><pre><code>$ sudo apt-get install libssl-dev</code></pre><ul><li>参考：<a href="http://ask.xmodulo.com/fix-fatal-error-openssl.html" target="_blank" rel="external">How to fix “fatal error: openssl/aes.h: No such file or directory”</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一章主要介绍Scrapy的安装、安装过程中可能遇到的问题以及解决方式。由于我在Mac和Ubuntu环境下都尝试过，所以会将两个平台上遇到的问题都记下来以供参考。&lt;/p&gt;
&lt;p&gt;在安装Scrapy之前，首先需要安装以下组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;python 2.7&lt;/li&gt;
&lt;li&gt;pip&lt;/li&gt;
&lt;li&gt;lxml&lt;/li&gt;
&lt;li&gt;openssl&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来分别介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="Scrapy" scheme="http://nkcoder.github.io/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>VirtualBox安装Ubuntu Server</title>
    <link href="http://nkcoder.github.io/2014/12/16/virtualbox-install-ubuntu-server/"/>
    <id>http://nkcoder.github.io/2014/12/16/virtualbox-install-ubuntu-server/</id>
    <published>2014-12-16T12:47:40.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>有段时间没更新博客了，今天写一篇随手笔记吧。</p><p>公司给配置的电脑是Thinkpad， 装的是Windows，但手边没有个Linux环境，总感觉缺点啥，于是决定在虚拟机上装个Ubuntu。</p><a id="more"></a><p>版本情况：</p><ul><li>Windows：64位Windows 7</li><li>VirtualBox：VirtualBox-4.3.20-96997-Win</li><li>Ubuntu：ubuntu-14.04.1-server-amd64</li></ul><p>在VirtualBox中新建虚拟机时，发现ubuntu的版本只有<code>Ubuntu(32bit)</code>一个选项，有点纳闷，不管了，先继续安装。选择完语言，开始安装后就报错了：</p><pre><code>This kernel requires an X86-64 CPU,but only detected an i686 CPU</code></pre><p>Goolge一下，很常见的问题了，需要在BIOS中启用<code>Intel VT-x</code>的虚拟化配置，该配置默认是禁用的。</p><p>然后，重新启动虚拟机，还是同样的错误，原来还需要在settings中将version修改为<code>Ubuntu(64 bit)</code>，再重新启动就OK了。</p><p>以前在VirtualBox中安装CentOS时，也遇到相同的问题，只是过了一段时间后就忘了，好记性不如烂笔头。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://hereirestinremorse.wordpress.com/virtualbox/this-kernel-requires-an-x86-64-cpu-but-only-detected-an-i686-cpu-unable-to-boot-please-use-a-kernel-appropriate-for-your-cpu/" target="_blank" rel="external">This kernel requires an x86-64 CPU</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有段时间没更新博客了，今天写一篇随手笔记吧。&lt;/p&gt;
&lt;p&gt;公司给配置的电脑是Thinkpad， 装的是Windows，但手边没有个Linux环境，总感觉缺点啥，于是决定在虚拟机上装个Ubuntu。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="virtualbox" scheme="http://nkcoder.github.io/tags/virtualbox/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch+LogStash+Kibana+Redis日志服务的高可用方案</title>
    <link href="http://nkcoder.github.io/2014/11/06/elkr-log-platform-deploy-ha/"/>
    <id>http://nkcoder.github.io/2014/11/06/elkr-log-platform-deploy-ha/</id>
    <published>2014-11-06T13:35:33.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-高可用方案的架构"><a href="#1-高可用方案的架构" class="headerlink" title="1. 高可用方案的架构"></a>1. 高可用方案的架构</h3><p>在上一篇文章<a href="http://nkcoder.github.io/blog/20141031/elkr-log-platform-deploy/">使用ElasticSearch+LogStash+Kibana+Redis搭建日志管理服务</a>中介绍了日志服务的整体框架以及各组件的搭建部署，本篇文章主要讨论一下日志服务框架的高可用方案，主要从以下三个方面考虑：</p><a id="more"></a><ul><li>作为broker的Redis，可以使用redis cluster或者主备结构代替单实例，提高broker组件的可用性；</li><li>作为indexer的LogStash，可以部署多个LogStash实例，协作处理日志信息，提高indexer组件的可用性；</li><li>作为search&amp;storage的ElasticSearch，采用ElasticSearch Cluster，提高search&amp;storage组件的性能和可用性；</li></ul><!-- more --><p>日志服务的高可用方案的示意图为：</p><p><img src="/images/post/ELKR-log-platform-ha.jpg" alt="ELKR-log-platform-ha"></p><p>下面分别予以介绍。</p><h3 id="2-Redis-Cluster和主备结构"><a href="#2-Redis-Cluster和主备结构" class="headerlink" title="2. Redis Cluster和主备结构"></a>2. Redis Cluster和主备结构</h3><h4 id="2-1-Redis-Cluster"><a href="#2-1-Redis-Cluster" class="headerlink" title="2.1 Redis Cluster"></a>2.1 Redis Cluster</h4><p>首先需要部署一个redis cluster，为了方便，我在本机上部署了一个三主三从的cluster，端口分别为：7000, 7001, 7002, 7003, 7004, 7005，以端口7000为例，配置文件为：</p><pre><code>include ../redis.confdaemonize yespidfile /var/run/redis_7000.pidport 7000logfile /opt/logs/redis/7000.logappendonly yescluster-enabled yescluster-config-file node-7000.conf</code></pre><p>对于redis来说，远程Logstash和中心LogStash都是redis cluster的client，因此只需要与cluster中的任何一个节点连接即可；远程LogStash和中心LogStash的redis配置部分为：</p><p>shipper.conf:</p><pre><code>output {    redis {        host =&gt; &quot;20.8.40.49:7000&quot;        data_type =&gt; &quot;list&quot;        key =&gt; &quot;key_count&quot;    }   }</code></pre><p>central.conf:</p><pre><code>input {    redis {        host =&gt; &quot;20.8.40.49&quot;        port =&gt; 7000        type =&gt; &quot;redis-cluster-input&quot;        data_type =&gt; &quot;list&quot;        key =&gt; &quot;key_count&quot;    }}</code></pre><p>使用redis cluster的优劣分析：</p><ul><li>可以提高broker组件的可用性：当每一个master节点都有slave节点的时候，任何一个节点挂掉，都不影响集群的正常工作；如果启用<code>cluster-require-full-coverage no</code>，则有效节点构成的子集群仍然可用。</li><li>当作为broker组件的redis成为瓶颈的时候，redis cluster提供良好的扩展性。但是redis cluster有一个比较头疼的问题，就是在伸缩(增删节点)时，需要手动做sharding，官方提供了<code>redis-trib.rb</code>工具，我自己实现了一个java版本，可以作为参考<a href="https://github.com/nkcoder/redis-toolkit" target="_blank" rel="external">redis-toolkit</a>。</li><li>当前的redis cluster还是RC1版，稳定版还需要等待一段时间。</li></ul><h4 id="2-2-redis主备结构"><a href="#2-2-redis主备结构" class="headerlink" title="2.2 redis主备结构"></a>2.2 redis主备结构</h4><p>注意，主备不是主从，备用的redis实例只是作为冗余节点，当主节点挂掉时，备用的节点会顶上，任何时刻仅有一个节点在提供服务。无论是远程LogStash还是中心LogStash，都需要明确配置所有主备redis节点的信息，LogStash会轮询节点列表，选择一个可用的节点。比如，配置两个redis实例，6379作为主，6380作为从，则远程LogStash和中心LogStash的配置分别为：</p><p>shipper.conf:</p><pre><code>output {    redis {        host =&gt; [&quot;20.8.40.49:6379&quot;, &quot;20.8.40.49:6380&quot;]        data_type =&gt; &quot;list&quot;        key =&gt; &quot;key_count&quot;    }   }</code></pre><p>central.conf:</p><pre><code>input {    redis {        host =&gt; &quot;20.8.40.49&quot;        port =&gt; 6379        type =&gt; &quot;redis-cluster-input&quot;        data_type =&gt; &quot;list&quot;        key =&gt; &quot;key_count&quot;    }    redis {        host =&gt; &quot;20.8.40.49&quot;        port =&gt; 6380        type =&gt; &quot;redis-cluster-input&quot;        data_type =&gt; &quot;list&quot;        key =&gt; &quot;key_count&quot;    }}</code></pre><p>redis主备结构的优劣分析：</p><ul><li>可以提高broker组件的可用性：只要主备节点中有一个节点可用，broker组件服务就是可用的；</li><li>主备结构无法解决redis成为瓶颈的情况；</li></ul><h3 id="3-部署多个中心LogStash"><a href="#3-部署多个中心LogStash" class="headerlink" title="3. 部署多个中心LogStash"></a>3. 部署多个中心LogStash</h3><p>当日志信息的量很大时，作为indexer的LogStash很可能成为瓶颈，此时，可以部署多个中心LogStash，它们之间的关系是对等的，共同从broker处提取消息，中心LogStash节点之间是相互独立的。每一个中心LogStash节点的配置是完全一样的，比如当broker是redis cluster时，中心LogStash的配置为：</p><p>central.conf:</p><pre><code>input {    redis {        host =&gt; &quot;20.8.40.49&quot;        port =&gt; 7000        type =&gt; &quot;redis-cluster-input&quot;        data_type =&gt; &quot;list&quot;        key =&gt; &quot;key_count&quot;    }}</code></pre><p>部署多个中心LogStash的优劣分析：</p><ul><li>可以提高indexer组件的可用性：多个中心LogStash节点之间是相互独立的，任何一个节点的失效不会影响其它节点，更不会影响整个indexer组件；当broker是redis时，各个中心LogStash都是redis的client，它们都是执行<code>BLPOP</code>命令从redis中提取消息，而redis的任何单个命令都是原子的，因此多中心LogStash不仅可以提高indexer组件的可用性，也可以提高indexer组件的处理能力和效率；</li><li>多中心LogStash节点的部署和维护成本，可以借助配置管理工具如<a href="http://puppetlabs.com/" target="_blank" rel="external">Puppet</a>、<a href="http://www.saltstack.com/" target="_blank" rel="external">SaltStack</a>等</li></ul><h3 id="4-ElasticSearch-Cluster"><a href="#4-ElasticSearch-Cluster" class="headerlink" title="4. ElasticSearch Cluster"></a>4. ElasticSearch Cluster</h3><p>ElasticSearch原生支持Cluster模式，节点之间通过单播或多播进行通信；ElasticSearch Cluster能自动检测节点的增加、失效和恢复，并重新组织索引。</p><p>比如，我们启动两个ElasticSearch实例构成集群，使用默认配置即可，如：</p><pre><code>$ bin/elasticsearch -d$ bin/elasticsearch -d</code></pre><p>使用默认配置，两个实例的HTTP监听端口分别为9200和9201，它们的节点间通信端口分别为9300和9301，默认使用多播构成集群，集群的名称为elasticsearch；</p><p>中心LogStash只需要配置ElasticSearch的cluster name即可(如果不能发现ES集群，可以指定host: <code>host =&gt; &quot;20.8.40.49&quot;</code>)，如：</p><pre><code>output {    elasticsearch {        cluster =&gt; &quot;elasticsearch&quot;        codec =&gt; &quot;json&quot;        protocol =&gt; &quot;http&quot;    }   }</code></pre><p>使用ElasticSearch Cluster的优劣分析：</p><ul><li>提高组件的可用性：cluster中任何一个节点挂掉，索引及副本都会自动重新分配；</li><li>极佳的水平扩展性：向cluster中增加新的节点即可，索引会自动重新组织；</li></ul><h3 id="5-后续工作"><a href="#5-后续工作" class="headerlink" title="5. 后续工作"></a>5. 后续工作</h3><p>关于ELKR日志服务，下一步的工作方向有：</p><ul><li>学习grok正则表达式，匹配自定义的日志输出格式；</li><li>研究ElasticSearch的查询功能及原理；</li><li>熟悉Kibana丰富的图标展示功能；</li></ul><p>Ok，高可用方案的介绍告一段落，如果用到实际的生产环境中，应该会遇到很多意想不到的问题，后续会继续总结和分享。</p><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul><li><a href="http://www.logstashbook.com/" target="_blank" rel="external">The LogStash Book</a></li><li><a href="http://www.elasticsearch.org/guide/" target="_blank" rel="external">ElasticSearch doc</a></li><li><a href="http://redis.io/documentation" target="_blank" rel="external">Redis Documentation</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-高可用方案的架构&quot;&gt;&lt;a href=&quot;#1-高可用方案的架构&quot; class=&quot;headerlink&quot; title=&quot;1. 高可用方案的架构&quot;&gt;&lt;/a&gt;1. 高可用方案的架构&lt;/h3&gt;&lt;p&gt;在上一篇文章&lt;a href=&quot;http://nkcoder.github.io/blog/20141031/elkr-log-platform-deploy/&quot;&gt;使用ElasticSearch+LogStash+Kibana+Redis搭建日志管理服务&lt;/a&gt;中介绍了日志服务的整体框架以及各组件的搭建部署，本篇文章主要讨论一下日志服务框架的高可用方案，主要从以下三个方面考虑：&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="elasticsearch" scheme="http://nkcoder.github.io/tags/elasticsearch/"/>
    
      <category term="kibana" scheme="http://nkcoder.github.io/tags/kibana/"/>
    
      <category term="logstash" scheme="http://nkcoder.github.io/tags/logstash/"/>
    
  </entry>
  
  <entry>
    <title>使用ElasticSearch+LogStash+Kibana+Redis搭建日志管理服务</title>
    <link href="http://nkcoder.github.io/2014/10/31/elkr-log-platform-deploy/"/>
    <id>http://nkcoder.github.io/2014/10/31/elkr-log-platform-deploy/</id>
    <published>2014-10-31T01:37:56.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-日志平台的结构示意图"><a href="#1-日志平台的结构示意图" class="headerlink" title="1. 日志平台的结构示意图"></a>1. 日志平台的结构示意图</h3><p><img src="/images/post/ELKR-log-platform.jpg" alt="ELKR-log-platform"></p><p>说明：</p><ul><li>多个独立的agent(Shipper)负责收集不同来源的数据，一个中心agent(Indexer)负责汇总和分析数据，在中心agent前的Broker(使用redis实现)作为缓冲区，中心agent后的ElasticSearch用于存储和搜索数据，前端的Kibana提供丰富的图表展示。</li><li>Shipper表示日志收集，使用LogStash收集各种来源的日志数据，可以是系统日志、文件、redis、mq等等；</li><li>Broker作为远程agent与中心agent之间的缓冲区，使用redis实现，一是可以提高系统的性能，二是可以提高系统的可靠性，当中心agent提取数据失败时，数据保存在redis中，而不至于丢失；</li><li>中心agent也是LogStash，从Broker中提取数据，可以执行相关的分析和处理(Filter)；</li><li>ElasticSearch用于存储最终的数据，并提供搜索功能；</li><li>Kibana提供一个简单、丰富的web界面，数据来自于ElasticSearch，支持各种查询、统计和展示；</li></ul><a id="more"></a><h3 id="2-搭建部署"><a href="#2-搭建部署" class="headerlink" title="2. 搭建部署"></a>2. 搭建部署</h3><p>环境：</p><ul><li>本机(20.8.40.49)上部署：redis, 中心agent(LogStash), ElasticSearch以及Kibana</li><li>远程测试机(20.20.79.75)上部署：独立agent(LogStash)</li><li>Redis版本：<a href="https://github.com/antirez/redis/archive/3.0.0-rc1.tar.gz" target="_blank" rel="external">3.0.0-rc1</a></li><li>LogStash版本；<a href="https://download.elasticsearch.org/logstash/logstash/logstash-1.4.2.tar.gz" target="_blank" rel="external">logstash-1.4.2</a></li><li>ElasticSearch版本：<a href="https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-1.3.4.tar.gz" target="_blank" rel="external">elasticsearch-1.3.4</a></li><li>Kibana版本：<a href="https://download.elasticsearch.org/kibana/kibana/kibana-3.1.1.tar.gz" target="_blank" rel="external">kibana-3.1.1</a></li></ul><h4 id="2-1-部署redis"><a href="#2-1-部署redis" class="headerlink" title="2.1 部署redis"></a>2.1 部署redis</h4><p>部署一个redis单机实例:</p><pre><code>$ wget https://github.com/antirez/redis/archive/3.0.0-rc1.tar.gz$ tar zxvf 3.0.0-rc1.tar.gz -C /usr/local</code></pre><p>redis.conf配置文件为：</p><pre><code>include ../redis.confdaemonize yespidfile /var/run/redis_6379.pidport 6379logfile /opt/logs/redis/6379.logappendonly yes</code></pre><p>启动：</p><pre><code>$ redis.server redis.conf</code></pre><blockquote><p>ip为10.7.40.40， 端口为6379</p></blockquote><h4 id="2-2-部署中心LogStash"><a href="#2-2-部署中心LogStash" class="headerlink" title="2.2 部署中心LogStash"></a>2.2 部署中心LogStash</h4><p>下载并解压：</p><pre><code>$ wget https://download.elasticsearch.org/logstash/logstash/logstash-1.4.2.tar.gz$ tar zxvf logstash-1.4.2.tar.gz -C /usr/local/$ cd /usr/local/logstash-1.4.2$ mkdir conf logs</code></pre><p>配置文件conf/central.conf:</p><pre><code>input {    redis {        host =&gt; &quot;127.0.0.1&quot;        port =&gt; 6379        type =&gt; &quot;redis-input&quot;        data_type =&gt; &quot;list&quot;        key =&gt; &quot;key_count&quot;    }   }output {    stdout {}    elasticsearch {        cluster =&gt; &quot;elasticsearch&quot;        codec =&gt; &quot;json&quot;        protocol =&gt; &quot;http&quot;    }   }</code></pre><p>启动：</p><pre><code>$ bin/logstash agent --verbose --config conf/central.conf --log logs/stdout.log</code></pre><blockquote><p>配置文件表示输入来自于redis，使用redis的list类型存储数据，key为”key_count”；输出到elasticsearch，cluster的名称为”elasticsearch”;</p></blockquote><h4 id="2-3-部署ElasticSearch"><a href="#2-3-部署ElasticSearch" class="headerlink" title="2.3 部署ElasticSearch"></a>2.3 部署ElasticSearch</h4><p>下载并解压：</p><pre><code>$ wget https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-1.3.4.tar.gz$ tar zxvf elasticsearch-1.3.4.tar.gz -C /usr/local</code></pre><p>elasticsearch使用默认配置即可，默认的cluster name为：elasticsearch；</p><p>启动：</p><pre><code>$ bin/elasticsearch -d</code></pre><h4 id="2-4-部署远程LogStash"><a href="#2-4-部署远程LogStash" class="headerlink" title="2.4 部署远程LogStash"></a>2.4 部署远程LogStash</h4><p>与部署中心LogStash的步骤是类似的，只是配置文件不一样，使用新的配置文件启动即可；</p><p>配置文件conf/shipper.conf的内容为：</p><pre><code>input {    file {        type =&gt; &quot;type_count&quot;        path =&gt; [&quot;/data/logs/count/stdout.log&quot;, &quot;/data/logs/count/stderr.log&quot;]        exclude =&gt; [&quot;*.gz&quot;, &quot;access.log&quot;]    }   }output {    stdout {}    redis {        host =&gt; &quot;20.8.40.49&quot;        port =&gt; 6379        data_type =&gt; &quot;list&quot;        key =&gt; &quot;key_count&quot;    }   }</code></pre><blockquote><p>配置文件表示输入来自于目录/data/logs/count/下的stdout.log和stderr.log两个文件，且排除该目录下所有.gz文件和access.log；(这里因为path没有使用通配符，所以exclude是没有效果的)；输出表示将监听到的event发送到redis服务器，使用redis的list保存，key为”key_count”，这里的<code>data_type</code>属性和<code>key</code>属性应该与中心agent的配置一致；</p></blockquote><h4 id="2-5-部署Kibana"><a href="#2-5-部署Kibana" class="headerlink" title="2.5 部署Kibana"></a>2.5 部署Kibana</h4><p>下载并安装：</p><pre><code>$ wget https://download.elasticsearch.org/kibana/kibana/kibana-3.1.1.tar.gz$ tar zxvf kibana-3.1.1.tar.gz</code></pre><p>修改配置文件config.js，仅需要配置elasticsearch的地址即可：</p><pre><code>elasticsearch: &quot;http://20.8.40.49:9200&quot;</code></pre><p>将目录kibana-3.1.1拷贝到jetty的webapp目录下，并启动jetty：</p><pre><code>$ mv kibana-3.1.1 /usr/local/jetty-distribution-9.2.1.v20140609/webapps/$ bin/jetty start</code></pre><p>浏览器访问：</p><pre><code>http://20.8.40.49:8080/kibana-3.1.1/</code></pre><h3 id="3-简单测试"><a href="#3-简单测试" class="headerlink" title="3. 简单测试"></a>3. 简单测试</h3><p>打开LogStash的远程agent和中心agent的日志：</p><pre><code>$ tail -f logs/stdout.log</code></pre><p>远程agent的数据是以<code>rpush</code>操作将event推送到redis的list中，中心agent通过<code>blpop</code>命令从redis的list中提取数据，因此，测试时由于数据量小，通过命令<code>llen key_count</code>的返回结果很可能为空，因此为了观察redis中数据流的变化，可以使用<code>monitor</code>命令：</p><pre><code>$ redis-cli -p 6379 monitor</code></pre><p>现在，我们向/data/logs/count目录下的stdout.log和stderr.log各发送一条数据：</p><pre><code>$ echo &quot;stdout: just a test message&quot; &gt;&gt; stdout.log$ echo &quot;stderr: just a test message&quot; &gt;&gt; stderr.log</code></pre><p>远程agent和中心agent都会收到event消息，如远程agent的日志为：</p><pre><code>{:timestamp=&gt;&quot;2014-10-31T09:30:40.323000+0800&quot;, :message=&gt;&quot;Received line&quot;, :path=&gt;&quot;/data/logs/count/stdout.log&quot;, :text=&gt;&quot;stdout: just a test message&quot;, :level=&gt;:debug, :file=&gt;&quot;logstash/inputs/file.rb&quot;, :line=&gt;&quot;134&quot;}{:timestamp=&gt;&quot;2014-10-31T09:30:40.325000+0800&quot;, :message=&gt;&quot;writing sincedb (delta since last write = 52)&quot;, :level=&gt;:debug, :file=&gt;&quot;filewatch/tail.rb&quot;, :line=&gt;&quot;177&quot;}......{:timestamp=&gt;&quot;2014-10-31T09:30:49.350000+0800&quot;, :message=&gt;&quot;Received line&quot;, :path=&gt;&quot;/data/logs/count/stderr.log&quot;, :text=&gt;&quot;stderr: just a test message&quot;, :level=&gt;:debug, :file=&gt;&quot;logstash/inputs/file.rb&quot;, :line=&gt;&quot;134&quot;}{:timestamp=&gt;&quot;2014-10-31T09:30:49.352000+0800&quot;, :message=&gt;&quot;output received&quot;, :event=&gt;{&quot;message&quot;=&gt;&quot;stderr: just a test message&quot;, &quot;@version&quot;=&gt;&quot;1&quot;, &quot;@timestamp&quot;=&gt;&quot;2014-10-31T01:30:49.350Z&quot;, &quot;type&quot;=&gt;&quot;type_count&quot;, &quot;host&quot;=&gt;&quot;dn1&quot;, &quot;path&quot;=&gt;&quot;/data/logs/count/stderr.log&quot;}, :level=&gt;:debug, :file=&gt;&quot;(eval)&quot;, :line=&gt;&quot;19&quot;}</code></pre><p>我们可以观察到redis的输出：</p><pre><code>1414714174.936642 [0 20.20.79.75:54010] &quot;rpush&quot; &quot;key_count&quot; &quot;{\&quot;message\&quot;:\&quot;stdout: just a test message\&quot;,\&quot;@version\&quot;:\&quot;1\&quot;,\&quot;@timestamp\&quot;:\&quot;2014-10-31T00:10:04.530Z\&quot;,\&quot;type\&quot;:\&quot;type_count\&quot;,\&quot;host\&quot;:\&quot;dn1\&quot;,\&quot;path\&quot;:\&quot;/data/logs/count/stdout.log\&quot;}&quot;1414714174.939517 [0 127.0.0.1:56094] &quot;blpop&quot; &quot;key_count&quot; &quot;0&quot;1414714198.991452 [0 20.20.79.75:54010] &quot;rpush&quot; &quot;key_count&quot; &quot;{\&quot;message\&quot;:\&quot;stderr: just a test message\&quot;,\&quot;@version\&quot;:\&quot;1\&quot;,\&quot;@timestamp\&quot;:\&quot;2014-10-31T00:10:28.586Z\&quot;,\&quot;type\&quot;:\&quot;type_count\&quot;,\&quot;host\&quot;:\&quot;dn1\&quot;,\&quot;path\&quot;:\&quot;/data/logs/count/stderr.log\&quot;}&quot;1414714198.993590 [0 127.0.0.1:56094] &quot;blpop&quot; &quot;key_count&quot; &quot;0&quot;</code></pre><p>从elasticsearch中执行如下的简单查询：</p><pre><code>$ curl &apos;localhost:9200/_search?q=type:type_count&amp;pretty&apos;{  &quot;took&quot; : 3,  &quot;timed_out&quot; : false,  &quot;_shards&quot; : {    &quot;total&quot; : 6,    &quot;successful&quot; : 6,    &quot;failed&quot; : 0  },  &quot;hits&quot; : {    &quot;total&quot; : 2,    &quot;max_score&quot; : 0.5945348,    &quot;hits&quot; : [ {      &quot;_index&quot; : &quot;logstash-2014.10.31&quot;,      &quot;_type&quot; : &quot;type_count&quot;,      &quot;_id&quot; : &quot;w87bRn8MToaYm_kfnygGGw&quot;,      &quot;_score&quot; : 0.5945348,      &quot;_source&quot;:{&quot;message&quot;:&quot;stdout: just a test message&quot;,&quot;@version&quot;:&quot;1&quot;,&quot;@timestamp&quot;:&quot;2014-10-31T08:10:04.530+08:00&quot;,&quot;type&quot;:&quot;type_count&quot;,&quot;host&quot;:&quot;dn1&quot;,&quot;path&quot;:&quot;/data/logs/count/stdout.log&quot;}    }, {      &quot;_index&quot; : &quot;logstash-2014.10.31&quot;,      &quot;_type&quot; : &quot;type_count&quot;,      &quot;_id&quot; : &quot;wwmA2BD6SAGeNsuYz5ax-Q&quot;,      &quot;_score&quot; : 0.5945348,      &quot;_source&quot;:{&quot;message&quot;:&quot;stderr: just a test message&quot;,&quot;@version&quot;:&quot;1&quot;,&quot;@timestamp&quot;:&quot;2014-10-31T08:10:28.586+08:00&quot;,&quot;type&quot;:&quot;type_count&quot;,&quot;host&quot;:&quot;dn1&quot;,&quot;path&quot;:&quot;/data/logs/count/stderr.log&quot;}    } ]  }}</code></pre><p>再切换到Kibana的web界面：<a href="http://20.8.40.49:8080/kibana-3.1.1" target="_blank" rel="external">http://20.8.40.49:8080/kibana-3.1.1</a></p><p><img src="/images/post/kibana-count-log.png" alt="kibana-count-log"></p><h3 id="4-后续工作"><a href="#4-后续工作" class="headerlink" title="4. 后续工作"></a>4. 后续工作</h3><hr><ul><li>使用LogStash的Filter对日志数据进行过滤和分析；</li><li>使用Redis的Cluster模式替换单机模式；</li><li>在elasticsearch中对数据进行高级的分析和查询；</li><li>熟悉Kibana的展示组件以及查询语法；</li></ul><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul><li><a href="http://logstash.net/docs/1.4.2/" target="_blank" rel="external">logstash-doc-1.4.2</a></li><li><a href="http://www.elasticsearch.org/overview/" target="_blank" rel="external">elasticsearch</a></li><li><a href="http://redis.io/commands/blpop" target="_blank" rel="external">redis-blpop</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-日志平台的结构示意图&quot;&gt;&lt;a href=&quot;#1-日志平台的结构示意图&quot; class=&quot;headerlink&quot; title=&quot;1. 日志平台的结构示意图&quot;&gt;&lt;/a&gt;1. 日志平台的结构示意图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/post/ELKR-log-platform.jpg&quot; alt=&quot;ELKR-log-platform&quot;&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个独立的agent(Shipper)负责收集不同来源的数据，一个中心agent(Indexer)负责汇总和分析数据，在中心agent前的Broker(使用redis实现)作为缓冲区，中心agent后的ElasticSearch用于存储和搜索数据，前端的Kibana提供丰富的图表展示。&lt;/li&gt;
&lt;li&gt;Shipper表示日志收集，使用LogStash收集各种来源的日志数据，可以是系统日志、文件、redis、mq等等；&lt;/li&gt;
&lt;li&gt;Broker作为远程agent与中心agent之间的缓冲区，使用redis实现，一是可以提高系统的性能，二是可以提高系统的可靠性，当中心agent提取数据失败时，数据保存在redis中，而不至于丢失；&lt;/li&gt;
&lt;li&gt;中心agent也是LogStash，从Broker中提取数据，可以执行相关的分析和处理(Filter)；&lt;/li&gt;
&lt;li&gt;ElasticSearch用于存储最终的数据，并提供搜索功能；&lt;/li&gt;
&lt;li&gt;Kibana提供一个简单、丰富的web界面，数据来自于ElasticSearch，支持各种查询、统计和展示；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="elasticsearch" scheme="http://nkcoder.github.io/tags/elasticsearch/"/>
    
      <category term="kibana" scheme="http://nkcoder.github.io/tags/kibana/"/>
    
      <category term="logstash" scheme="http://nkcoder.github.io/tags/logstash/"/>
    
  </entry>
  
  <entry>
    <title>为什么应该选择Gradle</title>
    <link href="http://nkcoder.github.io/2014/10/27/why-should-choose-gradle/"/>
    <id>http://nkcoder.github.io/2014/10/27/why-should-choose-gradle/</id>
    <published>2014-10-27T13:00:54.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-为什么选择Gradle？"><a href="#1-为什么选择Gradle？" class="headerlink" title="1. 为什么选择Gradle？"></a>1. 为什么选择Gradle？</h3><p><img src="/images/post/why-should-choose-gradle.jpg" alt="为什么应该使用Gradle"></p><a id="more"></a><h3 id="2-简单入门"><a href="#2-简单入门" class="headerlink" title="2. 简单入门"></a>2. 简单入门</h3><h4 id="2-1-使用Intellij-Idea创建gradle项目"><a href="#2-1-使用Intellij-Idea创建gradle项目" class="headerlink" title="2.1 使用Intellij Idea创建gradle项目"></a>2.1 使用Intellij Idea创建gradle项目</h4><p>首先在Idea中启用Gradle支持：Settings-&gt;Plugins: Gradle</p><p>然后创建一个gradle项目或模块，会发现目录结构和maven的很像，其中build.gradle是gradle的配置文件，类似于maven中pom.xml文件，以下是build.gradle的简单示例：</p><pre><code>apply plugin: &apos;java&apos;group = &apos;org.yousharp&apos;version = &apos;1.0-SNAPSHOT&apos;sourceCompatibility = 1.7targetCompatibility = 1.7repositories {    mavenCentral()    maven { url &quot;http://repo.maven.apache.org/maven2&quot; }}dependencies {    compile group: &apos;com.google.guava&apos;, name: &apos;guava&apos;, version:&apos;17.0&apos;    compile group: &apos;redis.clients&apos;, name: &apos;jedis&apos;, version:&apos;2.6.0&apos;    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version:&apos;4.11&apos;}</code></pre><p>插件(plugin)：是gradle的一种扩展，gradle预定义了很多插件，常见的如java插件、war插件等；java插件中定义了一些有用的task，如编译源码、执行单元测试、生成jar包、约定默认的目录结构等；<br>repositories定义仓库，dependencies定义项目的依赖，比maven的XML定义更简洁；</p><p>那么，如何编译、测试，以及运行gradle的项目呢？</p><p>刚才说到java插件预定义了很多task，其中就包括编译、测试、生成jar包等task，可以在命令行通过<code>$ gradle tasks</code>查看项目已定义的所有task以及含义，如java插件中常用的task有：</p><pre><code>+ assemble: 编译+ build：编译并执行测试+ clean：删除build目录+ jar： 生成jar包+ test：执行单元测试</code></pre><h4 id="2-2-将Java项目从maven迁移到gradle"><a href="#2-2-将Java项目从maven迁移到gradle" class="headerlink" title="2.2 将Java项目从maven迁移到gradle"></a>2.2 将Java项目从maven迁移到gradle</h4><p>如何将一个java项目从maven迁移到gradle呢？gradle集成了一个很方便的插件：Build Init Plugin，使用这个插件可以很方便地创建一个新的gradle项目，或者将其它类型的项目转换为gradle项目。</p><p>要将maven项目转换为gradle项目，只需要在项目的pom文件所在的目录下执行以下命令：</p><pre><code>$ gradle init --type pom</code></pre><p>上面的命令会根据pom文件自动生成gradle项目所需的文件和配置，然后以gradle项目重新导入即可。</p><p>关于gradle的简介就到这里，感兴趣的朋友可以参考<a href="http://gradle.org/docs/current/userguide/userguide.html" target="_blank" rel="external">gradle-userguide</a>以及<a href="http://www.gradle.org/books" target="_blank" rel="external">Gradle in Action</a>。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="http://gradle.org/docs/current/userguide/userguide.html" target="_blank" rel="external">gradle-userguide</a></li><li><a href="http://www.gradle.org/books" target="_blank" rel="external">Gradle in Action</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-为什么选择Gradle？&quot;&gt;&lt;a href=&quot;#1-为什么选择Gradle？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么选择Gradle？&quot;&gt;&lt;/a&gt;1. 为什么选择Gradle？&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/post/why-should-choose-gradle.jpg&quot; alt=&quot;为什么应该使用Gradle&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="gradle" scheme="http://nkcoder.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Redis-Toolkit--Java实现的redis工具(一)</title>
    <link href="http://nkcoder.github.io/2014/10/24/redis-tookit-implement-in-java-1/"/>
    <id>http://nkcoder.github.io/2014/10/24/redis-tookit-implement-in-java-1/</id>
    <published>2014-10-24T03:21:49.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>redis作者提供了redis-trib.rb工具，用来与redis cluster进行交互，该工具使用ruby实现；对该工具提供的主要功能，我在redis的java客户端jedis的基础上进行了对应的实现，希望给同样使用java与redis交互的朋友一些参考。</p><a id="more"></a><h2 id="1-创建集群"><a href="#1-创建集群" class="headerlink" title="1. 创建集群"></a>1. 创建集群</h2><p>使用作者在<a href="http://redis.io/topics/cluster-tutorial" target="_blank" rel="external">cluster-tutorial</a>上的示例，即在localhost的7000、7001、7002、7003、7004、7005启动6个redis实例，且都启用cluster模式，使用redis-trib创建集群的命令为：</p><pre><code>./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</code></pre><p>上述命令表示使用这6个实例创建集群，3主3从；</p><p>实际上，这一条命令，如果拆分为原生的redis命令来实现，则主要有以下4个过程：</p><pre><code>1. 使用`CLUSTER MEET`命令将所有节点构建成一个集群；2. 使用`CLUSTER REPLICATE`命令设置master/slave结构；3. 使用`CLUSTER SETSLOTS`命令将16384个slot分配到集群中的master中；4. 等待集群的状态变为OK；</code></pre><p>对于以上原生命令，jedis都是支持的，所以根据以上4个步骤，使用jedis创建集群就不难了；<br>在redis-tookit中整个创建的过程被封装到Create#create()方法中了，示例代码：</p><pre><code>/* 构建一个3主3从的集群 */ArrayListMultimap&lt;HostAndPort, HostAndPort&gt; clusterNodes = ArrayListMultimap.create();clusterNodes.put(HostAndPort.fromString(&quot;127.0.0.1:7000&quot;), HostAndPort.fromString(&quot;127.0.0.1:7001&quot;));clusterNodes.put(HostAndPort.fromString(&quot;127.0.0.1:7002&quot;), HostAndPort.fromString(&quot;127.0.0.1:7003&quot;));clusterNodes.put(HostAndPort.fromString(&quot;127.0.0.1:7004&quot;), HostAndPort.fromString(&quot;127.0.0.1:7005&quot;));Create.create(clusterNodes);</code></pre><h2 id="2-数据迁移-reshard"><a href="#2-数据迁移-reshard" class="headerlink" title="2. 数据迁移(reshard)"></a>2. 数据迁移(reshard)</h2><p>在beta8之前，使用redis-trib.rb做reshard时，仅支持交互时模式，beta8之后，开始支持非交互式模式。比如，从源节点38807bd0262d99f205ebd0eb3e483cc09e927731上迁移100个slot到目标节点47ef6c293bb3f9763d421f56c63f00cf06ef5b3f的非交互式命令为：</p><pre><code>redis-trib.rb reshard --from 38807bd0262d99f205ebd0eb3e483cc09e927731 --to 47ef6c293bb3f9763d421f56c63f00cf06ef5b3f --slots 100 --yes 127.0.0.1:7000</code></pre><p>那么，使用redis的原生命令如何完成数据的reshard呢？其实，在数据reshard时，slot是逐个迁移的，redis迁移一个slot的步骤为：</p><pre><code>1. 对目标节点发送`CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_node_id&gt;`命令，表示目标节点将从源节点迁移slot；2. 对源节点发送`CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_node_id&gt;`命令，表示源节点将向目标节点迁移slot；3. 对源节点发送`CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;`命令，表示从slot中取出count个key/value对的key；4. 对源节点发送`CLUSTER MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;`命令，表示将key迁移到目标节点，对步骤3中的每个key都会执行该命令；5. 重复执行步骤3和4，直到该slot中所有的key都被迁移完毕；6. 向集群中的任一节点发送`CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_node_id&gt;`，表示告诉集群，将该slot分配给目标节点；7. 等待集群的状态变为OK；</code></pre><p>使用java实现时，也是通过jedis调用redis原生命令，根据以上步骤来实现的。在redis-toolkit中，封装了两个方法，Reshard#migrateSlots()表示迁移一个slot，Reshard#migrate()表示批量迁移，批量迁移时，从源节点的slot索引，从低到高依次迁移，使用示例：</p><pre><code>/** 将slot 9189从节点7002迁移到节点7006 **/HostAndPort srcNodeInfo = HostAndPort.fromString(&quot;10.7.40.49:7002&quot;);HostAndPort destNodeInfo = HostAndPort.fromString(&quot;10.7.40.49:7006&quot;);Reshard.migrateSlots(srcNodeInfo, destNodeInfo, 9189);/** 从节点7000迁移100个slot到节点7004 **/HostAndPort srcNodeInfo = HostAndPort.fromString(&quot;10.7.40.49:7000&quot;);HostAndPort destNodeInfo = HostAndPort.fromString(&quot;10.7.40.49:7004&quot;);Reshard.migrate(srcNodeInfo, destNodeInfo, 100);</code></pre><h2 id="3-节点的增加-删除"><a href="#3-节点的增加-删除" class="headerlink" title="3. 节点的增加/删除"></a>3. 节点的增加/删除</h2><h3 id="3-1-增加节点"><a href="#3-1-增加节点" class="headerlink" title="3.1 增加节点"></a>3.1 增加节点</h3><p>无论要添加的是master节点还是slave节点，首先都需要将该节点加入到集群中，然后，如果是master节点，则迁移一部分数据到该节点上，如果是slave节点，则使该节点成为其master节点的slave。</p><p>通过redis-trib.rb工具，增加一个master节点命令为：</p><pre><code>./redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000</code></pre><p>然后通过<code>redis-trib.rb reshard</code>命令迁移数据到新节点7006上；</p><p>增加一个slave节点，redis-trib.rb提供了两种方式：</p><pre><code>./redis-trib.rb add-node --slave 127.0.0.1:7006 127.0.0.1:7000./redis-trib.rb add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006</code></pre><p>第一种方式将该slave节点随机分配给集群中具有最少slave的master节点，第二种方式是将slave节点分配给指定的master节点；更通用的方式，则是先将该节点作为空的master节点加入集群，然后通过<code>CLUSTER REPLICATE</code>命令使其成为一个master节点的slave。</p><p>对redis集群进行扩容时，可分为垂直扩容和水平扩容，垂直扩容即通过<code>CONFIG SET</code>命令在线修改redis实例的<code>maxmemory</code>的大小，水平扩容即增加新的master节点，然后迁移一部分数据到新的节点上。</p><p>向集群中添加一个master节点，则相当于水平扩容，给集群中的一个节点增加一个slave节点，则不是扩容。</p><p>所以，增加节点的步骤为：</p><pre><code>- 使用`CLUSTER MEET`命令将节点加入到当前集群；- 如果要加入的是master节点，则迁移slot到新节点上(参考第2步的“数据迁移”)；- 如果要加入的是slave节点，则使用`CLUSTER REPLICATE`命令建立master/slave关系；</code></pre><p>redis-tookit中提供的增加节点的方法为Manage#addNewNode()，支持增加master节点和slave节点；如果增加的是master节点，则会迁移数据到新的master节点，为了迁移操作更均衡，根据每个master节点上的slot数等比例地迁移，即从slot更多的节点上迁移更多的slot，从slot少的节点上迁移更少的slot，使用示例：</p><pre><code>/** 向集群中增加一个master节点7006 **/HostAndPort clusterNodeInfo = HostAndPort.fromString(&quot;10.7.40.49:7000&quot;);HostAndPort newMaster = HostAndPort.fromString(&quot;10.7.40.49:7006&quot;);Manage.addNewNode(clusterNodeInfo, newMaster, null);/** 给集群中增加一个slave节点8001，作为master节点7002的slave **/HostAndPort clusterNodeInfo = HostAndPort.fromString(&quot;10.7.40.49:7000&quot;);HostAndPort master = HostAndPort.fromString(&quot;10.7.40.49:7002&quot;);HostAndPort newSlave = HostAndPort.fromString(&quot;10.7.40.49:8001&quot;);Manage.addNewNode(clusterNodeInfo, newSlave, master);</code></pre><h2 id="3-2-删除节点"><a href="#3-2-删除节点" class="headerlink" title="3.2 删除节点"></a>3.2 删除节点</h2><p>从集群中删除一个节点，如果要删除的是slave节点，直接将节点从集群中剔除即可，如果要删除的是master节点，则需要先将所有的slot迁移走，然后删除节点。</p><p>redis-trib.rb工具提供的删除一个节点的命令为：</p><pre><code>./redis-trib del-node 127.0.0.1:7000 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</code></pre><p>删除节点，就是调用<code>CLUSTER FORGET</code>命令，将要删除的节点从当前集群中踢掉，需要注意的是：</p><pre><code>- 需要对集群中的每一个节点(无论是master还是slave)都调用`CLUSTER FORGET`来“忘记”该节点，因为如果集群中有一个节点还“认识”待删除的节点，则通过消息，不久集群中的所有节点都”认识“待删除的节点了；- 一个slave节点不能”忘记“它的master节点；- 一个节点不能”忘记“它自己；</code></pre><p>所以，删除一个节点的步骤为：</p><pre><code>- 如果节点是master节点，先将节点上的slot迁移，然后从集群中删除该master节点以及它的所有slave节点；- 如果节点是slave节点，则直接从集群中删除即可；</code></pre><p>redis-tookit中提供了删除master节点和slave节点的方法，删除master节点时，需要迁移数据，当前的实现是将待删除的master节点上的所有slot平均分配给集群中的其它master；使用示例：</p><pre><code>/* 从集群中删除一个节点，删除时，集群会判断待删除的节点是master还是slave */HostAndPort oneNode = HostAndPort.fromString(&quot;10.7.40.49:7000&quot;);HostAndPort nodeToDelete = HostAndPort.fromString(&quot;10.7.40.49:7006&quot;);Manage.removeNode(oneNode, nodeToDelete);</code></pre><p>redis-tookit代码在<a href="https://github.com/nkcoder/redis-toolkit" target="_blank" rel="external">https://github.com/nkcoder/redis-toolkit</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://redis.io/topics/cluster-tutorial" target="_blank" rel="external">Redis cluster tutorial</a></li><li><a href="http://book.douban.com/subject/25900156/" target="_blank" rel="external">Redis设计与实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis作者提供了redis-trib.rb工具，用来与redis cluster进行交互，该工具使用ruby实现；对该工具提供的主要功能，我在redis的java客户端jedis的基础上进行了对应的实现，希望给同样使用java与redis交互的朋友一些参考。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="redis" scheme="http://nkcoder.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 3.0.0 RC1的发布和更新</title>
    <link href="http://nkcoder.github.io/2014/10/21/redis-3-dot-0-0-rc1-released-and-update/"/>
    <id>http://nkcoder.github.io/2014/10/21/redis-3-dot-0-0-rc1-released-and-update/</id>
    <published>2014-10-20T16:04:26.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 3.0.0 RC1在10月9日发布，这个版本具有重要的意义，说明Redis Cluster已经非常稳定了。</p><p>我们来简单梳理一下RC1中的重要更新。</p><a id="more"></a><h2 id="1-Redis-3-0-0-RC1的release-notes"><a href="#1-Redis-3-0-0-RC1的release-notes" class="headerlink" title="1. Redis 3.0.0 RC1的release notes"></a>1. Redis 3.0.0 RC1的<a href="https://raw.githubusercontent.com/antirez/redis/3.0/00-RELEASENOTES" target="_blank" rel="external">release notes</a></h2><h3 id="1-1-常规更新"><a href="#1-1-常规更新" class="headerlink" title="1.1 常规更新"></a>1.1 常规更新</h3><ul><li>[修复] 对一些简单问题的修复汇总，修复列表可以参考<a href="https://github.com/antirez/redis/pull/1906" target="_blank" rel="external">issue #1906</a>，修复的主要内容有：<ul><li>将sds的size从2GB增加到4GB(即使用<code>unsigned int</code>替换<code>int</code>，其它不变)；</li><li>如果redis在前台运行，Ctrl-C会将server优雅地<code>SHUTDOWN</code>，而不是仅仅将server进程kill掉；</li><li>Sentinel支持<code>INFO ALL</code>命令；</li><li>使用<code>redis-benchmark</code>命令测试时，新增<code>-a</code>参数用于验证；</li><li>对代码的优化、重构等。</li></ul></li><li>[修复] <code>SAVE</code> 命令不会蔓延到AOF文件和Slave实例；</li><li>[修复] 当hash table处于异常状态时，限制<code>SCAN</code>操作的延迟(当数据库正在rehash时，可用的bucket数量很少)；</li><li>[新增] redis在启动时可以加载被截断的AOF文件，而不需要先执行<code>redis-check-aof</code>工具，该功能可以在<code>redis.conf</code>中配置：<code>aof-load-truncated yes</code>；</li><li>[新增] <code>INCR</code>：尽可能地在原地修改自增键，可以得到更好的性能；</li></ul><h3 id="1-2-Cluster更新"><a href="#1-2-Cluster更新" class="headerlink" title="1.2 Cluster更新"></a>1.2 Cluster更新</h3><ul><li>[修复] 即使连接断开，仍要求返回ping_sent时间；</li><li>[修复] 判断是否处于少数节点构成的网络时，修复判断逻辑；</li><li>[修复] 修复已加入集群的节点间的gossip通信逻辑；</li><li>[新增] Redis Cluster运行稳定且通过了详尽的测试，因此从beta版晋升为stable版；</li><li>[新增] 当slot没有被完全覆盖时，集群仍然可用；</li><li>[新增] 当failover过程停顿的时候，slave会打印更详细的日志，包括原因；</li></ul><h3 id="1-3-Sentinel更新"><a href="#1-3-Sentinel更新" class="headerlink" title="1.3 Sentinel更新"></a>1.3 Sentinel更新</h3><ul><li>[修复] 修复严重bug：在计算大多数(majority)节点时，之前的实现方式是错误的，而specification上说的是对的。大多数节点是针对master的所有sentinel，而不管它当前的状态。</li><li>[修复] 修复hiredis库中的一个内存泄露问题：当一个被监控的实例或者另一个sentinel不可用的时候会导致内存泄露，每一次重连都会泄露少量的内存，但是如果持续累积，将会导致大量的内存泄露；</li></ul><h2 id="2-redis-conf更新"><a href="#2-redis-conf更新" class="headerlink" title="2. redis.conf更新"></a>2. redis.conf更新</h2><p>将redis-3.0.0-beta8中的redis.conf和redis-3.0.0-rc1中的redis.conf通过diff查看两者的区别。</p><pre><code># diff redis-b8.conf redis-rc1.conf &gt; diff.conf</code></pre><p>对比后发现，大部分的更新都是针对表述上的，功能上的更新主要有三点：</p><ul><li><code>unixsocketperm 700</code>: unixsocketperm的权限由755修改为700；</li><li><code>aof-load-truncated yes</code>: redis在启动的时候可以加载被截断的AOF文件，默认启用；</li><li><code>cluster-require-full-coverage yes</code>: rc1之前，如果至少有一个slot没有被节点覆盖，则整个集群不可用；现在，启用该配置，即使有部分slot没有被覆盖，被覆盖到的那部分slot构成的子集群仍然可用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 3.0.0 RC1在10月9日发布，这个版本具有重要的意义，说明Redis Cluster已经非常稳定了。&lt;/p&gt;
&lt;p&gt;我们来简单梳理一下RC1中的重要更新。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="redis" scheme="http://nkcoder.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>阻塞队列之ArrayBlockingQueue</title>
    <link href="http://nkcoder.github.io/2014/09/05/blockqueue-arrayblockingqueue/"/>
    <id>http://nkcoder.github.io/2014/09/05/blockqueue-arrayblockingqueue/</id>
    <published>2014-09-05T15:06:18.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>ArrayBlockingQueue是一个有界阻塞队列，队列根据FIFO的顺序组织元素，从队列的头部取元素，新的元素被插入到队列的尾部。插入元素时，如果队列满，线程阻塞(也有不阻塞的方法)，取元素时，如果队列为空，线程阻塞(有不阻塞的方法)。</p><a id="more"></a><p>内部使用固定大小的数组实现，在构造ArrayBlockingQueue对象时，指定数组的容量compacity，之后该容量不能被修改。</p><p>支持公平策略fairness，根据FIFO的顺序选择等待的线程；该参数在构造对象的时候开启，默认禁用；启用fairness会降低吞吐量，但是可以避免线程饥饿。</p><p>同步：内部使用ReentrantLock和two-condition算法实现</p><pre><code>/** Main lock guarding all access */final ReentrantLock lock;/** Condition for waiting takes */private final Condition notEmpty;/** Condition for waiting puts */private final Condition notFull;</code></pre><blockquote><p>notEmpty表示队列不为空，可以插入元素；notFull表示队列没有满，可以取出元素。</p></blockquote><p>构造函数：</p><pre><code>ArrayBlockingQueue(int capacity)ArrayBlockingQueue(int capacity, boolean fair)</code></pre><p>主要方法及区别：</p><pre><code>boolean add(E e)boolean offer(E e)boolean offer(E e, long timeout, TimeUnit unit)void put(E e)</code></pre><blockquote><p>add()插入元素，如果队列不满，则立即返回true，否则抛出IllegalStateException；offer()也是插入元素，在队列满的时候，返回false，也可以指定超时，超时后，队列还是满的，则返回false；put()插入元素，队列满时等待，直到队列不满或者被中断。</p></blockquote><pre><code>E take()E poll(long timeout, TimeUnit unit)E poll()</code></pre><blockquote><p>take()表示从队列取元素，如果队列为空，则等待，直到队列不空或者被中断；poll()取出元素，如果队列为空，返回null，可以指定超时，如果超时后队列还是为空，则返回null。</p></blockquote><p>注意：合理地处理这些方法抛出的异常，否则线程就挂了，线程池也就崩溃了。比如add(),take(), put()等都可能会被中断，从而抛出中断异常，poll()可能返回null，如果将返回结果赋值给基本类型的变量，会抛出空指针异常。对线程中可能出现的异常，一般有两种处理方式：1)捕获所有的异常；2)给线程注册一个UncaughtExceptionHandler；</p><p>参考：</p><ul><li><a href="http://fuseyism.com/classpath/doc/java/util/concurrent/ArrayBlockingQueue-source.html" target="_blank" rel="external">ArrayBlockingQueue</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ArrayBlockingQueue是一个有界阻塞队列，队列根据FIFO的顺序组织元素，从队列的头部取元素，新的元素被插入到队列的尾部。插入元素时，如果队列满，线程阻塞(也有不阻塞的方法)，取元素时，如果队列为空，线程阻塞(有不阻塞的方法)。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="java" scheme="http://nkcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Quartz教程八--SchedulerListener</title>
    <link href="http://nkcoder.github.io/2014/08/24/quartz-tutorial-08-scheduler-listener/"/>
    <id>http://nkcoder.github.io/2014/08/24/quartz-tutorial-08-scheduler-listener/</id>
    <published>2014-08-24T12:45:27.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>SchedulerListener与TriggerListener、JobListener类似，但它仅接收来自Scheduler自身的消息，而不一定是某个具体的trigger或job的消息。</p><p>scheduler相关的消息包括：job/trigger的增加、job/trigger的删除、scheduler内部发生的严重错误以及scheduler关闭的消息等；</p><a id="more"></a><p>org.quartz.SchedulerListener接口：</p><pre><code>public interface SchedulerListener {    public void jobScheduled(Trigger trigger);    public void jobUnscheduled(String triggerName, String triggerGroup);    public void triggerFinalized(Trigger trigger);    public void triggersPaused(String triggerName, String triggerGroup);    public void triggersResumed(String triggerName, String triggerGroup);    public void jobsPaused(String jobName, String jobGroup);    public void jobsResumed(String jobName, String jobGroup);    public void schedulerError(String msg, SchedulerException cause);    public void schedulerStarted();    public void schedulerInStandbyMode();    public void schedulerShutdown();    public void schedulingDataCleared();}</code></pre><p>SchedulerListener也是注册到scheduler的ListenerManager上的，任何实现了org.quartz.SchedulerListener接口的对象都可以是SchedulerListener(译者注：SchedulerListener与JobListener/TriggerListener一样，也可以继承SchedulerListenerSupport抽象类，重写感兴趣的方法即可)。</p><p>添加一个SchedulerListener：</p><pre><code>scheduler.getListenerManager().addSchedulerListener(mySchedListener);</code></pre><p>删除一个SchedulerListener：</p><pre><code>scheduler.getListenerManager().removeSchedulerListener(mySchedListener);</code></pre><ul><li><a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-08" target="_blank" rel="external">原文链接</a></li><li>本系列教程由<a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials" target="_blank" rel="external">quartz-2.2.x官方文档</a>翻译、整理而来，希望给同样对quartz感兴趣的朋友一些参考和帮助，有任何不当或错误之处，欢迎指正；有兴趣研究源码的同学，可以参考我对<a href="https://github.com/nkcoder/quartz-explained" target="_blank" rel="external">quartz-core源码的注释(进行中)</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SchedulerListener与TriggerListener、JobListener类似，但它仅接收来自Scheduler自身的消息，而不一定是某个具体的trigger或job的消息。&lt;/p&gt;
&lt;p&gt;scheduler相关的消息包括：job/trigger的增加、job/trigger的删除、scheduler内部发生的严重错误以及scheduler关闭的消息等；&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="quartz" scheme="http://nkcoder.github.io/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>Quartz教程七--TriggerListener和JobListener</title>
    <link href="http://nkcoder.github.io/2014/08/17/quartz-tutorial-07-listener/"/>
    <id>http://nkcoder.github.io/2014/08/17/quartz-tutorial-07-listener/</id>
    <published>2014-08-17T12:46:50.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>listener是一个对象，用于监听scheduler中发生的事件，然后执行相应的操作；你可能已经猜到了，<em>TriggerListeners</em>接受与trigger相关的事件，<em>JobListeners</em>接受与jobs相关的事件。</p><p>trigger相关的事件包括：trigger的触发、trigger错过触发(mis-fire)以及trigger的完成(即trigger触发的job执行完成)。</p><a id="more"></a><p>org.quartz.TriggerListener接口</p><pre><code>public interface TriggerListener {    public String getName();    public void triggerFired(Trigger trigger, JobExecutionContext context);    public boolean vetoJobExecution(Trigger trigger, JobExecutionContext context);    public void triggerMisfired(Trigger trigger);    public void triggerComplete(Trigger trigger, JobExecutionContext context,            int triggerInstructionCode);}</code></pre><p>job相关的事件包括：job即将执行的通知以及job执行完毕的通知。</p><p>org.quartz.JobListener接口：</p><pre><code>public interface JobListener {    public String getName();    public void jobToBeExecuted(JobExecutionContext context);    public void jobExecutionVetoed(JobExecutionContext context);    public void jobWasExecuted(JobExecutionContext context,            JobExecutionException jobException);}</code></pre><h2 id="使用自定义的listener"><a href="#使用自定义的listener" class="headerlink" title="使用自定义的listener"></a>使用自定义的listener</h2><p>创建一个listener，只需要实现<em>org.quartz.TriggerListener</em>接口或者<em>org.quartz.JobListener </em>接口即可；然后在运行时将listener注册到scheduler上，并且需要给listener取个名称(因为listener需要通过其getName()方法广播它的名称)。</p><p>我们可以实现上面提到的接口，但更方便的方式是继承<em>JobListenerSupport</em>类或者<em>TriggerListenerSupport</em>类，只需重写需要的方法即可。</p><p>listener是注册到scheduler的<em>ListenerManager</em>上的，与listener一同注册的还有一个<em>Matcher</em>对象，该对象用于描述listener期望接收事件的job或trigger。</p><blockquote><p>listener是在运行的时候注册到scheduler上的，而且<strong>不会</strong>与job和trigger一样保存在JobStore中。因为listener一般是应用的一个集成点(integration point)，因此，应用每次运行的时候，listener都应该重新注册到scheduler上。</p></blockquote><p>给一个job添加JobListener：</p><pre><code>scheduler.getListenerManager().addJobListener(myJobListener, KeyMatcher.jobKeyEquals(new JobKey(&quot;myJobName&quot;, &quot;myJobGroup&quot;)));</code></pre><p>可以对matcher和key下的类进行静态导入，这样使得matcher的定义更加清晰：</p><pre><code>import static org.quartz.JobKey.*;import static org.quartz.impl.matchers.KeyMatcher.*;import static org.quartz.impl.matchers.GroupMatcher.*;import static org.quartz.impl.matchers.AndMatcher.*;import static org.quartz.impl.matchers.OrMatcher.*;import static org.quartz.impl.matchers.EverythingMatcher.*;...etc.</code></pre><p>静态导入后，上面的实例可以写成：</p><pre><code>scheduler.getListenerManager().addJobListener(myJobListener, jobKeyEquals(jobKey(&quot;myJobName&quot;, &quot;myJobGroup&quot;)));</code></pre><p>给一个group下的所有job添加一个JobListener：</p><pre><code>scheduler.getListenerManager().addJobListener(myJobListener, jobGroupEquals(&quot;myJobGroup&quot;));</code></pre><p>给两个group下的所有job添加一个JobListener：</p><pre><code>scheduler.getListenerManager().addJobListener(myJobListener, or(jobGroupEquals(&quot;myJobGroup&quot;), jobGroupEquals(&quot;yourGroup&quot;)));</code></pre><p>给所有的job添加一个JobListener：</p><pre><code>scheduler.getListenerManager().addJobListener(myJobListener, allJobs());</code></pre><p>TriggerListener的注册过程与JobListener类似。</p><p>Quartz的大部分用户都不使用listener，但如果应用需要对发生的事件感兴趣，当然可以让job显示通知应用，但显然listener更方便。</p><ul><li><a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-07" target="_blank" rel="external">原文链接</a></li><li>本系列教程由<a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials" target="_blank" rel="external">quartz-2.2.x官方文档</a>翻译、整理而来，希望给同样对quartz感兴趣的朋友一些参考和帮助，有任何不当或错误之处，欢迎指正；有兴趣研究源码的同学，可以参考<a href="https://github.com/nkcoder/quartz-explained" target="_blank" rel="external">我对quartz-core源码的注释(进行中)</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;listener是一个对象，用于监听scheduler中发生的事件，然后执行相应的操作；你可能已经猜到了，&lt;em&gt;TriggerListeners&lt;/em&gt;接受与trigger相关的事件，&lt;em&gt;JobListeners&lt;/em&gt;接受与jobs相关的事件。&lt;/p&gt;
&lt;p&gt;trigger相关的事件包括：trigger的触发、trigger错过触发(mis-fire)以及trigger的完成(即trigger触发的job执行完成)。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="quartz" scheme="http://nkcoder.github.io/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>Quartz教程六--CronTrigger</title>
    <link href="http://nkcoder.github.io/2014/08/02/quartz-tutorial-06-crontrigger/"/>
    <id>http://nkcoder.github.io/2014/08/02/quartz-tutorial-06-crontrigger/</id>
    <published>2014-08-02T13:44:44.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你需要的是基于日历表示法的调度，而不是基于指定间隔的简单调度，那么CronTrigger比SimpleTrigger更合适。</p><p>使用CronTrigger，你可以配置这样的调度：“每周五的中午”，或者“每个工作日的上午9:30”，或者“在一月的每个周一、周三和周五的上午9点到10点之间每隔5分钟”。</p><a id="more"></a><p>与SimpleTrigger一样，CronTrigger需要设置<em>startTime</em>属性，表示调度生效的时间，以及(可选的)<em>endTime</em>属性，表示调度的结束时间。</p><h2 id="Cron表达式"><a href="#Cron表达式" class="headerlink" title="Cron表达式"></a>Cron表达式</h2><p>Cron表达式用于配置CronTrigger的实例，它由7个字段组成，字段之间由空格分开，它们表示的含义如下：</p><pre><code>1. 秒 (Seconds)2. 分钟 (Minutes)3. 小时 (Hours)4. 日(一个月的一天) (Day-of-Month)5. 月份    (Month)6. 周(一周的一天) (Day-of-Week)7. 年份(可选的) (Year)</code></pre><p>一个完整的Cron表达式的例子如字符串：”0 0 12 ? * WED” - 表示“每周三的中午12:00:00”；</p><p>每一个字段可以包含范围或者列举。比如，上例中的<em>周</em>字段(即”WED“)可以被替换为：”MON-FRI”, “MON,WED,FRI”, 或者”MON-WED,SAT”。</p><p>通配符(<em>)表示该字段上每一个可取的值。因此，上例中</em>月<em>字段上的</em>表示“每个月”。<em>周</em>字段上的*表示“一周的每一天”。</p><p>所有的字段都有一些可取的值的集合。有些就很明显 - 比如，<em>秒</em>和<em>分钟</em>字段可以取0到59的整数，<em>小时</em>字段可以取0到23的整数，<em>日</em>字段(Day-of-Month)可以取1到31的整数，不过你需要注意指定的月份到底有多少天。<em>月</em>字段可以取0到11之间的整数，或者使用字符串表示：JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV 和 DEC。<em>周</em>字段(Days-of-Week)可以取的值为1到7(1表示Sunday)，或者使用字符串表示：SUN, MON, TUE, WED, THU, FRI and SAT。</p><p>字符‘/’表示增量。比如，<em>分钟</em>字段使用”0/15“，表示”在这个小时内，从0分钟开始，每隔15分钟“；如果<em>分钟</em>字段使用”3/20“，则表示”在这个小时内，从第3分钟开始，每隔20分钟“，这与在<em>分钟</em>字段使用“3,23,43”表示的含义是一样的。注意一个细节，“/35”的含义并不是“每隔35分钟”，而是“在这个小时内，从第0分钟开始，每隔35分钟”。</p><p>字符’?’可以用于<em>日</em>字段和<em>周</em>字段，表示“没有具体的值“。它主要用于在这两个字段的某一个中指定某个值，更好的理解请参考下面的示例（以及CrontTrigger的JavaDoc）。</p><p>字符’L’可以用于<em>日</em>字段和<em>周</em>字段，它是<em>last</em>的缩写，但是用于这两个字段时，含义并不相同。比如，“L”用于<em>日</em>子段，表示“这个月的最后一天” - 即一月的第31天，非闰年二月的第28天。如果‘L’单独用于<em>周</em>字段，它的含义就是“7”或者“SAT”。但是，如果‘L’用于<em>周</em>字段时，前面还有一个值，则表示“这个月的最后一个周××” - 比如，“6L”或“FRIL”表示“这个月的最后一个周五”。我们也可以指定与这个月最后一天的偏移量，比如“L-3”表示与这个月的最后一天相差3天。需要注意的是，如果使用选项‘L’，则不要使用列举和范围，否则结果将是不可预料的。</p><p>字符’W’表示离某一天最近的工作日（weekday）。例如，<em>日</em>字段上的值“15W”表示“离这个月的15号最近的工作日”。</p><p>字符’#’表示“这个月的第n个周××”。例如，在<em>周</em>字段上的“6#3”或“FRI#3”表示“这个月的3个周五”。</p><p>以下为一些表达式的例子及对应的含义 - 在org.quartz.CronExpression的JavaDoc有更多的描述。</p><h2 id="Cron表达式示例"><a href="#Cron表达式示例" class="headerlink" title="Cron表达式示例"></a>Cron表达式示例</h2><p>CronTrigger示例1 - 每隔5分钟执行一次：</p><pre><code>0 0/5 * * * ?</code></pre><p>CronTrigger示例2 - 每隔5分钟，且在该分钟的第10秒执行（如10:00:10 am, 10:05:10 am等）：</p><pre><code>10 0/5 * * * ?</code></pre><p>CronTrigger示例3 - 每周三和周五的10:30, 11:30, 12:30和13:30执行：</p><pre><code>0 30 10-13 ? * WED,FRI</code></pre><p>Crontrigger示例4 - 在每个月的第5天和第20天，上午8点到上午10点之间每隔半小时执行。注意：该trigger不会在上午10点执行，只在上午8:00, 8:30, 9:00和9:30执行：</p><pre><code>0 0/30 8-9 5,20 * ?</code></pre><p>提示一下，有些调度需求太复杂了，无法使用一个trigger表达 - 比如：“在上午9点和上午10点之间，每隔5分钟执行一次，且在下午1点到下午10点之间每隔20分钟执行一次”。应对这样的需求，可以创建两个trigger，注册到同一个job上即可。</p><h2 id="创建CronTrigger"><a href="#创建CronTrigger" class="headerlink" title="创建CronTrigger"></a>创建CronTrigger</h2><p>CronTrigger实例可以通过<em>TriggerBuilder</em>（配置主要属性）和<em>CronScheduleBuilder</em>（配置CronTrigger专有的属性）配置。为了以DSL风格使用这些builder，需要静态导入：</p><pre><code>import static org.quartz.TriggerBuilder.*;import static org.quartz.CronScheduleBuilder.*;import static org.quartz.DateBuilder.*:</code></pre><p>构建一个trigger，在每天的上午8点到下午5点之间每隔2分钟执行一次，如：</p><pre><code>trigger = newTrigger()    .withIdentity(&quot;trigger3&quot;, &quot;group1&quot;)    .withSchedule(cronSchedule(&quot;0 0/2 8-17 * * ?&quot;))    .forJob(&quot;myJob&quot;, &quot;group1&quot;)    .build();</code></pre><p>构建一个trigger，每天上午10:42执行：</p><pre><code>trigger = newTrigger()    .withIdentity(&quot;trigger3&quot;, &quot;group1&quot;)    .withSchedule(dailyAtHourAndMinute(10, 42))    .forJob(myJobKey)    .build();</code></pre><p>或者：</p><pre><code>trigger = newTrigger()    .withIdentity(&quot;trigger3&quot;, &quot;group1&quot;)    .withSchedule(cronSchedule(&quot;0 42 10 * * ?&quot;))    .forJob(myJobKey)    .build();</code></pre><p>构建一个trigger，在每周三的上午10:42执行，并配置TimeZone：</p><pre><code>trigger = newTrigger()    .withIdentity(&quot;trigger3&quot;, &quot;group1&quot;)    .withSchedule(weeklyOnDayAndHourAndMinute(DateBuilder.WEDNESDAY, 10, 42)        .inTimeZone(TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;)))    .forJob(myJobKey)    .build();</code></pre><p>或者：</p><pre><code>trigger = newTrigger()    .withIdentity(&quot;trigger3&quot;, &quot;group1&quot;)    .withSchedule(cronSchedule(&quot;0 42 10 ? * WED&quot;)        .inTimeZone(TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;)))    .forJob(myJobKey)    .build();</code></pre><h2 id="CronTriggter错过触发策略"><a href="#CronTriggter错过触发策略" class="headerlink" title="CronTriggter错过触发策略"></a>CronTriggter错过触发策略</h2><p>下面的这些策略用于告诉Quartz，如果CronTrigger错过触发时应该采取的处理方式。（关于错过触发的场景，在本教程的<a href="">Trigger介绍</a>部分以经介绍过）。这些策略值是定义在CronTrigger上的常量，包括：</p><pre><code>MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICYMISFIRE_INSTRUCTION_DO_NOTHINGMISFIRE_INSTRUCTION_FIRE_NOW</code></pre><p>所有的trigger都可以使用<em>Trigger.MISFIRE_INSTRUCTION_SMART_POLICY</em>策略，该策略也是所有trigger的默认策略。在CronTrigger中，’smart policy’策略其实就是<em>MISFIRE_INSTRUCTION_FIRE_NOW</em>. <em>CronTrigger.updateAfterMisfire()</em>的API文档中对该策略有更详细的解释。</p><p>在构造CronTrigger时，将错过触发策略作为调度的一部分进行配置（通过CronScheduleBuilder):</p><pre><code>trigger = newTrigger()    .withIdentity(&quot;trigger3&quot;, &quot;group1&quot;)    .withSchedule(cronSchedule(&quot;0 0/2 8-17 * * ?&quot;)        .withMisfireHandlingInstructionFireAndProceed())    .forJob(&quot;myJob&quot;, &quot;group1&quot;)    .build();</code></pre><ul><li><a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-06" target="_blank" rel="external">原文链接</a></li><li>本系列教程由<a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials" target="_blank" rel="external">quartz-2.2.x官方文档</a>翻译、整理而来，希望给同样对quartz感兴趣的朋友一些参考和帮助，有任何不当或错误之处，欢迎指正；有兴趣研究源码的同学，可以参考<a href="https://github.com/nkcoder/quartz-explained" target="_blank" rel="external">我对quartz-core源码的注释(进行中)</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你需要的是基于日历表示法的调度，而不是基于指定间隔的简单调度，那么CronTrigger比SimpleTrigger更合适。&lt;/p&gt;
&lt;p&gt;使用CronTrigger，你可以配置这样的调度：“每周五的中午”，或者“每个工作日的上午9:30”，或者“在一月的每个周一、周三和周五的上午9点到10点之间每隔5分钟”。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="quartz" scheme="http://nkcoder.github.io/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>Java的值传递</title>
    <link href="http://nkcoder.github.io/2014/07/26/java-pass-by-value/"/>
    <id>http://nkcoder.github.io/2014/07/26/java-pass-by-value/</id>
    <published>2014-07-26T15:53:27.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>java pass by value or reference</code>，我用这句话向google求助，第一条结果就是我想要的，StackOverflow上早有大神解决了我等菜鸟的困惑。<a href="http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value" target="_blank" rel="external">排名第一的回答</a>虽简短，但精辟，两个小例子非常准确地说明了问题的本质。我想，如果再配两幅小图，那就完美了，故作图如下。</p><a id="more"></a><p>简单地回答，Java中只有值传递，没有引用传递之说；对象以引用的形式传递，但引用本身是值传递的。当将一个对象传递给函数时，该对象的内存地址将按位复制给临时变量，即函数内的临时变量和函数外的变量中都是对象的地址，都指向对象在内存中的位置，对这两个引用本身的改变是相互独立的，但通过引用去修改引用的对象则是相互影响的，因为修改的是同一个对象。</p><p>StackOverflow上作者的例子太经典了，这里还是借用一下，这里仅配图：</p><pre><code>Dog aDog = new Dog(&quot;Max&quot;);foo(aDog);aDog.getName().equals(&quot;Max&quot;); // truepublic void foo(Dog d) {    d.getName().equals(&quot;Max&quot;); // true    d = new Dog(&quot;Fifi&quot;);    d.getName().equals(&quot;Fifi&quot;); // true}</code></pre><p>在刚调用函数时：</p><p><img src="/images/post/value-ref-eg1-before-call.png" alt="value-ref-eg1-before-call"></p><p>执行<code>d = new Dog(&quot;Fifi&quot;);</code>后：</p><p><img src="/images/post/value-ref-eg1-after-call.png" alt="value-ref-eg1-after-call"></p><pre><code>Dog aDog = new Dog(&quot;Max&quot;);foo(aDog);aDog.getName().equals(&quot;Fifi&quot;); // truepublic void foo(Dog d) {    d.getName().equals(&quot;Max&quot;); // true    d.setName(&quot;Fifi&quot;);}</code></pre><p>在刚函数调用时：</p><p><img src="/images/post/value-ref-eg2-before-call.png" alt="value-ref-eg2-before-call"></p><p>调用<code>d.getName(&quot;Fifi&quot;)</code>后：</p><p><img src="/images/post/value-ref-eg2-after-call.png" alt="value-ref-eg2-after-call"></p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value" target="_blank" rel="external">Is Java “pass-by-reference” or “pass-by-value”?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;java pass by value or reference&lt;/code&gt;，我用这句话向google求助，第一条结果就是我想要的，StackOverflow上早有大神解决了我等菜鸟的困惑。&lt;a href=&quot;http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;排名第一的回答&lt;/a&gt;虽简短，但精辟，两个小例子非常准确地说明了问题的本质。我想，如果再配两幅小图，那就完美了，故作图如下。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="java" scheme="http://nkcoder.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Quartz教程五--SimpleTrigger</title>
    <link href="http://nkcoder.github.io/2014/07/23/quartz-tutorial-05-simple-trigger-intro/"/>
    <id>http://nkcoder.github.io/2014/07/23/quartz-tutorial-05-simple-trigger-intro/</id>
    <published>2014-07-23T00:08:19.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>SimpleTrigger</em>可以满足的调度需求是：在具体的时间点执行一次，或者在具体的时间点执行，并且以指定的间隔重复执行若干次。比如，你有一个trigger，你可以设置它在2015年1月13日的上午11:23:54准时触发，或者在这个时间点触发，并且每隔2秒触发一次，一共重复5次。</p><p>根据描述，你可能已经发现了，<em>SimpleTrigger</em>的属性包括：开始时间、结束时间、重复次数以及重复的间隔。这些属性的含义与你所期望的是一致的，只是关于结束时间有一些地方需要注意。</p><a id="more"></a><p>重复次数，可以是0、正整数，以及常量<em>SimpleTrigger.REPEAT_INDEFINITELY</em>。重复的间隔，必须是0，或者long型的正数，表示毫秒。注意，如果重复间隔为0，trigger将会以重复次数并发执行(或者以scheduler可以处理的近似并发数)。</p><p>如果你还不熟悉<em>DateBuilder</em>，了解后你会发现使用它可以非常方便地构造基于开始时间(或终止时间)的调度策略。</p><p>endTime属性的值会覆盖设置重复次数的属性值；比如，你可以创建一个trigger，在终止时间之前每隔10秒执行一次，你不需要去计算在开始时间和终止时间之间的重复次数，只需要设置终止时间并将重复次数设置为<em>REPEAT_INDEFINITELY</em>(当然，你也可以将重复次数设置为一个很大的值，并保证该值比trigger在终止时间之前实际触发的次数要大即可)。</p><p>SimpleTrigger实例通过<em>TriggerBuilder</em>设置主要的属性，通过<em>SimpleScheduleBuilder</em>设置与SimpleTrigger相关的属性。要使用这些builder的静态方法，需要静态导入：</p><pre><code>import static org.quartz.TriggerBuilder.*;import static org.quartz.SimpleScheduleBuilder.*;import static org.quartz.DateBuilder.*:</code></pre><p>下面的例子，是基于简单调度(simple schedule)创建的trigger。建议都看一下，因为每个例子都包含一个不同的实现点：</p><p>指定时间开始触发，不重复：</p><pre><code>SimpleTrigger trigger = (SimpleTrigger) newTrigger()    .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)    .startAt(myStartTime)                     // some Date    .forJob(&quot;job1&quot;, &quot;group1&quot;)                 // identify job with name, group strings    .build();</code></pre><p>指定时间触发，每隔10秒执行一次，重复10次：</p><pre><code>trigger = newTrigger()    .withIdentity(&quot;trigger3&quot;, &quot;group1&quot;)    .startAt(myTimeToStartFiring)  // if a start time is not given (if this line were omitted), &quot;now&quot; is implied    .withSchedule(simpleSchedule()        .withIntervalInSeconds(10)        .withRepeatCount(10)) // note that 10 repeats will give a total of 11 firings    .forJob(myJob) // identify job with handle to its JobDetail itself                       .build();</code></pre><p>5分钟以后开始触发，仅执行一次：</p><pre><code>trigger = (SimpleTrigger) newTrigger()    .withIdentity(&quot;trigger5&quot;, &quot;group1&quot;)    .startAt(futureDate(5, IntervalUnit.MINUTE)) // use DateBuilder to create a date in the future    .forJob(myJobKey) // identify job with its JobKey    .build();</code></pre><p>立即触发，每个5分钟执行一次，直到22:00：</p><pre><code>trigger = newTrigger()    .withIdentity(&quot;trigger7&quot;, &quot;group1&quot;)    .withSchedule(simpleSchedule()        .withIntervalInMinutes(5)        .repeatForever())    .endAt(dateOf(22, 0, 0))    .build();</code></pre><p>在下一小时整点触发，每个2小时执行一次，一直重复：</p><pre><code>trigger = newTrigger()    .withIdentity(&quot;trigger8&quot;) // because group is not specified, &quot;trigger8&quot; will be in the default group    .startAt(evenHourDate(null)) // get the next even-hour (minutes and seconds zero (&quot;00:00&quot;))    .withSchedule(simpleSchedule()        .withIntervalInHours(2)        .repeatForever())    // note that in this example, &apos;forJob(..)&apos; is not called which is valid    // if the trigger is passed to the scheduler along with the job      .build();scheduler.scheduleJob(trigger, job);</code></pre><p>请查阅<em>TriggerBuilder</em>和<em>SimpleScheduleBuilder</em>提供的方法，以便对上述示例中未提到的选项有所了解。</p><blockquote><p>TriggerBuilder(以及Quartz的其它builder)会为那些没有被显式设置的属性选择合理的默认值。比如：如果你没有调用<em>withIdentity(..)</em>方法，TriggerBuilder会为trigger生成一个随机的名称；如果没有调用<em>startAt(..)</em>方法，则默认使用当前时间，即trigger立即生效。</p></blockquote><h2 id="SimpleTrigger-Misfire策略"><a href="#SimpleTrigger-Misfire策略" class="headerlink" title="SimpleTrigger Misfire策略"></a>SimpleTrigger Misfire策略</h2><p>SimpleTrigger有几个misfire相关的策略，告诉quartz当misfire发生的时候应该如何处理。(Misfire策略参考<em><a href="http://nkcoder.github.io/blog/20140716/quartz-tutorial-04-trigger/">教程四：Trigger介绍</a></em>)。这些策略以常量的形式在SimpleTrigger中定义(JavaDoc中介绍了它们的功能)。这些策略包括：</p><p>SimpleTrigger的Misfire策略常量：</p><pre><code>MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICYMISFIRE_INSTRUCTION_FIRE_NOWMISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNTMISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNTMISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNTMISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_EXISTING_COUNT</code></pre><p>回顾一下，所有的trigger都有一个<em>Trigger.MISFIRE_INSTRUCTION_SMART_POLICY</em>策略可以使用，该策略也是所有trigger的默认策略。</p><p>如果使用<em>smart policy</em>，SimpleTrigger会根据实例的配置及状态，在所有MISFIRE策略中动态选择一种Misfire策略。<em>SimpleTrigger.updateAfterMisfire()</em>的JavaDoc中解释了该动态行为的具体细节。</p><p>在使用SimpleTrigger构造trigger时，misfire策略作为基本调度(simple schedule)的一部分进行配置(通过SimpleSchedulerBuilder设置)：</p><pre><code>trigger = newTrigger()    .withIdentity(&quot;trigger7&quot;, &quot;group1&quot;)    .withSchedule(simpleSchedule()        .withIntervalInMinutes(5)        .repeatForever()        .withMisfireHandlingInstructionNextWithExistingCount())    .build();</code></pre><ul><li><a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-05" target="_blank" rel="external">原文链接</a></li><li>本系列教程由<a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials" target="_blank" rel="external">quartz-2.2.x官方文档</a>翻译、整理而来，希望给同样对quartz感兴趣的朋友一些参考和帮助，有任何不当或错误之处，欢迎指正；有兴趣研究源码的同学，可以参考<a href="https://github.com/nkcoder/quartz-explained" target="_blank" rel="external">我对quartz-core源码的注释(进行中)</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;SimpleTrigger&lt;/em&gt;可以满足的调度需求是：在具体的时间点执行一次，或者在具体的时间点执行，并且以指定的间隔重复执行若干次。比如，你有一个trigger，你可以设置它在2015年1月13日的上午11:23:54准时触发，或者在这个时间点触发，并且每隔2秒触发一次，一共重复5次。&lt;/p&gt;
&lt;p&gt;根据描述，你可能已经发现了，&lt;em&gt;SimpleTrigger&lt;/em&gt;的属性包括：开始时间、结束时间、重复次数以及重复的间隔。这些属性的含义与你所期望的是一致的，只是关于结束时间有一些地方需要注意。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="quartz" scheme="http://nkcoder.github.io/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>Quartz教程四--Trigger介绍</title>
    <link href="http://nkcoder.github.io/2014/07/16/quartz-tutorial-04-trigger/"/>
    <id>http://nkcoder.github.io/2014/07/16/quartz-tutorial-04-trigger/</id>
    <published>2014-07-16T12:51:37.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>与job一样，trigger也很容易使用，但是还有一些扩展选项需要理解，以便更好地使用quartz。trigger也有很多类型，可以根据实际需要来选择。</p><p>最常用的两种trigger会分别在<a href="">教程五：SimpleTriggers</a>和<a href="">教程六：CronTrigger</a>中讲到；</p><a id="more"></a><h2 id="Trigger的公共属性"><a href="#Trigger的公共属性" class="headerlink" title="Trigger的公共属性"></a>Trigger的公共属性</h2><p>所有类型的trigger都有TriggerKey这个属性，表示trigger的身份；除此之外，trigger还有很多其它的公共属性。这些属性，在构建trigger的时候可以通过TriggerBuilder设置。</p><p>trigger的公共属性有：</p><ul><li><p><code>jobKey</code>属性：当trigger触发时被执行的job的身份；</p></li><li><p><code>startTime</code>属性：设置trigger第一次触发的时间；该属性的值是java.util.Date类型，表示某个指定的时间点；有些类型的trigger，会在设置的<code>startTime</code>时立即触发，有些类型的trigger，表示其触发是在<code>startTime</code>之后开始生效。比如，现在是1月份，你设置了一个trigger–”在每个月的第5天执行”，然后你将<code>startTime</code>属性设置为4月1号，则该trigger第一次触发会是在几个月以后了(即4月5号)。</p></li><li><p><code>endTime</code>属性：表示trigger失效的时间点。比如，”每月第5天执行”的trigger，如果其<code>endTime</code>是7月1号，则其最后一次执行时间是6月5号。</p></li></ul><p>其它的属性，会在下面的小节中解释。</p><h2 id="优先级-priority"><a href="#优先级-priority" class="headerlink" title="优先级(priority)"></a>优先级(priority)</h2><p>如果你的trigger很多(或者Quartz线程池的工作线程太少)，Quartz可能没有足够的资源同时触发所有的trigger；这种情况下，你可能希望控制哪些trigger优先使用Quartz的工作线程，要达到该目的，可以在trigger上设置<code>priority</code>属性。比如，你有N个trigger需要同时触发，但只有Z个工作线程，优先级最高的Z个trigger会被首先触发。如果没有为trigger设置优先级，trigger使用默认优先级，值为5；<code>priority</code>属性的值可以是任意整数，正数、负数都可以。</p><p>注意：只有同时触发的trigger之间才会比较优先级。10:59触发的trigger总是在11:00触发的trigger之前执行。</p><p>注意：如果trigger是可恢复的，在恢复后再调度时，优先级与原trigger是一样的。</p><h2 id="错过触发-misfire"><a href="#错过触发-misfire" class="headerlink" title="错过触发(misfire)"></a>错过触发(misfire)</h2><p>trigger还有一个重要的属性misfire；如果scheduler关闭了，或者Quartz线程池中没有可用的线程来执行job，此时持久性的trigger就会错过(miss)其触发时间，即错过触发(misfire)。不同类型的trigger，有不同的misfire机制。它们默认都使用“智能机制(smart policy)”，即根据trigger的类型和配置动态调整行为。当scheduler启动的时候，查询所有错过触发(misfire)的持久性trigger。然后根据它们各自的misfire机制更新trigger的信息。当你在项目中使用Quartz时，你应该对各种类型的trigger的misfire机制都比较熟悉，这些misfire机制在JavaDoc中有说明。关于misfire机制的细节，会在讲到具体的trigger时作介绍。</p><h2 id="日历-calendar"><a href="#日历-calendar" class="headerlink" title="日历(calendar)"></a>日历(calendar)</h2><p>Quartz的Calendar对象(不是java.util.Calendar对象)可以在定义和存储trigger的时候与trigger进行关联。Calendar用于从trigger的调度计划中排除时间段。比如，可以创建一个trigger，每个工作日的上午9:30执行，然后增加一个Calendar，排除掉所有的商业节日。</p><p>任何实现了Calendar接口的可序列化对象都可以作为Calendar对象，Calendar接口如下：</p><pre><code>package org.quartz;public interface Calendar {    public boolean isTimeIncluded(long timeStamp);    public long getNextIncludedTime(long timeStamp);}</code></pre><p>注意到这些方法的参数类型为long。你也许猜到了，他们就是毫秒单位的时间戳。即Calendar排除时间段的单位可以精确到毫秒。你也许对“排除一整天”的Calendar比较感兴趣。Quartz提供的org.quartz.impl.HolidayCalendar类可以很方便地实现。</p><p>Calendar必须先实例化，然后通过addCalendar()方法注册到scheduler。如果使用HolidayCalendar，实例化后，需要调用addExcludedDate(Date date)方法从调度计划中排除时间段。以下示例是将同一个Calendar实例用于多个trigger：</p><pre><code>HolidayCalendar cal = new HolidayCalendar();cal.addExcludedDate( someDate );cal.addExcludedDate( someOtherDate );sched.addCalendar(&quot;myHolidays&quot;, cal, false);Trigger t = newTrigger()    .withIdentity(&quot;myTrigger&quot;)    .forJob(&quot;myJob&quot;)    .withSchedule(dailyAtHourAndMinute(9, 30)) // execute job daily at 9:30    .modifiedByCalendar(&quot;myHolidays&quot;) // but not on holidays    .build();// .. schedule job with triggerTrigger t2 = newTrigger()    .withIdentity(&quot;myTrigger2&quot;)    .forJob(&quot;myJob2&quot;)    .withSchedule(dailyAtHourAndMinute(11, 30)) // execute job daily at 11:30    .modifiedByCalendar(&quot;myHolidays&quot;) // but not on holidays    .build();// .. schedule job with trigger2</code></pre><p>构造trigger的细节将在接下来的几节中讲到。就现在，只需要知道上面的代码创建了两个trigger，都是每天执行一次。但是在Calendar定义的时间段内，trigger的执行被跳过。</p><p>org.quartz.impl.calendar包下有各种Calendar的实现，根据需要进行选择。</p><ul><li><a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-04" target="_blank" rel="external">原文链接</a></li><li>本系列教程由<a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials" target="_blank" rel="external">quartz-2.2.x官方文档</a>翻译、整理而来，希望给同样对quartz感兴趣的朋友一些参考和帮助，有任何不当或错误之处，欢迎指正；有兴趣研究源码的同学，可以参考<a href="https://github.com/nkcoder/quartz-explained" target="_blank" rel="external">我对quartz-core源码的注释(进行中)</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与job一样，trigger也很容易使用，但是还有一些扩展选项需要理解，以便更好地使用quartz。trigger也有很多类型，可以根据实际需要来选择。&lt;/p&gt;
&lt;p&gt;最常用的两种trigger会分别在&lt;a href=&quot;&quot;&gt;教程五：SimpleTriggers&lt;/a&gt;和&lt;a href=&quot;&quot;&gt;教程六：CronTrigger&lt;/a&gt;中讲到；&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="quartz" scheme="http://nkcoder.github.io/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>Linux下命令行删除符号链接</title>
    <link href="http://nkcoder.github.io/2014/07/16/linux-delete-symbolic-link/"/>
    <id>http://nkcoder.github.io/2014/07/16/linux-delete-symbolic-link/</id>
    <published>2014-07-16T02:34:25.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><p>Linux下，如何从命令行删除符号链接(软链接)？</p><a id="more"></a><h2 id="2-命令："><a href="#2-命令：" class="headerlink" title="2. 命令："></a>2. 命令：</h2><p>删除符号链接，使用<code>rm</code>命令或者<code>unlink</code>命令，后接文件名或目录名，如果是目录，注意目录后，不要加/。</p><p>语法：</p><pre><code>rm linkname/dirnameunlink linkname/dirname</code></pre><p>示例：</p><pre><code>nkcoder@ubuntu:~$ cd ~nkcoder@ubuntu:~$ ln -s /usr/local/jetty/start.ini start.ini.baknkcoder@ubuntu:~$ ll start.ini.baklrwxrwxrwx 1 nkcoder nkcoder 26 Jul 16 10:28 start.ini.bak -&gt; /usr/local/jetty/start.ininkcoder@ubuntu:~$ unlink start.ini.baknkcoder@ubuntu:~$ ln -s /usr/local/jetty jetty.baknkcoder@ubuntu:~$ ll jetty.baklrwxrwxrwx 1 nkcoder nkcoder 16 Jul 16 10:28 jetty.bak -&gt; /usr/local/jetty/nkcoder@ubuntu:~$ rm jetty.bak</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.cyberciti.biz/faq/linux-remove-delete-symbolic-softlink-command/" target="_blank" rel="external">Linux Delete Symbolic Link ( Softlink )</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题&quot;&gt;&lt;a href=&quot;#1-问题&quot; class=&quot;headerlink&quot; title=&quot;1. 问题&quot;&gt;&lt;/a&gt;1. 问题&lt;/h2&gt;&lt;p&gt;Linux下，如何从命令行删除符号链接(软链接)？&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="linux" scheme="http://nkcoder.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Mysql重连，连接丢失的问题</title>
    <link href="http://nkcoder.github.io/2014/07/12/mysql-reconnect-packet-lost/"/>
    <id>http://nkcoder.github.io/2014/07/12/mysql-reconnect-packet-lost/</id>
    <published>2014-07-12T12:58:06.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-错误信息："><a href="#1-错误信息：" class="headerlink" title="1. 错误信息："></a>1. 错误信息：</h2><pre><code>Caused by: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: The last packet successfully received from the server was 20,820,001 milliseconds ago.  The last packet sent successfully to the server was 20,820,002 milliseconds ago. is longer than the server configured value of &apos;wait_timeout&apos;. You should consider either expiring and/or testing connection validity before use in your application, increasing the server configured values for client timeouts, or using the Connector/J connection property &apos;autoReconnect=true&apos; to avoid this problem.</code></pre><a id="more"></a><pre><code>at sun.reflect.GeneratedConstructorAccessor29.newInstance(Unknown Source) ~[na:na]at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:1.7.0_51]at java.lang.reflect.Constructor.newInstance(Constructor.java:526) ~[na:1.7.0_51]at com.mysql.jdbc.Util.handleNewInstance(Util.java:411) ~[mysql-connector-java-5.1.29.jar:na]at com.mysql.jdbc.SQLError.createCommunicationsException(SQLError.java:1129) ~[mysql-connector-java-5.1.29.jar:na]at com.mysql.jdbc.MysqlIO.send(MysqlIO.java:3988) ~[mysql-connector-java-5.1.29.jar:na]at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:2598) ~[mysql-connector-java-5.1.29.jar:na]at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2778) ~[mysql-connector-java-5.1.29.jar:na]at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2828) ~[mysql-connector-java-5.1.29.jar:na]at com.mysql.jdbc.ConnectionImpl.setAutoCommit(ConnectionImpl.java:5372) ~[mysql-connector-java-5.1.29.jar:na]at com.mchange.v2.c3p0.impl.NewProxyConnection.setAutoCommit(NewProxyConnection.java:881) ~[c3p0-0.9.1.1.jar:0.9.1.1]at org.quartz.impl.jdbcjobstore.AttributeRestoringConnectionInvocationHandler.setAutoCommit(AttributeRestoringConnectionInvocationHandler.java:98) ~[quartz-2.2.1.jar:na]</code></pre><h2 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2. 解决方法"></a>2. 解决方法</h2><ul><li><p>如果使用的是JDBC，在JDBC URL上添加<code>?autoReconnect=true</code>，如：</p><p>  jdbc:mysql://10.10.10.10:3306/mydb?autoReconnect=true</p></li><li><p>如果是在Spring中使用DBCP连接池，在定义datasource增加属性<code>validationQuery</code>和<code>testOnBorrow</code>，如：</p>  <bean id="vrsRankDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"><br>      <property name="driverClassName" value="${jdbc.driverClassName}"><br>      <property name="url" value="${countNew.jdbc.url}"><br>      <property name="username" value="${countNew.jdbc.user}"><br>      <property name="password" value="${countNew.jdbc.pwd}"><br>      <property name="validationQuery" value="SELECT 1"><br>      <property name="testOnBorrow" value="true"><br>  </property></property></property></property></property></property></bean><ul><li><p>如果是在Spring中使用c3p0连接池，则在定义datasource的时候，添加属性<code>testConnectionOnCheckin</code>和<code>testConnectionOnCheckout</code>，如：</p><bean name="cacheCloudDB" class="com.mchange.v2.c3p0.ComboPooledDataSource"><br>    <property name="driverClass" value="${jdbc.driver}"><br>    <property name="jdbcUrl" value="${cache.url}"><br>    <property name="user" value="${cache.user}"><br>    <property name="password" value="${cache.password}"><br>    <property name="initialPoolSize" value="10"><br>    <property name="maxPoolSize" value="${cache.maxPoolSize}"><br>    <property name="testConnectionOnCheckin" value="false"><br>    <property name="testConnectionOnCheckout" value="true"><br>    <property name="preferredTestQuery" value="SELECT 1"><br></property></property></property></property></property></property></property></property></property></bean></li></ul></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://itellity.wordpress.com/2013/07/18/mysql-reconnect-issues-or-the-last-packet-successfully-received-from-the-server-xx-milliseconds-ago-errors/" target="_blank" rel="external">MySQL reconnect issues</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-错误信息：&quot;&gt;&lt;a href=&quot;#1-错误信息：&quot; class=&quot;headerlink&quot; title=&quot;1. 错误信息：&quot;&gt;&lt;/a&gt;1. 错误信息：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Caused by: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: The last packet successfully received from the server was 20,820,001 milliseconds ago.  The last packet sent successfully to the server was 20,820,002 milliseconds ago. is longer than the server configured value of &amp;apos;wait_timeout&amp;apos;. You should consider either expiring and/or testing connection validity before use in your application, increasing the server configured values for client timeouts, or using the Connector/J connection property &amp;apos;autoReconnect=true&amp;apos; to avoid this problem.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="mysql" scheme="http://nkcoder.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【MyBatis】元素类型为&quot;configuration&quot;的内容必须匹配</title>
    <link href="http://nkcoder.github.io/2014/07/09/mybatis-config-order-error/"/>
    <id>http://nkcoder.github.io/2014/07/09/mybatis-config-order-error/</id>
    <published>2014-07-09T14:23:31.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-错误信息："><a href="#1-错误信息：" class="headerlink" title="1. 错误信息："></a>1. 错误信息：</h2><pre><code>org.apache.ibatis.exceptions.PersistenceException:### Error building SqlSession.### Cause: org.apache.ibatis.builder.BuilderException: Error creating document instance.  Cause: org.xml.sax.SAXParseException; lineNumber: 45; columnNumber: 17; 元素类型为 &quot;configuration&quot; 的内容必须匹配 &quot;(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,plugins?,environments?,databaseIdProvider?,mappers?)&quot;。</code></pre><a id="more"></a><h2 id="2-原因：在配置mybatis-config-xml时，其中的节点是有顺序的，配置顺序依次为："><a href="#2-原因：在配置mybatis-config-xml时，其中的节点是有顺序的，配置顺序依次为：" class="headerlink" title="2. 原因：在配置mybatis-config.xml时，其中的节点是有顺序的，配置顺序依次为："></a>2. 原因：在配置mybatis-config.xml时，其中的节点是有顺序的，配置顺序依次为：</h2><pre><code>properties/settings/typeAliases/typeHandlers/objectFactory/objectWrapperFactory/plugins/environments/databaseIdProvider/mappers</code></pre><blockquote><p>我出现该错是因为将settings节点放到了environments后面。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-错误信息：&quot;&gt;&lt;a href=&quot;#1-错误信息：&quot; class=&quot;headerlink&quot; title=&quot;1. 错误信息：&quot;&gt;&lt;/a&gt;1. 错误信息：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;org.apache.ibatis.exceptions.PersistenceException:
### Error building SqlSession.
### Cause: org.apache.ibatis.builder.BuilderException: Error creating document instance.  Cause: org.xml.sax.SAXParseException; lineNumber: 45; columnNumber: 17; 元素类型为 &amp;quot;configuration&amp;quot; 的内容必须匹配 &amp;quot;(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,plugins?,environments?,databaseIdProvider?,mappers?)&amp;quot;。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="mybatis" scheme="http://nkcoder.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【Guava】使用前置条件进行合法性检查</title>
    <link href="http://nkcoder.github.io/2014/07/08/guava-basic-preconditions/"/>
    <id>http://nkcoder.github.io/2014/07/08/guava-basic-preconditions/</id>
    <published>2014-07-08T14:55:59.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章是在学习<a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="external">Google Guava 17.0</a>库的过程中的整理和笔记，不是完全翻译，欢迎交流。</p></blockquote><h2 id="1-前置条件检查"><a href="#1-前置条件检查" class="headerlink" title="1. 前置条件检查"></a>1. 前置条件检查</h2><ul><li><p>Preconditions类提供了很多static方法，用于对方法或构造函数的参数进行合法性检查，强烈推荐使用；</p></li><li><p>关于性能：Preconditions是为了提高代码的可读性，但有些情况下，可能会影响系统性能；在性能敏感的环境下，总是可以使用如下形式：</p><p>  if (value &lt; 0.0) {</p><pre><code>throw new IllegalArgumentException(&quot;negative value: &quot; + value);</code></pre><p>  }</p></li></ul><a id="more"></a><ul><li><p>在使用com.google.common时，应尽量避免使用Objects.requireNonNull(Object)，推荐使用checkNotNull(Object)或者Verify.verifyNotNull(Object)，而且它们支持%s的格式化信息；</p></li><li><p>checkNotNull(Object) 含义明确，不易混淆，而且参数合法时返回原值，可以用于‘检查并赋值‘的场合，如：this.field = checkNotNull(field)；</p></li><li><p>推荐将多个前置条件分开检查，并在异常消息中提供有用的信息，这样有利于程序的调试；</p></li></ul><h2 id="2-Preconditions-API"><a href="#2-Preconditions-API" class="headerlink" title="2. Preconditions API"></a>2. Preconditions API</h2><p>每一类方法都有三种变体，除了要检查的参数外，额外的参数组合有：</p><ul><li><p>不带参数，抛出异常时不带异常信息；</p></li><li><p>带一个Object参数，抛出异常时，异常信息为：Ojbect.toString()；</p></li><li><p>带一个String参数，和不定个数的Object参数；行为类似于printf，但String中仅支持%s格式符，如：</p><p>  checkArgument(i &gt;= 0, “Argument was %s but expected nonnegative”, i);<br>  checkArgument(i &lt; j, “Expected i &lt; j, but %s &gt; %s”, i, j);</p></li></ul><p>主要的static方法有：</p><ul><li><p><code>checkArgument(boolean)</code>        检查参数条件是否为true；</p></li><li><p><code>checkNotNull(T)</code>                检查参数是否不为null，如果不为null，直接返回参数值；</p></li><li><p><code>checkState(boolean)</code>            检查对象的状态，不依赖于方法的参数；</p></li><li><p><code>checkElementIndex(int index, int size)</code>    检查index是否在[0, size)之间，其中size可以表示String、List或Array的长度；</p></li><li><p><code>checkPositionIndex(int index, int size)</code>    检查index是否在[0, size]之间，其中size可以表示String、List或Array的长度；</p></li><li><p><code>checkPositionIndexes(int start, int end, int size)</code>    检查区间[start, end)是否为[0, size]的子区间；(该方法仅此一种形式，无其它参数版)。</p></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://code.google.com/p/guava-libraries/wiki/PreconditionsExplained" target="_blank" rel="external">PreconditionsExplained</a></li><li><a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/base/Preconditions.html" target="_blank" rel="external">Preconditions API</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列文章是在学习&lt;a href=&quot;https://code.google.com/p/guava-libraries/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google Guava 17.0&lt;/a&gt;库的过程中的整理和笔记，不是完全翻译，欢迎交流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-前置条件检查&quot;&gt;&lt;a href=&quot;#1-前置条件检查&quot; class=&quot;headerlink&quot; title=&quot;1. 前置条件检查&quot;&gt;&lt;/a&gt;1. 前置条件检查&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Preconditions类提供了很多static方法，用于对方法或构造函数的参数进行合法性检查，强烈推荐使用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于性能：Preconditions是为了提高代码的可读性，但有些情况下，可能会影响系统性能；在性能敏感的环境下，总是可以使用如下形式：&lt;/p&gt;
&lt;p&gt;  if (value &amp;lt; 0.0) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;throw new IllegalArgumentException(&amp;quot;negative value: &amp;quot; + value);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  }&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="guava" scheme="http://nkcoder.github.io/tags/guava/"/>
    
  </entry>
  
  <entry>
    <title>【Guava】避免使用null</title>
    <link href="http://nkcoder.github.io/2014/07/08/guava-basic-avoid-null/"/>
    <id>http://nkcoder.github.io/2014/07/08/guava-basic-avoid-null/</id>
    <published>2014-07-08T14:36:58.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章是在学习<a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="external">Google Guava 17.0</a>库的过程中的整理和笔记，不是完全翻译，欢迎交流。</p></blockquote><h2 id="1-避免使用null"><a href="#1-避免使用null" class="headerlink" title="1. 避免使用null"></a>1. 避免使用null</h2><ul><li><p>集合中不要接受null，对于null采取快速失败的策略；</p></li><li><p>NULL的含义是模糊的，如Map.get(key)，如果返回null，可能是该map中不存在该key，也可能是存在该key，但对应的value为null；</p></li><li><p>如果打算在map中存放key对应的value为null的entry，不要这么做，宁愿另外用一个Set保存value非null的key（或value为null的key），分开操作，在你的上下文中，value为null的key应该具有明确的含义；</p></li></ul><a id="more"></a><h2 id="2-Optional"><a href="#2-Optional" class="headerlink" title="2. Optional"></a>2. Optional<t></t></h2><ul><li>Optional是一个引用，如果其中有值，则为’present’，如果没有值，则为’absent’，但不会“包含null”；Optional可以看做是对null的友好的包装，在设置或取值时，会提醒你判断它的引用状态，而null很容易让人忘记检查其合法性；</li></ul><h2 id="3-Optional-API"><a href="#3-Optional-API" class="headerlink" title="3. Optional API"></a>3. Optional API</h2><p>构造Optional的静态方法：</p><ul><li><p><code>Optional.of(T)</code>        根据非null的参数，构造一个Optional实例；</p></li><li><p><code>Optional.absent()</code>        构造一个不包含引用的(absent)的Optional实例；</p></li><li><p><code>Optional.fromNullable(T)</code>    从可为null的参数中构造一个Optional实例，如果参数不为null，则状态为present，否则状态为absent；</p></li></ul><p>Optional对象的方法：</p><ul><li><p><code>boolean isPresent()</code>    如果该optional实例有非null引用，返回true，否则返回false；</p></li><li><p><code>T get()</code>                如果该optional实例有非null引用，返回引用对象的值，否则，抛出IllegalStateException；</p></li><li><p><code>T or(T)</code>                如果该optional实例有非null引用，返回引用对象的值，否则，返回参数指定的默认值；</p></li><li><p><code>T orNull()</code>            如果该optional实例有非null引用，返回引用对象的值，否则，返回null；</p></li><li><p><code>Set&lt;T&gt; asSet()</code>        如果该optional实例包含非null引用，以该实例的值构造一个Set并返回，否则返回一个空Set；</p></li></ul><h2 id="4-Strings中相关方法"><a href="#4-Strings中相关方法" class="headerlink" title="4. Strings中相关方法"></a>4. Strings中相关方法</h2><p>注意，不要将null串与空串混为一谈，Strings工具类中相关的static方法有：</p><ul><li><p><code>emptyToNull(String)</code>        如果参数不为空，返回参数值，否则返回null；</p></li><li><p><code>nullToEmpty(String)</code>        如果参数不为null，返回该参数，否则返回空串(“”)；</p></li><li><p><code>isNullOrEmpty(String)</code>    如果参数为null或为空，返回true；</p></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained" target="_blank" rel="external">Using and avoiding null</a></li><li><a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/base/Optional.html" target="_blank" rel="external">Optional doc</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列文章是在学习&lt;a href=&quot;https://code.google.com/p/guava-libraries/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google Guava 17.0&lt;/a&gt;库的过程中的整理和笔记，不是完全翻译，欢迎交流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-避免使用null&quot;&gt;&lt;a href=&quot;#1-避免使用null&quot; class=&quot;headerlink&quot; title=&quot;1. 避免使用null&quot;&gt;&lt;/a&gt;1. 避免使用null&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;集合中不要接受null，对于null采取快速失败的策略；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NULL的含义是模糊的，如Map.get(key)，如果返回null，可能是该map中不存在该key，也可能是存在该key，但对应的value为null；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果打算在map中存放key对应的value为null的entry，不要这么做，宁愿另外用一个Set保存value非null的key（或value为null的key），分开操作，在你的上下文中，value为null的key应该具有明确的含义；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="guava" scheme="http://nkcoder.github.io/tags/guava/"/>
    
  </entry>
  
  <entry>
    <title>Quartz教程三--Job与JobDetail介绍</title>
    <link href="http://nkcoder.github.io/2014/06/27/quartz-tutorial-03-job-jobdetail/"/>
    <id>http://nkcoder.github.io/2014/06/27/quartz-tutorial-03-job-jobdetail/</id>
    <published>2014-06-27T00:21:54.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>正如在<a href="http://nkcoder.github.io/blog/20140624/quartz-tutorial-api-job-trigger/">教程二</a>中讲到的，Job实现起来很容易，该接口只有一个“execute”方法。本节主要关注：Job的特点、Job接口的execute方法以及JobDetail。</p><p>你定义了一个实现Job接口的类，这个类仅仅表明该job需要完成什么类型的任务，除此之外，Quartz还需要知道该Job实例所包含的属性；这将由JobDetail类来完成。</p><a id="more"></a><p>JobDetail实例是通过JobBuilder类创建的，导入该类下的所有静态方法，会让你编码时有DSL的感觉：</p><pre><code>import static org.quartz.JobBuilder.*;</code></pre><p>让我们先看看Job的特征（nature）以及Job实例的生命期。不妨先回头看看<a href="http://nkcoder.github.io/blog/20140623/quartz-tutorial-using-quartz/">教程一</a>中的代码片段：</p><pre><code>// define the job and tie it to our HelloJob classJobDetail job = newJob(HelloJob.class)  .withIdentity(&quot;myJob&quot;, &quot;group1&quot;) // name &quot;myJob&quot;, group &quot;group1&quot;  .build();// Trigger the job to run now, and then every 40 secondsTrigger trigger = newTrigger()  .withIdentity(&quot;myTrigger&quot;, &quot;group1&quot;)  .startNow()  .withSchedule(simpleSchedule()      .withIntervalInSeconds(40)      .repeatForever())              .build();// Tell quartz to schedule the job using our triggersched.scheduleJob(job, trigger);</code></pre><p>“HelloJob”类可以如下定义：</p><pre><code>public class HelloJob implements Job {    public HelloJob() {    }    public void execute(JobExecutionContext context)      throws JobExecutionException    {      System.err.println(&quot;Hello!  HelloJob is executing.&quot;);    }}</code></pre><p>可以看到，我们传给scheduler一个JobDetail实例，因为我们在创建JobDetail时，将要执行的job的类名传给了JobDetail，所以scheduler就知道了要执行何种类型的job；每次当scheduler执行job时，在调用其execute(…)方法之前会创建该类的一个新的实例；执行完毕，对该实例的引用就被丢弃了，实例会被垃圾回收；这种执行策略带来的一个后果是，job必须有一个无参的构造函数（当使用默认的JobFactory时）；另一个后果是，在job类中，不应该定义有状态的数据属性，因为在job的多次执行中，这些属性的值不会保留。</p><p>那么如何给job实例增加属性或配置呢？如何在job的多次执行中，跟踪job的状态呢？答案就是:JobDataMap，JobDetail对象的一部分。</p><h2 id="JobDataMap"><a href="#JobDataMap" class="headerlink" title="JobDataMap"></a>JobDataMap</h2><p>JobDataMap中可以包含不限量的（序列化的）数据对象，在job实例执行的时候，可以使用其中的数据；JobDataMap是Java Map接口的一个实现，额外增加了一些便于存取基本类型的数据的方法。</p><p>将job加入到scheduler之前，在构建JobDetail时，可以将数据放入JobDataMap，如下示例：</p><pre><code>JobDetail job = newJob(DumbJob.class)  .withIdentity(&quot;myJob&quot;, &quot;group1&quot;) // name &quot;myJob&quot;, group &quot;group1&quot;  .usingJobData(&quot;jobSays&quot;, &quot;Hello World!&quot;)  .usingJobData(&quot;myFloatValue&quot;, 3.141f)  .build();</code></pre><p>在job的执行过程中，可以从JobDataMap中取出数据，如下示例：</p><pre><code>public class DumbJob implements Job {    public DumbJob() {    }    public void execute(JobExecutionContext context)        throws JobExecutionException    {        JobKey key = context.getJobDetail().getKey();        JobDataMap dataMap = context.getJobDetail().getJobDataMap();        String jobSays = dataMap.getString(&quot;jobSays&quot;);        float myFloatValue = dataMap.getFloat(&quot;myFloatValue&quot;);        System.err.println(&quot;Instance &quot; + key + &quot; of DumbJob says: &quot; + jobSays + &quot;, and val is: &quot; + myFloatValue);    }}</code></pre><p>如果你使用的是持久化的存储机制（本教程的JobStore部分会讲到），在决定JobDataMap中存放什么数据的时候需要小心，因为JobDataMap中存储的对象都会被序列化，因此很可能会导致类的版本不一致的问题；Java的标准类型都很安全，如果你已经有了一个类的序列化后的实例，某个时候，别人修改了该类的定义，此时你需要确保对类的修改没有破坏兼容性；更多细节，参考<a href="http://java.sun.com/developer/TechTips/2000/tt0229.html" target="_blank" rel="external">现实中的序列化问题</a>。另外，你也可以配置JDBC-JobStore和JobDataMap，使得map中仅允许存储基本类型和String类型的数据，这样可以避免后续的序列化问题。</p><p>如果你在job类中，为JobDataMap中存储的数据的key增加set方法（如在上面示例中，增加setJobSays(String val)方法），那么Quartz的默认JobFactory实现在job被实例化的时候会自动调用这些set方法，这样你就不需要在execute()方法中显式地从map中取数据了。</p><p>在Job执行时，JobExecutionContext中的JobDataMap为我们提供了很多的便利。它是JobDetail中的JobDataMap和Trigger中的JobDataMap的并集，但是如果存在相同的数据，则后者会覆盖前者的值。</p><p>下面的示例，在job执行时，从JobExecutionContext中获取合并后的JobDataMap：</p><pre><code>public class DumbJob implements Job {    public DumbJob() {    }    public void execute(JobExecutionContext context)      throws JobExecutionException    {        JobKey key = context.getJobDetail().getKey();        JobDataMap dataMap = context.getMergedJobDataMap();  // Note the difference from the previous example        String jobSays = dataMap.getString(&quot;jobSays&quot;);        float myFloatValue = dataMap.getFloat(&quot;myFloatValue&quot;);        ArrayList state = (ArrayList)dataMap.get(&quot;myStateData&quot;);        state.add(new Date());        System.err.println(&quot;Instance &quot; + key + &quot; of DumbJob says: &quot; + jobSays + &quot;, and val is: &quot; + myFloatValue);    }}</code></pre><p>如果你希望使用JobFactory实现数据的自动“注入”，则示例代码为：</p><pre><code>public class DumbJob implements Job {    String jobSays;    float myFloatValue;    ArrayList state;    public DumbJob() {    }    public void execute(JobExecutionContext context)      throws JobExecutionException    {        JobKey key = context.getJobDetail().getKey();        JobDataMap dataMap = context.getMergedJobDataMap();  // Note the difference from the previous example        state.add(new Date());        System.err.println(&quot;Instance &quot; + key + &quot; of DumbJob says: &quot; + jobSays + &quot;, and val is: &quot; + myFloatValue);    }    public void setJobSays(String jobSays) {        this.jobSays = jobSays;    }    public void setMyFloatValue(float myFloatValue) {        myFloatValue = myFloatValue;    }    public void setState(ArrayList state) {        state = state;    }}</code></pre><p>你也许发现，整体上看代码更多了，但是execute()方法中的代码更简洁了。而且，虽然代码更多了，但如果你的IDE可以自动生成setter方法，你就不需要写代码调用相应的方法从JobDataMap中获取数据了，所以你实际需要编写的代码更少了。当前，如何选择，由你决定。</p><h2 id="Job实例"><a href="#Job实例" class="headerlink" title="Job实例"></a>Job实例</h2><p>很多用户对于Job实例到底由什么构成感到很迷惑。我们在这里解释一下，并在接下来的小节介绍job状态和并发。</p><p>你可以只创建一个job类，然后创建多个与该job关联的JobDetail实例，每一个实例都有自己的属性集和JobDataMap，最后，将所有的实例都加到scheduler中。</p><p>比如，你创建了一个实现Job接口的类“SalesReportJob”。该job需要一个参数（通过JobdataMap传入），表示负责该销售报告的销售员的名字。因此，你可以创建该job的多个实例（JobDetail），比如“SalesReportForJoe”、“SalesReportForMike”，将“joe”和“mike”作为JobDataMap的数据传给对应的job实例。</p><p>当一个trigger被触发时，与之关联的JobDetail实例会被加载，JobDetail引用的job类通过配置在Scheduler上的JobFactory进行初始化。默认的JobFactory实现，仅仅是调用job类的newInstance()方法，然后尝试调用JobDataMap中的key的setter方法。你也可以创建自己的JobFactory实现，比如让你的IOC或DI容器可以创建/初始化job实例。</p><p>在Quartz的描述语言中，我们将保存后的JobDetail称为“job定义”或者“JobDetail实例”,将一个正在执行的job称为“job实例”或者“job定义的实例”。当我们使用“job”时，一般指代的是job定义，或者JobDetail；当我们提到实现Job接口的类时，通常使用“job类”。</p><h2 id="Job状态与并发"><a href="#Job状态与并发" class="headerlink" title="Job状态与并发"></a>Job状态与并发</h2><p>关于job的状态数据（即JobDataMap）和并发性，还有一些地方需要注意。在job类上可以加入一些注解，这些注解会影响job的状态和并发性。</p><p>@DisallowConcurrentExecution：将该注解加到job类上，告诉Quartz不要并发地执行同一个job定义（这里指特定的job类）的多个实例。请注意这里的用词。拿前一小节的例子来说，如果“SalesReportJob”类上有该注解，则同一时刻仅允许执行一个“SalesReportForJoe”实例，但可以并发地执行“SalesReportForMike”类的一个实例。所以该限制是针对JobDetail的，而不是job类的。但是我们认为（在设计Quartz的时候）应该将该注解放在job类上，因为job类的改变经常会导致其行为发生变化。</p><p>@PersistJobDataAfterExecution：将该注解加在job类上，告诉Quartz在成功执行了job类的execute方法后（没有发生任何异常），更新JobDetail中JobDataMap的数据，使得该job（即JobDetail）在下一次执行的时候，JobDataMap中是更新后的数据，而不是更新前的旧数据。和 @DisallowConcurrentExecution注解一样，尽管注解是加在job类上的，但其限制作用是针对job实例的，而不是job类的。由job类来承载注解，是因为job类的内容经常会影响其行为状态（比如，job类的execute方法需要显式地“理解”其”状态“）。</p><p>如果你使用了@PersistJobDataAfterExecution注解，我们强烈建议你同时使用@DisallowConcurrentExecution注解，因为当同一个job（JobDetail）的两个实例被并发执行时，由于竞争，JobDataMap中存储的数据很可能是不确定的。</p><h2 id="Job的其它特性"><a href="#Job的其它特性" class="headerlink" title="Job的其它特性"></a>Job的其它特性</h2><p>通过JobDetail对象，可以给job实例配置的其它属性有：</p><ul><li>Durability：如果一个job是非持久的，当没有活跃的trigger与之关联的时候，会被自动地从scheduler中删除。也就是说，非持久的job的生命期是由trigger的存在与否决定的；</li><li>RequestsRecovery：如果一个job是可恢复的，并且在其执行的时候，scheduler发生硬关闭（hard shutdown)（比如运行的进程崩溃了，或者关机了），则当scheduler重新启动的时候，该job会被重新执行。此时，该job的JobExecutionContext.isRecovering() 返回true。</li></ul><h2 id="JobExecutionException"><a href="#JobExecutionException" class="headerlink" title="JobExecutionException"></a>JobExecutionException</h2><p>最后，是关于Job.execute(..)方法的一些额外细节。execute方法中仅允许抛出一种类型的异常（包括RuntimeExceptions），即JobExecutionException。因此，你应该将execute方法中的所有内容都放到一个”try-catch”块中。你也应该花点时间看看JobExecutionException的文档，因为你的job可以使用该异常告诉scheduler，你希望如何来处理发生的异常。</p><ul><li><a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-03" target="_blank" rel="external">原文链接</a></li><li>本系列教程由<a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials" target="_blank" rel="external">quartz-2.2.x官方文档</a>翻译、整理而来，希望给同样对quartz感兴趣的朋友一些参考和帮助，有任何不当或错误之处，欢迎指正；有兴趣研究源码的同学，可以参考<a href="https://github.com/nkcoder/quartz-explained" target="_blank" rel="external">我对quartz-core源码的注释(进行中)</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正如在&lt;a href=&quot;http://nkcoder.github.io/blog/20140624/quartz-tutorial-api-job-trigger/&quot;&gt;教程二&lt;/a&gt;中讲到的，Job实现起来很容易，该接口只有一个“execute”方法。本节主要关注：Job的特点、Job接口的execute方法以及JobDetail。&lt;/p&gt;
&lt;p&gt;你定义了一个实现Job接口的类，这个类仅仅表明该job需要完成什么类型的任务，除此之外，Quartz还需要知道该Job实例所包含的属性；这将由JobDetail类来完成。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="quartz" scheme="http://nkcoder.github.io/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>Quartz教程二--API、Job与Trigger</title>
    <link href="http://nkcoder.github.io/2014/06/24/quartz-tutorial-02-api-job-trigger/"/>
    <id>http://nkcoder.github.io/2014/06/24/quartz-tutorial-02-api-job-trigger/</id>
    <published>2014-06-24T14:42:53.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quartz-API"><a href="#Quartz-API" class="headerlink" title="Quartz API"></a>Quartz API</h2><p>Quartz API核心接口有：</p><ul><li>Scheduler - 与scheduler交互的主要API；</li><li>Job - 你通过scheduler执行任务，你的任务类需要实现的接口；</li><li>JobDetail - 定义Job的实例；</li><li>Trigger - 触发Job的执行；</li><li>JobBuilder - 定义和创建JobDetail实例的接口;</li><li>TriggerBuilder - 定义和创建Trigger实例的接口；</li></ul><a id="more"></a><p>Scheduler的生命期，从SchedulerFactory创建它时开始，到Scheduler调用shutdown()方法时结束；Scheduler被创建后，可以增加、删除和列举Job和Trigger，以及执行其它与调度相关的操作（如暂停Trigger）。但是，Scheduler只有在调用start()方法后，才会真正地触发trigger（即执行job），见<a href="http://nkcoder.github.io/blog/20140623/quartz-tutorial-using-quartz/">教程一</a>。</p><p>Quartz提供的“builder”类，可以认为是一种领域特定语言（DSL，Domain Specific Language)。教程一中有相关示例，这里是其中的代码片段：</p><pre><code>// define the job and tie it to our HelloJob classJobDetail job = newJob(HelloJob.class)  .withIdentity(&quot;myJob&quot;, &quot;group1&quot;) // name &quot;myJob&quot;, group &quot;group1&quot;  .build();// Trigger the job to run now, and then every 40 secondsTrigger trigger = newTrigger()  .withIdentity(&quot;myTrigger&quot;, &quot;group1&quot;)  .startNow()  .withSchedule(simpleSchedule()      .withIntervalInSeconds(40)      .repeatForever())              .build();// Tell quartz to schedule the job using our triggersched.scheduleJob(job, trigger);</code></pre><p>定义job的代码使用的是从JobBuilder静态导入的方法。同样，定义trigger的代码使用的是从TriggerBuilder静态导入的方法 - 另外，也导入了SimpleSchedulerBuilder类的静态方法；</p><p>从DSL里静态导入的语句如下：</p><pre><code>import static org.quartz.JobBuilder.*;import static org.quartz.SimpleScheduleBuilder.*;import static org.quartz.CronScheduleBuilder.*;import static org.quartz.CalendarIntervalScheduleBuilder.*;import static org.quartz.TriggerBuilder.*;import static org.quartz.DateBuilder.*;</code></pre><p>SchedulerBuilder接口的各种实现类，可以定义不同类型的调度计划（schedule）；</p><p>DateBuilder类包含很多方法，可以很方便地构造表示不同时间点的java.util.Date实例（如定义下一个小时为偶数的时间点，如果当前时间为9:43:27，则定义的时间为10:00:00）。</p><h2 id="Job和Trigger"><a href="#Job和Trigger" class="headerlink" title="Job和Trigger"></a>Job和Trigger</h2><p>一个job就是一个实现了Job接口的类，该接口只有一个方法：</p><p>Job接口：</p><pre><code>package org.quartz;public interface Job {public void execute(JobExecutionContext context)  throws JobExecutionException;}</code></pre><p>当job的一个trigger被触发后（稍后会讲到），execute()方法会被scheduler的一个工作线程调用；传递给execute()方法的JobExecutionContext对象中保存着该job运行时的一些信息 - 执行job的scheduler的引用，触发job的trigger的引用，JobDetail对象引用，以及一些其它信息。</p><p>JobDetail对象是在将job加入scheduler时，由客户端程序（你的程序）创建的。它包含job的各种属性设置，以及用于存储job实例状态信息的JobDataMap。本节是对job实例的简单介绍，更多的细节将在下一节讲到。</p><p>Trigger用于触发Job的执行。当你准备调度一个job时，你创建一个Trigger的实例，然后设置调度相关的属性。Trigger也有一个相关联的JobDataMap，用于给Job传递一些触发相关的参数。Quartz自带了各种不同类型的Trigger，最常用的主要是SimpleTrigger和CronTrigger。</p><p>SimpleTrigger主要用于“一次性”(one-shot)执行的Job（只在某个特定的时间点执行一次），或者Job在特定的时间点执行，重复执行N次，每次执行之间延迟T个时间单位。CronTrigger在基于日历的调度上非常有用，如“每个星期五的正午”，或者“每月的第十天的上午10:15”等。</p><p>为什么既有Job，又有Trigger呢？很多任务调度器并不区分Job和Trigger。有些调度器只是简单地通过一个执行时间和一些job标识符来定义一个Job；其它的一些调度器将Quartz的Job和Trigger对象合二为一。在开发Quartz的时候，我们认为将调度和要调度的任务分离是合理的。在我们看来，这可以带来很多好处。</p><p>例如，Job被创建后，可以保存在Scheduler中，与Trigger是独立的，同一个Job可以有多个Trigger；这种松耦合的另一个好处是，当与Scheduler中的Job关联的trigger都过期了时，可以配置Job稍后被重新调度，而不用重新定义Job；还有，可以修改或者替换Trigger，而不用重新定义与之关联的Job。</p><h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h2><p>将Job和Trigger注册到Scheduler时，可以为它们设置key，配置其身份属性。Job和Trigger的key（JobKey和TriggerKey）可以用于将Job和Trigger放到不同的分组（group）里，然后基于分组进行操作。同一个分组下的Job或Trigger的名称必须唯一，即一个Job或Trigger的key由名称（name）和分组（group）组成。</p><p>对于Job和Trigger，你现在有一个大概的了解了，更详细的介绍，见<a href="http://nkcoder.github.io/blog/20140627/quartz-tutorial-job-jobdetail/">教程三</a>和<a href="http://nkcoder.github.io/blog/20140716/quartz-tutorial-04-trigger/">教程四</a>。</p><ul><li><a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-02" target="_blank" rel="external">原文链接</a></li><li>本系列教程由<a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials" target="_blank" rel="external">quartz-2.2.x官方文档</a>翻译、整理而来，希望给同样对quartz感兴趣的朋友一些参考和帮助，有任何不当或错误之处，欢迎指正；有兴趣研究源码的同学，可以参考<a href="https://github.com/nkcoder/quartz-explained" target="_blank" rel="external">我对quartz-core源码的注释(进行中)</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Quartz-API&quot;&gt;&lt;a href=&quot;#Quartz-API&quot; class=&quot;headerlink&quot; title=&quot;Quartz API&quot;&gt;&lt;/a&gt;Quartz API&lt;/h2&gt;&lt;p&gt;Quartz API核心接口有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scheduler - 与scheduler交互的主要API；&lt;/li&gt;
&lt;li&gt;Job - 你通过scheduler执行任务，你的任务类需要实现的接口；&lt;/li&gt;
&lt;li&gt;JobDetail - 定义Job的实例；&lt;/li&gt;
&lt;li&gt;Trigger - 触发Job的执行；&lt;/li&gt;
&lt;li&gt;JobBuilder - 定义和创建JobDetail实例的接口;&lt;/li&gt;
&lt;li&gt;TriggerBuilder - 定义和创建Trigger实例的接口；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="quartz" scheme="http://nkcoder.github.io/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>Quartz教程一--使用Quartz</title>
    <link href="http://nkcoder.github.io/2014/06/23/quartz-tutorial-01-using-quartz/"/>
    <id>http://nkcoder.github.io/2014/06/23/quartz-tutorial-01-using-quartz/</id>
    <published>2014-06-23T13:01:32.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Scheduler在使用之前需要实例化。一般通过SchedulerFactory来创建一个实例。有些用户将factory的实例保存在JNDI中，但直接初始化，然后使用该实例也许更简单（见下面的示例）。</p><p>scheduler实例化后，可以启动(start)、暂停(stand-by)、停止(shutdown)。注意：scheduler被停止后，除非重新实例化，否则不能重新启动；只有当scheduler启动后，即使处于暂停状态也不行，trigger才会被触发（job才会被执行）。</p><a id="more"></a><p>下面的代码片段，实例化并启动一个scheduler，调度执行一个job：</p><pre><code>SchedulerFactory schedFact = new org.quartz.impl.StdSchedulerFactory(); Scheduler sched = schedFact.getScheduler(); sched.start(); // define the job and tie it to our HelloJob class JobDetail job = newJob(HelloJob.class)     .withIdentity(&quot;myJob&quot;, &quot;group1&quot;)     .build(); // Trigger the job to run now, and then every 40 seconds Trigger trigger = newTrigger()     .withIdentity(&quot;myTrigger&quot;, &quot;group1&quot;)     .startNow()     .withSchedule(simpleSchedule()         .withIntervalInSeconds(40)         .repeatForever())     .build(); // Tell quartz to schedule the job using our trigger sched.scheduleJob(job, trigger);</code></pre><p>你看到了，quartz的使用并不难。<a href="http://nkcoder.github.io/blog/20140624/quartz-tutorial-api-job-trigger/">教程二</a>会简要地介绍job和trigger，以及quartz的API，然后你会更好地理解上面的示例。</p><ul><li><a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-01" target="_blank" rel="external">原文链接</a></li><li>本系列教程由<a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials" target="_blank" rel="external">quartz-2.2.x官方文档</a>翻译、整理而来，希望给同样对quartz感兴趣的朋友一些参考和帮助，有任何不当或错误之处，欢迎指正；有兴趣研究源码的同学，可以参考<a href="https://github.com/nkcoder/quartz-explained" target="_blank" rel="external">我对quartz-core源码的注释(进行中)</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scheduler在使用之前需要实例化。一般通过SchedulerFactory来创建一个实例。有些用户将factory的实例保存在JNDI中，但直接初始化，然后使用该实例也许更简单（见下面的示例）。&lt;/p&gt;
&lt;p&gt;scheduler实例化后，可以启动(start)、暂停(stand-by)、停止(shutdown)。注意：scheduler被停止后，除非重新实例化，否则不能重新启动；只有当scheduler启动后，即使处于暂停状态也不行，trigger才会被触发（job才会被执行）。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="quartz" scheme="http://nkcoder.github.io/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>Quartz教程--快速入门</title>
    <link href="http://nkcoder.github.io/2014/06/22/quartz-tutorial-quickstart/"/>
    <id>http://nkcoder.github.io/2014/06/22/quartz-tutorial-quickstart/</id>
    <published>2014-06-22T02:11:23.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到quartz快速入门教程。阅读本教程，你将会了解：</p><ul><li>quartz下载</li><li>quartz安装</li><li>根据你的需要，配置Quartz</li><li>开始一个示例应用</li></ul><a id="more"></a><p>当熟悉了quratz调度的基本功能后，可以尝试一些更高级的特性，比如<a href="http://terracotta.org/documentation/quartz-scheduler/quartz-scheduler-where" target="_blank" rel="external">Where</a>，这个一个企业级功能，可以让job和trigger运行在指定的，而不是随机的Terracotta客户端上。</p><h2 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h2><p>首先，<a href="http://quartz-scheduler.org/downloads/" target="_blank" rel="external">下载最新的稳定版</a> - 不用注册。解压并安装。</p><h3 id="Quartz-jar文件"><a href="#Quartz-jar文件" class="headerlink" title="Quartz jar文件"></a>Quartz jar文件</h3><p>quartz安装包根目录的lib/目录下有很多的jar包。其中，quartz-xxx.jar（其中xxx是版本号）是最主要的。为了使用quartz，必须将该jar包放在应用的classpath下；</p><p>下载后，解压，然后将quartz-xxx.jar放到你的应用中。</p><p>我主要是在应用服务器的环境中使用quartz，所以一般将quartz jar包放到应用中（.ear或.war）。当然，如果你希望在很多应用中使用quartz，将quartz的jar包放在应用服务器(appserver)的classpath下即可。如果你只是希望在独立的应用中使用quartz，将quartz的jar包和你的应用依赖的其它jar包放在一起即可。</p><p>quzrtz依赖一些第三方的库（以jar包的形式），这些库位于quartz安装包的<code>lib</code>目录下。要使用quartz的所有功能，必须将所有的第三方jar包都放到classpath下。如果你开发的是一个独立的quartz应用，建议将所有的jar包都放到classpath下；如果是在应用服务器环境下使用quartz，其中有些包可能已经存在于classpath中了，因此你需要自己选择。</p><blockquote><p> 在应用服务器环境下，如果同一个jar文件，存在两个不同的版本，要注意，可能会产生一些奇怪的结果；比如，WebLogic包含了一个J2EE的实现（在weblogic.jar中），该实现与servlet.jar的实现可能不一致。此时，应该从你的应用中排除掉servlet.jar，这样你就知道使用的是哪个类了。</p></blockquote><h3 id="properties文件"><a href="#properties文件" class="headerlink" title="properties文件"></a>properties文件</h3><p>quartz使用名为quartz.properties的配置文件。刚开始时该配置文件不是必须的，但是为了使用最基本的配置，该文件必须位于classpath下。</p><p>基于我的个人情况举个例子，我的应用是基于WebLogic Workshop开发的。我将所有的配置文件（包括quartz.properties）放到应用根目录下的一个项目中。当我将项目打包成.ear文件时，放置配置文件的项目会以jar包的形式进入最终的.ear包，所以quartz.properties文件就自动位于classpath中了。</p><p>如果你准备构建一个使用quartz的web应用（以.war包的形式），你应该将quartz.properties文件放到WEB-INF/classes目录下。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>这里包含很多内容。quartz是一个配置很灵活的应用。配置quartz最好的方式是，编辑quartz.properties文件，然后放到应用的classpath下。</p><p>quartz的安装包中包含了一些配置文件的示例，位于example/目录下。我建议你创建自己的quartz.properties文件，而不是简单地从示例中拷贝并删除不需要的部分。这样看起来更整洁，而且你也会了解到quartz的更多功能。</p><p>关于quartz配置文件的详细文档，请查阅<a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/configuration" target="_blank" rel="external">Quartz配置参考</a></p><p>为了使用quartz，一个基本的quartz.properties配置文件如下所示：</p><pre><code>org.quartz.scheduler.instanceName = MySchedulerorg.quartz.threadPool.threadCount = 3org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore</code></pre><p>上述配置的scheduler有如下特点：</p><ul><li>org.quartz.scheduler.instanceName - scheduler的名称为“MyScheduler”</li><li>org.quartz.threadPool.threadCount - 线程池中有3个线程，即最多可以同时执行3个job；</li><li>org.quartz.jobStore.class - quartz的所有数据，包括job和trigger的配置，都会存储在内存中（而不是数据库里）。如果你想使用quartz的数据库存储功能，我们建议在使用数据库存储之前，先使用内存存储（RamJobStore）。</li></ul><h2 id="示例应用"><a href="#示例应用" class="headerlink" title="示例应用"></a>示例应用</h2><p>下载和安装完quartz后，是时候开发一个示例应用，并让它跑起来了。下面的示例代码，获取scheduler实例对象，启动，然后关闭。</p><p>QuartzTest.java</p><pre><code>import org.quartz.Scheduler;import org.quartz.SchedulerException;import org.quartz.impl.StdSchedulerFactory;import static org.quartz.JobBuilder.*;import static org.quartz.TriggerBuilder.*;import static org.quartz.SimpleScheduleBuilder.*;public class QuartzTest {    public static void main(String[] args) {        try {            // Grab the Scheduler instance from the Factory            Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();            // and start it off            scheduler.start();            scheduler.shutdown();        } catch (SchedulerException se) {            se.printStackTrace();        }    }}</code></pre><blockquote><p>当你调用StdSchedulerFactory.getDefaultScheduler()获取scheduler实例对象后，在调用scheduler.shutdown()之前，scheduler不会终止，因为还有活跃的线程在执行。</p></blockquote><p>注意示例代码中的静态导入(static import)，下面的代码中也会用到它们。</p><p>如果你没有配置日志输出，所有的日志会输出到控制台，比如：</p><pre><code>[INFO] 21 Jan 08:46:27.857 AM main [org.quartz.core.QuartzScheduler]Quartz Scheduler v.2.0.0-SNAPSHOT created.[INFO] 21 Jan 08:46:27.859 AM main [org.quartz.simpl.RAMJobStore]RAMJobStore initialized.[INFO] 21 Jan 08:46:27.865 AM main [org.quartz.core.QuartzScheduler]Scheduler meta-data: Quartz Scheduler (v2.0.0) &apos;Scheduler&apos; with instanceId &apos;NON_CLUSTERED&apos;  Scheduler class: &apos;org.quartz.core.QuartzScheduler&apos; - running locally.  NOT STARTED.  Currently in standby mode.  Number of jobs executed: 0  Using thread pool &apos;org.quartz.simpl.SimpleThreadPool&apos; - with 50 threads.  Using job-store &apos;org.quartz.simpl.RAMJobStore&apos; - which does not support persistence. and is not clustered.[INFO] 21 Jan 08:46:27.865 AM main [org.quartz.impl.StdSchedulerFactory]Quartz scheduler &apos;Scheduler&apos; initialized from default resource file in Quartz package: &apos;quartz.properties&apos;[INFO] 21 Jan 08:46:27.866 AM main [org.quartz.impl.StdSchedulerFactory]Quartz scheduler version: 2.0.0[INFO] 21 Jan 08:46:27.866 AM main [org.quartz.core.QuartzScheduler]Scheduler Scheduler_$_NON_CLUSTERED started.[INFO] 21 Jan 08:46:27.866 AM main [org.quartz.core.QuartzScheduler]Scheduler Scheduler_$_NON_CLUSTERED shutting down.[INFO] 21 Jan 08:46:27.866 AM main [org.quartz.core.QuartzScheduler]Scheduler Scheduler_$_NON_CLUSTERED paused.[INFO] 21 Jan 08:46:27.867 AM main [org.quartz.core.QuartzScheduler]Scheduler Scheduler_$_NON_CLUSTERED shutdown complete.</code></pre><p>你可以在start()和shutdown()之间做一些有趣的事情：</p><pre><code>// define the job and tie it to our HelloJob classJobDetail job = newJob(HelloJob.class)    .withIdentity(&quot;job1&quot;, &quot;group1&quot;)    .build();// Trigger the job to run now, and then repeat every 40 secondsTrigger trigger = newTrigger()    .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)    .startNow()    .withSchedule(simpleSchedule()            .withIntervalInSeconds(40)            .repeatForever())                .build();// Tell quartz to schedule the job using our triggerscheduler.scheduleJob(job, trigger);</code></pre><blockquote><p>在调用shutdown()之前，你需要给job的触发和执行预留一些时间，比如，你可以调用Thread.sleep(60000)让线程睡眠一段时间。</p></blockquote><p>好了，自己去探索吧！</p><ul><li><a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/quick-start" target="_blank" rel="external">原文链接</a></li><li>本系列教程由<a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials" target="_blank" rel="external">quartz-2.2.x官方文档</a>翻译、整理而来，希望给同样对quartz感兴趣的朋友一些参考和帮助，有任何不当或错误之处，欢迎指正；有兴趣研究源码的同学，可以参考<a href="https://github.com/nkcoder/quartz-explained" target="_blank" rel="external">我对quartz-core源码的注释(进行中)</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎来到quartz快速入门教程。阅读本教程，你将会了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;quartz下载&lt;/li&gt;
&lt;li&gt;quartz安装&lt;/li&gt;
&lt;li&gt;根据你的需要，配置Quartz&lt;/li&gt;
&lt;li&gt;开始一个示例应用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="quartz" scheme="http://nkcoder.github.io/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>Jetty9部署指南</title>
    <link href="http://nkcoder.github.io/2014/06/18/jetty-deploy-help/"/>
    <id>http://nkcoder.github.io/2014/06/18/jetty-deploy-help/</id>
    <published>2014-06-17T16:18:15.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简单有效的方式"><a href="#1-简单有效的方式" class="headerlink" title="1. 简单有效的方式"></a>1. 简单有效的方式</h2><p>把要部署的工程（war包、工程目录或者xml描述文件）放到${JETTY_HOME}的webapps目录下即可；</p><p>需要注意的是：</p><blockquote><p>jetty会对webapps目录下的几乎所有war包、目录、xml文件（有一些例外，如隐藏文件和.d结尾的目录等会被忽略）进行自动部署。<br>如果war包、目录和xml文件<strong>同名</strong>，则部署的顺序为xml文件 &gt; war包 &gt; 目录 。比如，webapps目录下有：rank.war，rank目录以及rank.xml，其中rank目录为rank.war解压后的目录，rank.xml中引用的是rank.war包或者rank目录，则此时，仅有xml文件被部署，这里成立的前提是<strong>同名</strong>，如果不同名，但它们是同一个工程，则会导致工程被重复部署，切记！（关于重复部署，参考前一篇博文：<a href="http://nkcoder.github.io/blog/20140522/jetty-avoid-repeat-deploy/">Jetty9避免重复部署</a>）</p></blockquote><p>我建议的做法是：将war包或解压后的目录放在webapps目录下，或者将xml描述文件放在webapps目录下，将war包或目录放在单独的目录里。</p><a id="more"></a><h2 id="2-配置context-path"><a href="#2-配置context-path" class="headerlink" title="2. 配置context path"></a>2. 配置context path</h2><p>默认，jetty将webapps目录下的工程名作为context path，如果工程名称为ROOT，则context path为/；比如，将rank.war（或rank目录）放在webapps目录下，则context path为/rank，如果将rank.war重命名为ROOT.war，则context path为/；</p><p>如果通过文件名来配置context path无法满足要求，则可以通过xml文件来配置，如将rank.xml放在webapps目录下，添加如下内容：</p><pre><code>&lt;?xml version=&quot;1.0&quot;  encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE Configure PUBLIC &quot;-//Jetty//Configure//EN&quot; &quot;http://www.eclipse.org/jetty/configure_9_0.dtd&quot;&gt;&lt;Configure class=&quot;org.eclipse.jetty.webapp.WebAppContext&quot;&gt;  &lt;Set name=&quot;contextPath&quot;&gt;/&lt;/Set&gt;  &lt;Set name=&quot;war&quot;&gt;/opt/www/ugc-base/webapps/RankByElasticSearch-1.0.war&lt;/Set&gt;&lt;/Configure&gt;</code></pre><p><em>contextPath</em>配置context path，<em>war</em>指定工程war包或目录的路径；</p><h2 id="3-jetty启动-停止"><a href="#3-jetty启动-停止" class="headerlink" title="3. jetty启动/停止"></a>3. jetty启动/停止</h2><p>建议通过${JETTY_HOME}下bin/jetty.sh脚本来启动/停止jetty，如：</p><pre><code>$ bin/jetty start$ bin/jetty stop</code></pre><p>当然，也可以通过start.jar来启动，如：</p><pre><code>$ java -jar start.jar</code></pre><p>如果希望通过start.jar停止，则在启动的时候需要指定STOP.PORT和STOP.KEY两个参数，且启动和停止时，两个参数的值必须匹配，如：</p><pre><code>$ java -jar start.jar STOP.PORT=8181 STOP.KEY=ugcKey$ java -jar start.jar STOP.PORT=8181 STOP.KEY=ugcKey --stop</code></pre><p>所以，一般通过bin/jetty.sh控制jetty的运行，使用start.jar查看jetty的配置和状态。</p><h2 id="4-配置jetty环境变量和jvm参数"><a href="#4-配置jetty环境变量和jvm参数" class="headerlink" title="4. 配置jetty环境变量和jvm参数"></a>4. 配置jetty环境变量和jvm参数</h2><p>通过bin/jetty.sh来控制jetty的运行，所以编辑bin/jetty.sh文件，可以配置的变量主要有：</p><pre><code>JAVA: 设置java命令的绝对路径，即jdk的bin目录下的java命令的路径，如果没设置，则从PATH环境变量中查找；JAVA_OPTIONS：设置jvm参数；JETTY_HOME：jetty的安装目录，如果没有设置，则从调用该脚本的上下文环境中猜测；JETTY_BASE：jetty的base目录，即当前工程使用的jetty环境的根目录，如果没有设置，则与JETTY_HOME相同；JETTY_RUN：配置保存jetty pid文件的路径，如果没有配置，根据以下顺序查找第一个可用目录：/var/run, /usr/var/run, JETTY_BASE, /tmp；JETTY_PID：pid文件路径，默认为：$JETTY_RUN/$NAME.pid（NAME变量表示启动jetty时，去掉扩展名的脚本名称）；JETTY_ARGS：jetty参数，如配置端口号等：JETTY_ARGS=8080 jetty.spdy.port=8443JETTY_USER：配置启动用户，如以nkcoder用户启动：JETTY_USER=nkcoder</code></pre><blockquote><p>注意：以上这些变量，虽然在jetty的运行环境下都具有默认值，但是在设置时，这些参数还是空的，即不能互相引用，比如，没有显式配置JETTY_BASE，直接配置JETTY_RUN=JETTY_BASE，则此时JETTY_RUN使用的还是默认值，因为JETTY_BASE此时为空。</p></blockquote><p>这里提供一个简单的配置供参考：</p><pre><code>JETTY_HOME=/usr/local/jetty9.1JETTY_BASE=$JETTY_HOMEJETTY_RUN=$JETTY_BASEJETTY_USER=wwwJETTY_ARGS=jetty.port=8989JAVA=/usr/local/jdk7/bin/javaJAVA_OPTIONS=&quot;-Xloggc:/opt/logs/vrsRank/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=10M -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:G1MaxNewSizePercent=50 -XX:PermSize=256m -XX:MaxPermSize=256m -Xss256k -server -Xms4G -Xmx4G -Dcom.sun.management.jmxremote=true -Dcom.sun.management.jmxremote.port=18787 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -XX:+UnlockCommercialFeatures -XX:+FlightRecorder -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/opt/logs/vrsRank/oom.log&quot;</code></pre><h2 id="5-查看jetty配置"><a href="#5-查看jetty配置" class="headerlink" title="5. 查看jetty配置"></a>5. 查看jetty配置</h2><p>通过start.jar查看帮助和配置：</p><pre><code>$ java -jar start.jar --help</code></pre><p>主要的查看配置的参数有：</p><pre><code>--list-config: 查看启动jetty使用的配置：java环境，jetty环境，JVM参数，属性，服务器classpath，服务器的xml配置等；--list-modules: 查看系统使用的模块--list-classpath: 查看系统使用的classpath--version：查看版本信息--module=&lt;model-name&gt;：临时启用一个模块</code></pre><h2 id="6-一台机器上同时部署多个jetty"><a href="#6-一台机器上同时部署多个jetty" class="headerlink" title="6. 一台机器上同时部署多个jetty"></a>6. 一台机器上同时部署多个jetty</h2><p>以在一台服务器上同时部署两个工程为例，需要两份jetty和一份jdk。和单独部署的唯一区别就是，只要确保pid和port是不同的即可。</p><p>第一种方式：修改jetty.sh脚本的名称，因为pid文件的名称就是脚本的名称，如：</p><p>工程1使用jetty1，将bin/jetty.sh重命名为bin/jetty1.sh，同时修改其配置如下（注意不用配置JETTY_RUN变量）：</p><pre><code>JETTY_HOME=/usr/local/jetty1JETTY_BASE=$JETTY_HOMEJETTY_USER=wwwJETTY_ARGS=jetty.port=8181JAVA=/usr/local/jdk7/bin/javaJAVA_OPTIONS=&quot;-Xloggc:/opt/logs/ugcRank/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps&quot;</code></pre><p>工程2使用jetty2，将bin/jetty.sh重命名为bin/jetty2.sh，并修改配置：</p><pre><code>JETTY_HOME=/usr/local/jetty2JETTY_BASE=$JETTY_HOMEJETTY_USER=wwwJETTY_ARGS=jetty.port=8282JAVA=/usr/local/jdk7/bin/javaJAVA_OPTIONS=&quot;-Xloggc:/opt/logs/vrsRank/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps&quot;</code></pre><p>此时，两个jetty的pid均位于默认的目录下，即/var/run，路径分别为/var/run/jetty1.pid，/var/run/jetty2.pid。</p><p>第二种方式：修改pid文件保存的目录，该目录由JETTY_RUN配置，默认都在/var/run下，如：</p><p>工程1使用jetty1，修改bin/jetty.sh如下：</p><pre><code>JETTY_HOME=/usr/local/jetty1JETTY_BASE=$JETTY_HOMEJETTY_RUN=$JETTY_BASEJETTY_USER=wwwJETTY_ARGS=jetty.port=8181JAVA=/usr/local/jdk7/bin/javaJAVA_OPTIONS=&quot;-Xloggc:/opt/logs/ugcRank/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps&quot;</code></pre><p>工程2使用jetty2，修改bin/jetty.sh如下：</p><pre><code>JETTY_HOME=/usr/local/jetty1JETTY_BASE=$JETTY_HOMEJETTY_RUN=$JETTY_BASEJETTY_USER=wwwJETTY_ARGS=jetty.port=8181JAVA=/usr/local/jdk7/bin/javaJAVA_OPTIONS=&quot;-Xloggc:/opt/logs/ugcRank/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps&quot;</code></pre><p>此时，pid文件位于各自jetty的安装目录下，虽然都为jetty.pid，但是互不影响。</p><h2 id="7-将jetty配置为系统服务"><a href="#7-将jetty配置为系统服务" class="headerlink" title="7. 将jetty配置为系统服务"></a>7. 将jetty配置为系统服务</h2><p>首先，将bin/jetty.sh拷贝到/etc/init.d中：</p><pre><code>$ cp bin/jetty.sh /etc/init.d/jetty</code></pre><p>然后，新建文件/etc/default/jetty，在其中设置环境变量JETTY_HOME：</p><pre><code>$ vim /etc/default/jettyJETTY_HOME=/usr/local/jetty9.1</code></pre><p>启动和停止：</p><pre><code>$ service jetty start$ service jetty stop</code></pre><p>说明：bin/jetty.sh默认将/etc/default/{pid}作为其配置文件，此时pid名称即为jetty，所以/etc/default/jetty会作为jetty的配置文件，可以在其中配置JETTY_HOME, JAVA, JAVA_OPTIONS等环境变量。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol><li><a href="http://www.eclipse.org/jetty/documentation/current/index.html" target="_blank" rel="external">Jetty : The Definitive Reference</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简单有效的方式&quot;&gt;&lt;a href=&quot;#1-简单有效的方式&quot; class=&quot;headerlink&quot; title=&quot;1. 简单有效的方式&quot;&gt;&lt;/a&gt;1. 简单有效的方式&lt;/h2&gt;&lt;p&gt;把要部署的工程（war包、工程目录或者xml描述文件）放到${JETTY_HOME}的webapps目录下即可；&lt;/p&gt;
&lt;p&gt;需要注意的是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;jetty会对webapps目录下的几乎所有war包、目录、xml文件（有一些例外，如隐藏文件和.d结尾的目录等会被忽略）进行自动部署。&lt;br&gt;如果war包、目录和xml文件&lt;strong&gt;同名&lt;/strong&gt;，则部署的顺序为xml文件 &amp;gt; war包 &amp;gt; 目录 。比如，webapps目录下有：rank.war，rank目录以及rank.xml，其中rank目录为rank.war解压后的目录，rank.xml中引用的是rank.war包或者rank目录，则此时，仅有xml文件被部署，这里成立的前提是&lt;strong&gt;同名&lt;/strong&gt;，如果不同名，但它们是同一个工程，则会导致工程被重复部署，切记！（关于重复部署，参考前一篇博文：&lt;a href=&quot;http://nkcoder.github.io/blog/20140522/jetty-avoid-repeat-deploy/&quot;&gt;Jetty9避免重复部署&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我建议的做法是：将war包或解压后的目录放在webapps目录下，或者将xml描述文件放在webapps目录下，将war包或目录放在单独的目录里。&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="jetty" scheme="http://nkcoder.github.io/tags/jetty/"/>
    
  </entry>
  
  <entry>
    <title>算法练习--扑克牌构成顺子</title>
    <link href="http://nkcoder.github.io/2014/06/04/algorithm-straight-poker/"/>
    <id>http://nkcoder.github.io/2014/06/04/algorithm-straight-poker/</id>
    <published>2014-06-04T15:20:29.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述："><a href="#1-问题描述：" class="headerlink" title="1. 问题描述："></a>1. 问题描述：</h2><blockquote><p>从扑克牌里抽出任意5张牌，其中J, Q, K分表表示11, 12, 13，A表示1，大小王可以表示任意点数。求该5张牌是否可以构成顺子。</p></blockquote><a id="more"></a><h2 id="2-思路："><a href="#2-思路：" class="headerlink" title="2. 思路："></a>2. 思路：</h2><blockquote><p>思路：<br>思路一：首先求出抽出的5张牌中，大小王的数量，然后将其它的牌按点数排序，计算它们之间的空隙，<br>如果空隙数小于王牌的数量，则表示可以构成顺子；否则，不能构成顺子。复杂度O(n)。<br>思路二：特殊牌做特殊处理，将大小王的点数当做0，求出最大点数和最小点数（非0），如果最大点数<br>和最小点数之间的差值小于5（抽出的牌的总数量），则表示可以构成顺子，否则不能；注意：为了方便<br>排重，因为牌的数量小，可以先排序，然后排重，最后比较。复杂度O(n)。</p></blockquote><h2 id="3-Java参考代码"><a href="#3-Java参考代码" class="headerlink" title="3. Java参考代码"></a>3. Java参考代码</h2><pre><code>/** * 检查抽出的n张牌是否可以构成顺子 * @param cards 表示抽出的牌的数组 * @param length    抽出的牌的数量 * @return  是否可以构成顺子 */public boolean checkStraightPoker(int[] cards, int length) {    // 桶排序    int[] allCards = new int[ALL_CARDS_SIZE];    for (int i = 0; i &lt; length; i++) {        allCards[cards[i]]++;    }    // 牌的排重    for (int i = 1; i &lt; ALL_CARDS_SIZE; i++) {        if (allCards[i] &gt; 1) {            logger.error(&quot;identical cards exists.&quot;);            return false;        }    }    // 查找最小索引（非0）    int firstIndex = 1;    while (0 == allCards[firstIndex]) {        firstIndex ++;    }    // 查找最大索引（非0）    int lastIndex = ALL_CARDS_SIZE - 1;    while (0 == allCards[lastIndex]) {        lastIndex --;    }    // 构成顺子的条件    if ((lastIndex - firstIndex + 1) &lt;= length) {        return true;    }    return false;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题描述：&quot;&gt;&lt;a href=&quot;#1-问题描述：&quot; class=&quot;headerlink&quot; title=&quot;1. 问题描述：&quot;&gt;&lt;/a&gt;1. 问题描述：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;从扑克牌里抽出任意5张牌，其中J, Q, K分表表示11, 12, 13，A表示1，大小王可以表示任意点数。求该5张牌是否可以构成顺子。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://nkcoder.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://nkcoder.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法练习--合并两个有序单链表</title>
    <link href="http://nkcoder.github.io/2014/05/25/algorithm-merge-two-sorted-list/"/>
    <id>http://nkcoder.github.io/2014/05/25/algorithm-merge-two-sorted-list/</id>
    <published>2014-05-25T02:42:57.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述："><a href="#1-问题描述：" class="headerlink" title="1. 问题描述："></a>1. 问题描述：</h2><blockquote><p>给定两个单链表，都是递增有序的，将它们合并，使合并后的链表仍然有序。</p></blockquote><a id="more"></a><h2 id="2-思路："><a href="#2-思路：" class="headerlink" title="2. 思路："></a>2. 思路：</h2><blockquote><p>思路：<br>先比较两个单链表的第一个节点，值小的的节点作为合并后新链表的第一个节点；值小的节点的下一个<br>节点作为该单链表的新的头节点。相当于第一个节点已排好序，剩下的问题仍然是对两个有序链表进行<br>合并，则可以用递归的思路解决。</p></blockquote><h2 id="3-Java参考代码"><a href="#3-Java参考代码" class="headerlink" title="3. Java参考代码"></a>3. Java参考代码</h2><pre><code>/** * 合并两个有序单链表 * @param firstHead     第一个单链表的头节点 * @param secondHead    第二个单链表的头节点 * @return  合并后的链表的头节点 */public static ListNode merge(ListNode firstHead, ListNode secondHead) {    // 退出条件    if (firstHead == null) {        return secondHead;    }    if (secondHead == null) {        return firstHead;    }    // 比较两个单链表的第一个节点，值小的节点作为合并后的链表的节点    ListNode currentHead = null;    if (firstHead.value &lt; secondHead.value) {        currentHead = firstHead;        currentHead.next = merge(firstHead.next, secondHead);    } else {        currentHead = secondHead;        currentHead.next = merge(firstHead, secondHead.next);    }    return currentHead;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题描述：&quot;&gt;&lt;a href=&quot;#1-问题描述：&quot; class=&quot;headerlink&quot; title=&quot;1. 问题描述：&quot;&gt;&lt;/a&gt;1. 问题描述：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个单链表，都是递增有序的，将它们合并，使合并后的链表仍然有序。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://nkcoder.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://nkcoder.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Jetty9避免重复部署</title>
    <link href="http://nkcoder.github.io/2014/05/22/jetty-avoid-repeat-deploy/"/>
    <id>http://nkcoder.github.io/2014/05/22/jetty-avoid-repeat-deploy/</id>
    <published>2014-05-22T14:34:28.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>jetty是一个轻量级的web容器，部署简单，同时高度可定制化。由于刚接触，对其约定和配置不太熟练，在自动部署时，跳过一次重复部署的坑，这里简要说明一下，希望给同样打算在项目中使用jetty9的朋友一个参考。</p><p>默认情况下，jetty会对根目录(也可以配置jetty.base)下webapps/目录下的内容实现自动部署，部署的规则如下：</p><a id="more"></a><ol><li>隐藏文件(.开头)和.d结尾的目录被忽略；</li><li>CVS目录如”CVS”和”CVSROOT”被忽略；</li><li>任何war包都会被自动部署；</li><li>任何xml描述文件被认为是可部署的；</li><li>任何目录都被认为是可部署的；</li><li>同名的war包和目录同时存在，目录不被部署，仅war包部署，且认为war包引用该目录；</li><li>同名的war包和xml文件同时存在，war包不被部署，仅xml文件描述符被部署，且认为该xml文件引用该war包；</li><li>同名的目录和xml文件同时存在，目录不被部署，xml文件被部署，且认为xml文件引用该目录；</li></ol><p>关于更详细的说明，请参考官方文档的<a href="http://www.eclipse.org/jetty/documentation/current/deployment-architecture.html" target="_blank" rel="external">这里</a>。我主要提醒的是：在webapps目录中，如果存在同名的目录、war包和xml文件，它们会被当做同一个工程，部署的优先级是<code>xml文件&gt;war包&gt;目录</code>。一定要注意同名，如果不同名，在webapps下存在一个war包，同时存在一个引用该war包的xml文件，则会导致重复部署，这就是我跳的坑。</p><p>部署时，推荐的做法是，将xml描述文件放到自动部署的webapps目录下，里面定义war包的路径、上下文路径、是否解压、临时目录、日志文件等，然后将war包放在自定义的固定目录下，项目更新，只需要备份和替换war包，重启jetty即可。</p><p>参考：</p><ol><li><a href="http://www.eclipse.org/jetty/documentation/current/deployment-architecture.html" target="_blank" rel="external">Deployment Architecture</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jetty是一个轻量级的web容器，部署简单，同时高度可定制化。由于刚接触，对其约定和配置不太熟练，在自动部署时，跳过一次重复部署的坑，这里简要说明一下，希望给同样打算在项目中使用jetty9的朋友一个参考。&lt;/p&gt;
&lt;p&gt;默认情况下，jetty会对根目录(也可以配置jetty.base)下webapps/目录下的内容实现自动部署，部署的规则如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Backend" scheme="http://nkcoder.github.io/categories/Backend/"/>
    
    
      <category term="jetty" scheme="http://nkcoder.github.io/tags/jetty/"/>
    
  </entry>
  
  <entry>
    <title>算法练习--环中最后的数字</title>
    <link href="http://nkcoder.github.io/2014/05/22/algorithm-last-num-in-circle/"/>
    <id>http://nkcoder.github.io/2014/05/22/algorithm-last-num-in-circle/</id>
    <published>2014-05-21T16:00:43.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述："><a href="#1-问题描述：" class="headerlink" title="1. 问题描述："></a>1. 问题描述：</h2><blockquote><p>有n个数，从0到n-1，形成环状，即n-1后的数字为0；从0开始，每次从环中删除第m个数，然后<br>将删除元素的下一个元素作为第一个元素。如此循环，求最后剩下的数。</p></blockquote><a id="more"></a><h2 id="2-思路："><a href="#2-思路：" class="headerlink" title="2. 思路："></a>2. 思路：</h2><blockquote><p>思路：</p><p><em>思路一</em>：构造环形链表，每个节点有两个属性，一个是值，另一个是指向下一个元素的指针。每次从<br>环中删除第m个元素，直到链表中剩下一个元素。复杂度O(m*n)；</p><p><em>思路二</em>：也是用链表模拟环，使用标准库的LinkedList，每次遍历到最后一个元素后，继续遍历链表<br>第一个元素；</p><p><em>思路三</em>：寻找规律：f(n,m)表示从n个数(0,1,2,…,n-1)的环中删除第m个数后剩下的数；第一<br>次删掉了的元素为k（显然，k=m-1），剩下的元素为(k+1,k+2,…,n-1, 0, 1, …,k-1)，此时<br>的序列有n-1个元素，但排列不同，从该序列每次删除第m个元素后最后剩下的元素记为f’(n-1,m)，则有<br><code>f(n,m)=f&#39;(n-1,m)</code>，但是我们将<code>f&#39;(n-1,m)与f(n-1,m)</code>（序列为0,1,2,…,n-2)做一下映射，找规律：</p></blockquote><pre><code>f&apos;(n-1,m)       f(n-1,m)k+1             0k+2             1...             ...k-2             n-3k-1             n-2</code></pre><blockquote><p>发现的映射规律为：<code>[f(n-1,m) + (k+1)] % n = f&#39;(n-1,m)</code><br>将该公式以及(k=m-1)与f(n,m)=f’(n-1,m)组合，有：<br><code>f(n,m) = [f(n-1)+m]%n</code>，<br>即如果要求f(n,m)，可以先求f(n-1)，得到的递归公式为：</p></blockquote><pre><code>f(n,m) = [f(n-1,m)+m]%n, (n=1时 f(n,m)=0)</code></pre><blockquote><p>利用该公式，使用递归或者循环很容易解决。复杂度O(n)</p></blockquote><h2 id="3-Java参考代码"><a href="#3-Java参考代码" class="headerlink" title="3. Java参考代码"></a>3. Java参考代码</h2><pre><code>/** * 自定义链表节点，形成环状，每次从环中删除第m个节点，直到环中只剩下一个节点 * @param head  头节点 * @param m 要删除的第m个节点 * @return  最后剩下的节点 */public ListNode ListNodeMethod(ListNode head, int m) {    if (null == head || m &lt;= 0) {        return null;    }    // 寻找链表最后一个节点    ListNode loopNode = head;    while (null != loopNode.next) {        loopNode = loopNode.next;    }    // 如果每次都是删除第一个节点，则返回的应该是最后一个节点    if (m == 1) {        return head;    }    // 否则形成环状    loopNode.next = head;    // 循环删除，直到最后只剩下一个节点    while (head.next != head) {        // 先找到第m-1个节点        ListNode preNode = head;        for (int i = 0; i &lt; m - 2; i++) {            preNode = preNode.next;        }        // 删除第m个节点        preNode.next = preNode.next.next;        // 修改起点        head = preNode.next;    }    return head;}/** * 使用标准库的LinkedList模拟环形链表，遍历到最后一个元素后，返回到第一个元素，继续 * @param numberList    包含n个数的链表 * @param m 要删除的第m个数 * @return  最后剩下的元素 */public int LinkedListMethod(LinkedList&lt;Integer&gt; numberList, int m) {    if (null == numberList || 0 == numberList.size()) {        return -1;    }    int n = numberList.size();    int start = 0;    while (n &gt; 1) {        // 要删除的元素        int delIndex = (start + m - 1) % n;        numberList.remove(delIndex);        n = numberList.size();        // 删除元素后，该索引对应的即为下一个元素        start = delIndex;        if (start &gt;= n) {            start = 0;        }    }    return numberList.getLast();}/** * 使用循环实现由规律得出的公式： *      f(n,m) = f&apos;(n-1,m) = (f(n-1,m)+m) % n; * 因为数组的下标索引从0到n-1，所以返回的值即为最后元素在数组中的索引 * @param m 要删除的第m个元素 * @param n 数组的大小 * @return  数组中最后一个元素的索引 */public int loopMethod(int m, int n) {    // 只有一个元素：f(1,m) = 0;    int last = 0;    // 有n个元素：f(n,m) = (f(n-1,m) + m) % n;    for (int i = 2; i &lt;= n; i++) {        last = (last + m) % i;    }    return last;}/** * 使用递归实现由规律得到的公式： *      f(n,m) = (f(n-1,m) + m) % n * 因为数组的下标索引从0到n-1，所以返回的值即为最后元素在数组中的索引 * @param m 要删除的第m个元素 * @param n 数组中元素的个数 * @return  最后一个元素在数组里的索引 */public int recursiveMethod(int n, int m) {    if (1 == n) {        return 0;    }    return (recursiveMethod(n-1, m) + m) % n;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题描述：&quot;&gt;&lt;a href=&quot;#1-问题描述：&quot; class=&quot;headerlink&quot; title=&quot;1. 问题描述：&quot;&gt;&lt;/a&gt;1. 问题描述：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;有n个数，从0到n-1，形成环状，即n-1后的数字为0；从0开始，每次从环中删除第m个数，然后&lt;br&gt;将删除元素的下一个元素作为第一个元素。如此循环，求最后剩下的数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://nkcoder.github.io/categories/Algorithm/"/>
    
    
      <category term="array" scheme="http://nkcoder.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>算法练习--返回链表中倒数第K个节点</title>
    <link href="http://nkcoder.github.io/2014/05/18/algorithm-find-kth-node/"/>
    <id>http://nkcoder.github.io/2014/05/18/algorithm-find-kth-node/</id>
    <published>2014-05-18T15:51:04.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述："><a href="#1-问题描述：" class="headerlink" title="1. 问题描述："></a>1. 问题描述：</h2><blockquote><p>返回链表中倒数第k个节点。</p></blockquote><a id="more"></a><h2 id="2-思路："><a href="#2-思路：" class="headerlink" title="2. 思路："></a>2. 思路：</h2><blockquote><p>思路：<br>使用两个指针，第一个指针先走(k-1)步，第二个指针不动，此时两个指针相差k个节点；然后两个指针同时向前走，直到第一个指针<br>到达链表尾节点，此时第二个指针即为链表的倒数第k个节点。<br>注意：需要考虑到链表不够k个节点的情况。</p></blockquote><h2 id="3-Java参考代码"><a href="#3-Java参考代码" class="headerlink" title="3. Java参考代码"></a>3. Java参考代码</h2><pre><code>/** * 查找链表中倒数第k个节点 * @param head  链表的头节点 * @param k 倒数第k个节点 * @return */public static ListNode find(ListNode head, int k) {    if (head == null || k &lt;= 0) {        return null;    }    // 第一个节点先向前走k-1步    ListNode firstNode = head;    int i = 0;    while ((i &lt; k -1) &amp;&amp; (firstNode.next != null)) {            firstNode = firstNode.next;            i++;    }    // 链表的长度小于k    if (i != k - 1) {        return null;    }    // 两个节点同时走，直到第一个节点到达尾节点    ListNode secondNode = head;    while (firstNode.next != null) {        firstNode = firstNode.next;        secondNode = secondNode.next;    }    return secondNode;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题描述：&quot;&gt;&lt;a href=&quot;#1-问题描述：&quot; class=&quot;headerlink&quot; title=&quot;1. 问题描述：&quot;&gt;&lt;/a&gt;1. 问题描述：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;返回链表中倒数第k个节点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://nkcoder.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://nkcoder.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法练习--根据对角线打印矩阵</title>
    <link href="http://nkcoder.github.io/2014/05/16/algorithm-print-matrix-diagonally/"/>
    <id>http://nkcoder.github.io/2014/05/16/algorithm-print-matrix-diagonally/</id>
    <published>2014-05-16T15:41:54.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述："><a href="#1-问题描述：" class="headerlink" title="1. 问题描述："></a>1. 问题描述：</h2><blockquote><p>输入一个矩阵，从右上角开始按照斜对角线打印矩阵的值，如矩阵为：</p></blockquote><pre><code>1, 2,  3,  45, 6,  7,  89, 10, 11, 1213,14, 15, 16</code></pre><blockquote><p>输出：</p></blockquote><pre><code>4, 3, 8, 2, 7, 12, 1, 6, 11, 16, 5, 10, 15, 9, 14, 13</code></pre><a id="more"></a><h2 id="2-思路："><a href="#2-思路：" class="headerlink" title="2. 思路："></a>2. 思路：</h2><blockquote><p>思路：<br>将整个输出以最长的斜对角线分为两部分：右上部分和左下部分。<br>右上部分：对角线的起点在第一行，列数递减，对角线上相邻元素之间横坐标和纵坐标均相差1；<br>左下部分：对角线的起点在第一列上，行数递减，对角线上相邻元素之间横坐标和纵坐标均相差1；<br>复杂度：O(n^2)</p></blockquote><h2 id="3-Java参考代码"><a href="#3-Java参考代码" class="headerlink" title="3. Java参考代码"></a>3. Java参考代码</h2><pre><code> /** * 以对角线的方式打印n*n矩阵 * @param data  矩阵数组 * @param n 矩阵的维度 */public void print(int[][] data, int n) {    // 打印右上部分    for (int i = n - 1; i &gt;= 0; i--) {        int row = 0;        int col = i;        while ((row &gt;= 0 &amp;&amp; row &lt; n) &amp;&amp; (col &gt;= 0 &amp;&amp; col &lt; n)) {            System.out.println(data[row][col]);            row++;            col++;        }    }    // 打印左下部分    for (int i = 1; i &lt; n; i++) {        int row = i;        int col = 0;        while ((row &gt;= 0 &amp;&amp; row &lt; n) &amp;&amp; (col &gt;= 0 &amp;&amp; col &lt; n)) {            System.out.println(data[row][col]);            row++;            col++;        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题描述：&quot;&gt;&lt;a href=&quot;#1-问题描述：&quot; class=&quot;headerlink&quot; title=&quot;1. 问题描述：&quot;&gt;&lt;/a&gt;1. 问题描述：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入一个矩阵，从右上角开始按照斜对角线打印矩阵的值，如矩阵为：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;1, 2,  3,  4
5, 6,  7,  8
9, 10, 11, 12
13,14, 15, 16
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;4, 3, 8, 2, 7, 12, 1, 6, 11, 16, 5, 10, 15, 9, 14, 13
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://nkcoder.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://nkcoder.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法练习--从链表中删除一个节点</title>
    <link href="http://nkcoder.github.io/2014/05/16/algorithm-del-one-node-from-linklist/"/>
    <id>http://nkcoder.github.io/2014/05/16/algorithm-del-one-node-from-linklist/</id>
    <published>2014-05-16T14:31:03.000Z</published>
    <updated>2017-09-17T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述："><a href="#1-问题描述：" class="headerlink" title="1. 问题描述："></a>1. 问题描述：</h2><blockquote><p>给定一个链表和其中一个节点，删除该节点；</p></blockquote><a id="more"></a><h2 id="2-思路："><a href="#2-思路：" class="headerlink" title="2. 思路："></a>2. 思路：</h2><blockquote><p>思路：<br>节点的差异体现在节点对象的内容不同。要删除当前节点，可以将当前节点与下一节点的值互换，然后删除下一个节点即可。<br>需要注意的是，如果要删除的节点是最后一个节点，没有下一个节点，此时需要从头遍历了。如果要删除的节点不是最后一<br>个节点，复杂度为O(1)，否则复杂度为O(n)，平均复杂度为O(1)。</p></blockquote><h2 id="3-Java参考代码"><a href="#3-Java参考代码" class="headerlink" title="3. Java参考代码"></a>3. Java参考代码</h2><pre><code>/** * 从链表中删除某一个节点 * @param head  链表的头节点 * @param toDelete  要删除的节点 * @return 头节点 */public static ListNode delete(ListNode head, ListNode toDelete) {    // param error    if (head == null || toDelete == null) {        return head;    }    // 最后一个节点    if (toDelete.next == null) {        // 也是头节点        if (head == toDelete) {            return null;        }        // 遍历查找前一个节点        ListNode node = head;        while (node.next != toDelete) {            node = node.next;        }        node.next = node.next.next;        return head;    }    // 不是最后一个节点，将下一个节点的值覆盖当前节点的值，删除下一个节点    toDelete.value = toDelete.next.value;    toDelete.next = toDelete.next.next;    return head;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题描述：&quot;&gt;&lt;a href=&quot;#1-问题描述：&quot; class=&quot;headerlink&quot; title=&quot;1. 问题描述：&quot;&gt;&lt;/a&gt;1. 问题描述：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个链表和其中一个节点，删除该节点；&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://nkcoder.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://nkcoder.github.io/tags/algorithm/"/>
    
  </entry>
  
</feed>
